package quota

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/quota/mgmt/2020-10-25/quota"

// CreateGenericQuotaRequestParameters quota change requests information.
type CreateGenericQuotaRequestParameters struct {
	// Value - Quota change requests.
	Value *[]CurrentQuotaLimitBase `json:"value,omitempty"`
}

// CreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type CreateOrUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *CreateOrUpdateFuture) Result(client Client) (so SetObject, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "quota.CreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("quota.CreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if so.Response.Response, err = future.GetResult(sender); err == nil && so.Response.Response.StatusCode != http.StatusNoContent {
		so, err = client.CreateOrUpdateResponder(so.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "quota.CreateOrUpdateFuture", "Result", so.Response.Response, "Failure responding to request")
		}
	}
	return
}

// CurrentQuotaLimit quota limits.
type CurrentQuotaLimit struct {
	// CurrentQuotaLimitBase - Quota information detail.
	*CurrentQuotaLimitBase `json:"quotaInformation,omitempty"`
	// RequestStatusDetails - Addition properties for the quota request status for the resource.
	*RequestStatusDetails `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for CurrentQuotaLimit.
func (cql CurrentQuotaLimit) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cql.CurrentQuotaLimitBase != nil {
		objectMap["quotaInformation"] = cql.CurrentQuotaLimitBase
	}
	if cql.RequestStatusDetails != nil {
		objectMap["properties"] = cql.RequestStatusDetails
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CurrentQuotaLimit struct.
func (cql *CurrentQuotaLimit) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "quotaInformation":
			if v != nil {
				var currentQuotaLimitBase CurrentQuotaLimitBase
				err = json.Unmarshal(*v, &currentQuotaLimitBase)
				if err != nil {
					return err
				}
				cql.CurrentQuotaLimitBase = &currentQuotaLimitBase
			}
		case "properties":
			if v != nil {
				var requestStatusDetails RequestStatusDetails
				err = json.Unmarshal(*v, &requestStatusDetails)
				if err != nil {
					return err
				}
				cql.RequestStatusDetails = &requestStatusDetails
			}
		}
	}

	return nil
}

// CurrentQuotaLimitBase quota limits.
type CurrentQuotaLimitBase struct {
	autorest.Response `json:"-"`
	// Properties - Quota properties for the resource.
	Properties *Properties `json:"properties,omitempty"`
}

// ExceptionResponse the api error.
type ExceptionResponse struct {
	// Error - The api error details.
	Error *ServiceError `json:"error,omitempty"`
}

// Limits quota limits.
type Limits struct {
	autorest.Response `json:"-"`
	// Value - List of Quota limits.
	Value *[]CurrentQuotaLimitBase `json:"value,omitempty"`
	// NextLink - The uri to fetch the next page of quota limits. When there are no more pages, this is null.
	NextLink *string `json:"nextLink,omitempty"`
}

// LimitsIterator provides access to a complete listing of CurrentQuotaLimitBase values.
type LimitsIterator struct {
	i    int
	page LimitsPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *LimitsIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LimitsIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *LimitsIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter LimitsIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter LimitsIterator) Response() Limits {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter LimitsIterator) Value() CurrentQuotaLimitBase {
	if !iter.page.NotDone() {
		return CurrentQuotaLimitBase{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the LimitsIterator type.
func NewLimitsIterator(page LimitsPage) LimitsIterator {
	return LimitsIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (l Limits) IsEmpty() bool {
	return l.Value == nil || len(*l.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (l Limits) hasNextLink() bool {
	return l.NextLink != nil && len(*l.NextLink) != 0
}

// limitsPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (l Limits) limitsPreparer(ctx context.Context) (*http.Request, error) {
	if !l.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(l.NextLink)))
}

// LimitsPage contains a page of CurrentQuotaLimitBase values.
type LimitsPage struct {
	fn func(context.Context, Limits) (Limits, error)
	l  Limits
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *LimitsPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LimitsPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.l)
		if err != nil {
			return err
		}
		page.l = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *LimitsPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page LimitsPage) NotDone() bool {
	return !page.l.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page LimitsPage) Response() Limits {
	return page.l
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page LimitsPage) Values() []CurrentQuotaLimitBase {
	if page.l.IsEmpty() {
		return nil
	}
	return *page.l.Value
}

// Creates a new instance of the LimitsPage type.
func NewLimitsPage(cur Limits, getNextPage func(context.Context, Limits) (Limits, error)) LimitsPage {
	return LimitsPage{
		fn: getNextPage,
		l:  cur,
	}
}

// LimitsResponse quota limits request response.
type LimitsResponse struct {
	// Value - List of Quota limits with the quota request status.
	Value *[]CurrentQuotaLimit `json:"value,omitempty"`
	// NextLink - The uri to fetch the next page of quota limits. When there are no more pages, this is null.
	NextLink *string `json:"nextLink,omitempty"`
}

// Properties quota properties for the resource.
type Properties struct {
	// Limit - The quota limit.
	Limit *int32 `json:"limit,omitempty"`
	// CurrentValue - READ-ONLY; The current resource usages information.
	CurrentValue *int32 `json:"currentValue,omitempty"`
	// Unit -  The units of the limit, such as - Count, Bytes, etc. Use the unit field provided in the Get quota response.
	Unit *string `json:"unit,omitempty"`
	// Name - Name of the resource provide by the resource Provider. Please use this name property for quotaRequests.
	Name *ResourceName `json:"name,omitempty"`
	// ResourceType - The Resource Type Name.
	ResourceType interface{} `json:"resourceType,omitempty"`
	// QuotaPeriod - READ-ONLY; The quota period over which the usage values are summarized, such as - P1D (Per one day), PT1M (Per one minute), PT1S (Per one second). This parameter is optional because, for some resources like compute, the period doesnâ€™t matter.
	QuotaPeriod *string `json:"quotaPeriod,omitempty"`
	// Properties - Additional properties for the specific resource provider.
	Properties interface{} `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for Properties.
func (p Properties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.Limit != nil {
		objectMap["limit"] = p.Limit
	}
	if p.Unit != nil {
		objectMap["unit"] = p.Unit
	}
	if p.Name != nil {
		objectMap["name"] = p.Name
	}
	if p.ResourceType != nil {
		objectMap["resourceType"] = p.ResourceType
	}
	if p.Properties != nil {
		objectMap["properties"] = p.Properties
	}
	return json.Marshal(objectMap)
}

// RequestDetails the details of the quota Request.
type RequestDetails struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The quota request Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the quota request.
	Name *string `json:"name,omitempty"`
	// RequestProperties - The quota request details.
	*RequestProperties `json:"properties,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/ServiceLimits"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for RequestDetails.
func (rd RequestDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rd.RequestProperties != nil {
		objectMap["properties"] = rd.RequestProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RequestDetails struct.
func (rd *RequestDetails) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rd.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rd.Name = &name
			}
		case "properties":
			if v != nil {
				var requestProperties RequestProperties
				err = json.Unmarshal(*v, &requestProperties)
				if err != nil {
					return err
				}
				rd.RequestProperties = &requestProperties
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rd.Type = &typeVar
			}
		}
	}

	return nil
}

// RequestDetailsList quota requests information.
type RequestDetailsList struct {
	autorest.Response `json:"-"`
	// Value - The quota Requests.
	Value *[]RequestDetails `json:"value,omitempty"`
	// NextLink - The uri to fetch the next page of quota limits. When there are no more pages, this is null.
	NextLink *string `json:"nextLink,omitempty"`
}

// RequestDetailsListIterator provides access to a complete listing of RequestDetails values.
type RequestDetailsListIterator struct {
	i    int
	page RequestDetailsListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RequestDetailsListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RequestDetailsListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RequestDetailsListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RequestDetailsListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RequestDetailsListIterator) Response() RequestDetailsList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RequestDetailsListIterator) Value() RequestDetails {
	if !iter.page.NotDone() {
		return RequestDetails{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RequestDetailsListIterator type.
func NewRequestDetailsListIterator(page RequestDetailsListPage) RequestDetailsListIterator {
	return RequestDetailsListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rdl RequestDetailsList) IsEmpty() bool {
	return rdl.Value == nil || len(*rdl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rdl RequestDetailsList) hasNextLink() bool {
	return rdl.NextLink != nil && len(*rdl.NextLink) != 0
}

// requestDetailsListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rdl RequestDetailsList) requestDetailsListPreparer(ctx context.Context) (*http.Request, error) {
	if !rdl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rdl.NextLink)))
}

// RequestDetailsListPage contains a page of RequestDetails values.
type RequestDetailsListPage struct {
	fn  func(context.Context, RequestDetailsList) (RequestDetailsList, error)
	rdl RequestDetailsList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RequestDetailsListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RequestDetailsListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rdl)
		if err != nil {
			return err
		}
		page.rdl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RequestDetailsListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RequestDetailsListPage) NotDone() bool {
	return !page.rdl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RequestDetailsListPage) Response() RequestDetailsList {
	return page.rdl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RequestDetailsListPage) Values() []RequestDetails {
	if page.rdl.IsEmpty() {
		return nil
	}
	return *page.rdl.Value
}

// Creates a new instance of the RequestDetailsListPage type.
func NewRequestDetailsListPage(cur RequestDetailsList, getNextPage func(context.Context, RequestDetailsList) (RequestDetailsList, error)) RequestDetailsListPage {
	return RequestDetailsListPage{
		fn:  getNextPage,
		rdl: cur,
	}
}

// RequestOneResourceProperties the details of quota request.
type RequestOneResourceProperties struct {
	// ProvisioningState - READ-ONLY; The quota request status.
	ProvisioningState interface{} `json:"provisioningState,omitempty"`
	// Message - READ-ONLY; User friendly status message.
	Message *string `json:"message,omitempty"`
	// RequestSubmitTime - READ-ONLY; The quota request submit time. The date conforms to the following format: yyyy-MM-ddTHH:mm:ssZ as specified by the ISO 8601 standard.
	RequestSubmitTime *date.Time `json:"requestSubmitTime,omitempty"`
	// CurrentQuotaLimitBase - The quota request addition properties.
	*CurrentQuotaLimitBase `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RequestOneResourceProperties.
func (rorp RequestOneResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rorp.CurrentQuotaLimitBase != nil {
		objectMap["properties"] = rorp.CurrentQuotaLimitBase
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RequestOneResourceProperties struct.
func (rorp *RequestOneResourceProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "provisioningState":
			if v != nil {
				var provisioningState interface{}
				err = json.Unmarshal(*v, &provisioningState)
				if err != nil {
					return err
				}
				rorp.ProvisioningState = provisioningState
			}
		case "message":
			if v != nil {
				var message string
				err = json.Unmarshal(*v, &message)
				if err != nil {
					return err
				}
				rorp.Message = &message
			}
		case "requestSubmitTime":
			if v != nil {
				var requestSubmitTime date.Time
				err = json.Unmarshal(*v, &requestSubmitTime)
				if err != nil {
					return err
				}
				rorp.RequestSubmitTime = &requestSubmitTime
			}
		case "properties":
			if v != nil {
				var currentQuotaLimitBase CurrentQuotaLimitBase
				err = json.Unmarshal(*v, &currentQuotaLimitBase)
				if err != nil {
					return err
				}
				rorp.CurrentQuotaLimitBase = &currentQuotaLimitBase
			}
		}
	}

	return nil
}

// RequestOneResourceSubmitResponse quota submit request response
type RequestOneResourceSubmitResponse struct {
	// ID - READ-ONLY; The quota request Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the quota request.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/ServiceLimits"
	Type *string `json:"type,omitempty"`
	// RequestOneResourceProperties - The quota request details.
	*RequestOneResourceProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RequestOneResourceSubmitResponse.
func (rorsr RequestOneResourceSubmitResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rorsr.RequestOneResourceProperties != nil {
		objectMap["properties"] = rorsr.RequestOneResourceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RequestOneResourceSubmitResponse struct.
func (rorsr *RequestOneResourceSubmitResponse) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rorsr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rorsr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rorsr.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var requestOneResourceProperties RequestOneResourceProperties
				err = json.Unmarshal(*v, &requestOneResourceProperties)
				if err != nil {
					return err
				}
				rorsr.RequestOneResourceProperties = &requestOneResourceProperties
			}
		}
	}

	return nil
}

// RequestProperties the details of quota request.
type RequestProperties struct {
	// ProvisioningState - The quota request status.
	ProvisioningState interface{} `json:"provisioningState,omitempty"`
	// Message - READ-ONLY; User friendly status message.
	Message *string `json:"message,omitempty"`
	// RequestSubmitTime - READ-ONLY; The quota request submit time. The date conforms to the following format: yyyy-MM-ddTHH:mm:ssZ as specified by the ISO 8601 standard.
	RequestSubmitTime *date.Time `json:"requestSubmitTime,omitempty"`
	// Value - The quotaRequests.
	Value *[]SubRequest `json:"value,omitempty"`
}

// MarshalJSON is the custom marshaler for RequestProperties.
func (rp RequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rp.ProvisioningState != nil {
		objectMap["provisioningState"] = rp.ProvisioningState
	}
	if rp.Value != nil {
		objectMap["value"] = rp.Value
	}
	return json.Marshal(objectMap)
}

// RequestStatusDetails the quota request status details.
type RequestStatusDetails struct {
	// ProvisioningState - READ-ONLY; The quota request status.
	ProvisioningState interface{} `json:"provisioningState,omitempty"`
	// Message - READ-ONLY; A user friendly message.
	Message *string `json:"message,omitempty"`
}

// RequestSubmitResponse quota submit request response
type RequestSubmitResponse struct {
	// ID - READ-ONLY; The quota request Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the quota request.
	Name *string `json:"name,omitempty"`
	// Properties - The quota request details.
	Properties *RequestProperties `json:"properties,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/serviceLimits"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for RequestSubmitResponse.
func (rsr RequestSubmitResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rsr.Properties != nil {
		objectMap["properties"] = rsr.Properties
	}
	return json.Marshal(objectMap)
}

// RequestSubmitResponse201 the quota request submit response with request id.
type RequestSubmitResponse201 struct {
	// ID - READ-ONLY; The quota request id. Please use the requestId to check the request status.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The operation Id
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The resource type
	Type *string `json:"type,omitempty"`
	// RequestStatusDetails - The quota request status.
	*RequestStatusDetails `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RequestSubmitResponse201.
func (rsr2 RequestSubmitResponse201) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rsr2.RequestStatusDetails != nil {
		objectMap["properties"] = rsr2.RequestStatusDetails
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RequestSubmitResponse201 struct.
func (rsr2 *RequestSubmitResponse201) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rsr2.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rsr2.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rsr2.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var requestStatusDetails RequestStatusDetails
				err = json.Unmarshal(*v, &requestStatusDetails)
				if err != nil {
					return err
				}
				rsr2.RequestStatusDetails = &requestStatusDetails
			}
		}
	}

	return nil
}

// ResourceName name of the resource provide by the resource Provider. Please use this name property for
// quotaRequests.
type ResourceName struct {
	// Value - Resource name.
	Value *string `json:"value,omitempty"`
	// LocalizedValue - READ-ONLY; Resource display name.
	LocalizedValue *string `json:"localizedValue,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceName.
func (rn ResourceName) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rn.Value != nil {
		objectMap["value"] = rn.Value
	}
	return json.Marshal(objectMap)
}

// ServiceError the api error details.
type ServiceError struct {
	// Code - The error code.
	Code *string `json:"code,omitempty"`
	// Message - The error message.
	Message *string `json:"message,omitempty"`
	// Details - READ-ONLY; The list of error details.
	Details *[]ServiceErrorDetail `json:"details,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceError.
func (se ServiceError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if se.Code != nil {
		objectMap["code"] = se.Code
	}
	if se.Message != nil {
		objectMap["message"] = se.Message
	}
	return json.Marshal(objectMap)
}

// ServiceErrorDetail the error details.
type ServiceErrorDetail struct {
	// Code - READ-ONLY; The error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; The error message.
	Message *string `json:"message,omitempty"`
}

// SetObject ...
type SetObject struct {
	autorest.Response `json:"-"`
	Value             interface{} `json:"value,omitempty"`
}

// SubRequest the sub-request submitted with the quota request.
type SubRequest struct {
	// Limit - READ-ONLY; The Resource limit.
	Limit *int32 `json:"limit,omitempty"`
	// Name - The Resource name.
	Name *ResourceName `json:"name,omitempty"`
	// ResourceType - READ-ONLY; Resource type for which the quota check was made.
	ResourceType *string `json:"resourceType,omitempty"`
	// Unit -  The units of the limit, such as - Count, Bytes, etc. Use the unit field provided in the Get quota response.
	Unit *string `json:"unit,omitempty"`
	// ProvisioningState - The quota request status.
	ProvisioningState interface{} `json:"provisioningState,omitempty"`
	// Message - READ-ONLY; User friendly status message.
	Message *string `json:"message,omitempty"`
	// SubRequestID - READ-ONLY; Sub request id for individual request.
	SubRequestID *string `json:"subRequestId,omitempty"`
}

// MarshalJSON is the custom marshaler for SubRequest.
func (sr SubRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sr.Name != nil {
		objectMap["name"] = sr.Name
	}
	if sr.Unit != nil {
		objectMap["unit"] = sr.Unit
	}
	if sr.ProvisioningState != nil {
		objectMap["provisioningState"] = sr.ProvisioningState
	}
	return json.Marshal(objectMap)
}

// UpdateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type UpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *UpdateFuture) Result(client Client) (so SetObject, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "quota.UpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("quota.UpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if so.Response.Response, err = future.GetResult(sender); err == nil && so.Response.Response.StatusCode != http.StatusNoContent {
		so, err = client.UpdateResponder(so.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "quota.UpdateFuture", "Result", so.Response.Response, "Failure responding to request")
		}
	}
	return
}
