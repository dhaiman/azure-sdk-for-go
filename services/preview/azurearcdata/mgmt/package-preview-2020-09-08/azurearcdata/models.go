package azurearcdata

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"github.com/satori/go.uuid"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/azurearcdata/mgmt/package-preview-2020-09-08/azurearcdata"

// CloudError an error response from the Azure Data on Azure Arc service.
type CloudError struct {
	// Error - null
	Error *CloudErrorBody `json:"error,omitempty"`
}

// CloudErrorBody an error response from the Batch service.
type CloudErrorBody struct {
	// Code - An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`
	// Message - A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`
	// Target - The target of the particular error. For example, the name of the property in error.
	Target *string `json:"target,omitempty"`
	// Details - A list of additional details about the error.
	Details *[]CloudErrorBody `json:"details,omitempty"`
}

// DataControllerProperties the data controller properties.
type DataControllerProperties struct {
	OnPremiseProperty *OnPremiseProperty `json:"onPremiseProperty,omitempty"`
	// K8sRaw - The raw kubernetes information
	K8sRaw interface{} `json:"k8sRaw,omitempty"`
	// LastUploadedDate - Last uploaded date from on premise cluster. Defaults to current date time
	LastUploadedDate *date.Time `json:"lastUploadedDate,omitempty"`
}

// DataControllerResource data controller resource
type DataControllerResource struct {
	autorest.Response `json:"-"`
	// DataControllerProperties - The data controller's properties
	*DataControllerProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DataControllerResource.
func (dcr DataControllerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcr.DataControllerProperties != nil {
		objectMap["properties"] = dcr.DataControllerProperties
	}
	if dcr.Tags != nil {
		objectMap["tags"] = dcr.Tags
	}
	if dcr.Location != nil {
		objectMap["location"] = dcr.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DataControllerResource struct.
func (dcr *DataControllerResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var dataControllerProperties DataControllerProperties
				err = json.Unmarshal(*v, &dataControllerProperties)
				if err != nil {
					return err
				}
				dcr.DataControllerProperties = &dataControllerProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				dcr.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				dcr.Location = &location
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				dcr.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dcr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dcr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dcr.Type = &typeVar
			}
		}
	}

	return nil
}

// DataControllerUpdate used for updating a data controller resource.
type DataControllerUpdate struct {
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for DataControllerUpdate.
func (dcu DataControllerUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcu.Tags != nil {
		objectMap["tags"] = dcu.Tags
	}
	return json.Marshal(objectMap)
}

// Identity identity for the resource.
type Identity struct {
	// PrincipalID - READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`
	// Type - The identity type. Possible values include: 'SystemAssigned'
	Type ResourceIdentityType `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.Type != "" {
		objectMap["type"] = i.Type
	}
	return json.Marshal(objectMap)
}

// ODataError information about an error.
type ODataError struct {
	// Code - A language-independent error name.
	Code *string `json:"code,omitempty"`
	// Message - The error message.
	Message *string `json:"message,omitempty"`
	// Target - The target of the error (for example, the name of the property in error).
	Target *string `json:"target,omitempty"`
	// Details - The error details.
	Details *[]ODataError `json:"details,omitempty"`
}

// OnPremiseProperty properties from the on premise data controller
type OnPremiseProperty struct {
	// ID - A globally unique ID identifying the associated on premise cluster
	ID *uuid.UUID `json:"id,omitempty"`
	// PublicSigningKey - Certificate that contains the on premise cluster public key used to verify signing
	PublicSigningKey *string `json:"publicSigningKey,omitempty"`
	// SigningCertificateThumbprint - Unique thumbprint returned to customer to verify the certificate being uploaded
	SigningCertificateThumbprint *string `json:"signingCertificateThumbprint,omitempty"`
}

// PageOfDataControllerResource ...
type PageOfDataControllerResource struct {
	autorest.Response `json:"-"`
	Value             *[]DataControllerResource `json:"value,omitempty"`
	// NextLink - Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// PageOfDataControllerResourceIterator provides access to a complete listing of DataControllerResource values.
type PageOfDataControllerResourceIterator struct {
	i    int
	page PageOfDataControllerResourcePage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PageOfDataControllerResourceIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PageOfDataControllerResourceIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PageOfDataControllerResourceIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PageOfDataControllerResourceIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PageOfDataControllerResourceIterator) Response() PageOfDataControllerResource {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PageOfDataControllerResourceIterator) Value() DataControllerResource {
	if !iter.page.NotDone() {
		return DataControllerResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PageOfDataControllerResourceIterator type.
func NewPageOfDataControllerResourceIterator(page PageOfDataControllerResourcePage) PageOfDataControllerResourceIterator {
	return PageOfDataControllerResourceIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (podcr PageOfDataControllerResource) IsEmpty() bool {
	return podcr.Value == nil || len(*podcr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (podcr PageOfDataControllerResource) hasNextLink() bool {
	return podcr.NextLink != nil && len(*podcr.NextLink) != 0
}

// pageOfDataControllerResourcePreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (podcr PageOfDataControllerResource) pageOfDataControllerResourcePreparer(ctx context.Context) (*http.Request, error) {
	if !podcr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(podcr.NextLink)))
}

// PageOfDataControllerResourcePage contains a page of DataControllerResource values.
type PageOfDataControllerResourcePage struct {
	fn    func(context.Context, PageOfDataControllerResource) (PageOfDataControllerResource, error)
	podcr PageOfDataControllerResource
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PageOfDataControllerResourcePage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PageOfDataControllerResourcePage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.podcr)
		if err != nil {
			return err
		}
		page.podcr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PageOfDataControllerResourcePage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PageOfDataControllerResourcePage) NotDone() bool {
	return !page.podcr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PageOfDataControllerResourcePage) Response() PageOfDataControllerResource {
	return page.podcr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PageOfDataControllerResourcePage) Values() []DataControllerResource {
	if page.podcr.IsEmpty() {
		return nil
	}
	return *page.podcr.Value
}

// Creates a new instance of the PageOfDataControllerResourcePage type.
func NewPageOfDataControllerResourcePage(getNextPage func(context.Context, PageOfDataControllerResource) (PageOfDataControllerResource, error)) PageOfDataControllerResourcePage {
	return PageOfDataControllerResourcePage{fn: getNextPage}
}

// Plan plan for the resource.
type Plan struct {
	// Name - A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`
	// Publisher - The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`
	// Product - The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`
	// PromotionCode - A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`
	// Version - The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

// PostgresInstance a Postgres Instance.
type PostgresInstance struct {
	autorest.Response `json:"-"`
	// PostgresInstanceProperties - null
	*PostgresInstanceProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PostgresInstance.
func (pi PostgresInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pi.PostgresInstanceProperties != nil {
		objectMap["properties"] = pi.PostgresInstanceProperties
	}
	if pi.Tags != nil {
		objectMap["tags"] = pi.Tags
	}
	if pi.Location != nil {
		objectMap["location"] = pi.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PostgresInstance struct.
func (pi *PostgresInstance) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var postgresInstanceProperties PostgresInstanceProperties
				err = json.Unmarshal(*v, &postgresInstanceProperties)
				if err != nil {
					return err
				}
				pi.PostgresInstanceProperties = &postgresInstanceProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				pi.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				pi.Location = &location
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				pi.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pi.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pi.Type = &typeVar
			}
		}
	}

	return nil
}

// PostgresInstanceListResult a list of PostgresInstance.
type PostgresInstanceListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; Array of results.
	Value *[]PostgresInstance `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// PostgresInstanceListResultIterator provides access to a complete listing of PostgresInstance values.
type PostgresInstanceListResultIterator struct {
	i    int
	page PostgresInstanceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PostgresInstanceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PostgresInstanceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PostgresInstanceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PostgresInstanceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PostgresInstanceListResultIterator) Response() PostgresInstanceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PostgresInstanceListResultIterator) Value() PostgresInstance {
	if !iter.page.NotDone() {
		return PostgresInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PostgresInstanceListResultIterator type.
func NewPostgresInstanceListResultIterator(page PostgresInstanceListResultPage) PostgresInstanceListResultIterator {
	return PostgresInstanceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pilr PostgresInstanceListResult) IsEmpty() bool {
	return pilr.Value == nil || len(*pilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pilr PostgresInstanceListResult) hasNextLink() bool {
	return pilr.NextLink != nil && len(*pilr.NextLink) != 0
}

// postgresInstanceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pilr PostgresInstanceListResult) postgresInstanceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !pilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pilr.NextLink)))
}

// PostgresInstanceListResultPage contains a page of PostgresInstance values.
type PostgresInstanceListResultPage struct {
	fn   func(context.Context, PostgresInstanceListResult) (PostgresInstanceListResult, error)
	pilr PostgresInstanceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PostgresInstanceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PostgresInstanceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pilr)
		if err != nil {
			return err
		}
		page.pilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PostgresInstanceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PostgresInstanceListResultPage) NotDone() bool {
	return !page.pilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PostgresInstanceListResultPage) Response() PostgresInstanceListResult {
	return page.pilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PostgresInstanceListResultPage) Values() []PostgresInstance {
	if page.pilr.IsEmpty() {
		return nil
	}
	return *page.pilr.Value
}

// Creates a new instance of the PostgresInstanceListResultPage type.
func NewPostgresInstanceListResultPage(getNextPage func(context.Context, PostgresInstanceListResult) (PostgresInstanceListResult, error)) PostgresInstanceListResultPage {
	return PostgresInstanceListResultPage{fn: getNextPage}
}

// PostgresInstanceProperties postgres Instance properties.
type PostgresInstanceProperties struct {
	// DataControllerID - The data controller id
	DataControllerID *string `json:"dataControllerId,omitempty"`
	// Admin - The instance admin
	Admin *string `json:"admin,omitempty"`
	// K8sRaw - The raw kubernetes information
	K8sRaw interface{} `json:"k8sRaw,omitempty"`
	// LastUploadedDate - Last uploaded date from on premise cluster. Defaults to current date time
	LastUploadedDate *date.Time `json:"lastUploadedDate,omitempty"`
}

// PostgresInstanceUpdate an update to a Postgres Instance.
type PostgresInstanceUpdate struct {
	// Tags - Resource tags.
	Tags       map[string]*string          `json:"tags"`
	Properties *PostgresInstanceProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for PostgresInstanceUpdate.
func (piu PostgresInstanceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if piu.Tags != nil {
		objectMap["tags"] = piu.Tags
	}
	if piu.Properties != nil {
		objectMap["properties"] = piu.Properties
	}
	return json.Marshal(objectMap)
}

// ProxyResource the resource model definition for a ARM proxy resource. It will have everything other than
// required location and tags
type ProxyResource struct {
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// Resource ...
type Resource struct {
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// ResourceSku ...
type ResourceSku struct {
	Capacity *int32  `json:"capacity,omitempty"`
	Family   *string `json:"family,omitempty"`
	Name     *string `json:"name,omitempty"`
	Size     *string `json:"size,omitempty"`
	Tier     *string `json:"tier,omitempty"`
}

// Sku the resource model definition representing SKU
type Sku struct {
	// Name - The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`
	// Tier - This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT. Possible values include: 'Free', 'Basic', 'Standard', 'Premium'
	Tier SkuTier `json:"tier,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
}

// SQLManagedInstance a SqlManagedInstance.
type SQLManagedInstance struct {
	autorest.Response `json:"-"`
	// SQLManagedInstanceProperties - null
	*SQLManagedInstanceProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLManagedInstance.
func (smi SQLManagedInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smi.SQLManagedInstanceProperties != nil {
		objectMap["properties"] = smi.SQLManagedInstanceProperties
	}
	if smi.Tags != nil {
		objectMap["tags"] = smi.Tags
	}
	if smi.Location != nil {
		objectMap["location"] = smi.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SQLManagedInstance struct.
func (smi *SQLManagedInstance) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var SQLManagedInstanceProperties SQLManagedInstanceProperties
				err = json.Unmarshal(*v, &SQLManagedInstanceProperties)
				if err != nil {
					return err
				}
				smi.SQLManagedInstanceProperties = &SQLManagedInstanceProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				smi.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				smi.Location = &location
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				smi.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				smi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				smi.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				smi.Type = &typeVar
			}
		}
	}

	return nil
}

// SQLManagedInstanceListResult a list of SqlManagedInstance.
type SQLManagedInstanceListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; Array of results.
	Value *[]SQLManagedInstance `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// SQLManagedInstanceListResultIterator provides access to a complete listing of SQLManagedInstance values.
type SQLManagedInstanceListResultIterator struct {
	i    int
	page SQLManagedInstanceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SQLManagedInstanceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SQLManagedInstanceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SQLManagedInstanceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SQLManagedInstanceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SQLManagedInstanceListResultIterator) Response() SQLManagedInstanceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SQLManagedInstanceListResultIterator) Value() SQLManagedInstance {
	if !iter.page.NotDone() {
		return SQLManagedInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SQLManagedInstanceListResultIterator type.
func NewSQLManagedInstanceListResultIterator(page SQLManagedInstanceListResultPage) SQLManagedInstanceListResultIterator {
	return SQLManagedInstanceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (smilr SQLManagedInstanceListResult) IsEmpty() bool {
	return smilr.Value == nil || len(*smilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (smilr SQLManagedInstanceListResult) hasNextLink() bool {
	return smilr.NextLink != nil && len(*smilr.NextLink) != 0
}

// sQLManagedInstanceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (smilr SQLManagedInstanceListResult) sQLManagedInstanceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !smilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(smilr.NextLink)))
}

// SQLManagedInstanceListResultPage contains a page of SQLManagedInstance values.
type SQLManagedInstanceListResultPage struct {
	fn    func(context.Context, SQLManagedInstanceListResult) (SQLManagedInstanceListResult, error)
	smilr SQLManagedInstanceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SQLManagedInstanceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SQLManagedInstanceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.smilr)
		if err != nil {
			return err
		}
		page.smilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SQLManagedInstanceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SQLManagedInstanceListResultPage) NotDone() bool {
	return !page.smilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SQLManagedInstanceListResultPage) Response() SQLManagedInstanceListResult {
	return page.smilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SQLManagedInstanceListResultPage) Values() []SQLManagedInstance {
	if page.smilr.IsEmpty() {
		return nil
	}
	return *page.smilr.Value
}

// Creates a new instance of the SQLManagedInstanceListResultPage type.
func NewSQLManagedInstanceListResultPage(getNextPage func(context.Context, SQLManagedInstanceListResult) (SQLManagedInstanceListResult, error)) SQLManagedInstanceListResultPage {
	return SQLManagedInstanceListResultPage{fn: getNextPage}
}

// SQLManagedInstanceProperties properties of sqlManagedInstance.
type SQLManagedInstanceProperties struct {
	// DataControllerID - null
	DataControllerID *string `json:"dataControllerId,omitempty"`
	// InstanceEndpoint - The on premise instance endpoint
	InstanceEndpoint *string `json:"instanceEndpoint,omitempty"`
	// Admin - The instance admin user
	Admin *string `json:"admin,omitempty"`
	// StartTime - The instance start time
	StartTime *string `json:"startTime,omitempty"`
	// EndTime - The instance end time
	EndTime *string `json:"endTime,omitempty"`
	// VCore - The instance vCore
	VCore *string `json:"vCore,omitempty"`
	// K8sRaw - The raw kubernetes information
	K8sRaw interface{} `json:"k8sRaw,omitempty"`
	// LastUploadedDate - Last uploaded date from on premise cluster. Defaults to current date time
	LastUploadedDate *date.Time `json:"lastUploadedDate,omitempty"`
}

// SQLManagedInstanceUpdate an update to a SQL Managed Instance.
type SQLManagedInstanceUpdate struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for SQLManagedInstanceUpdate.
func (smiu SQLManagedInstanceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smiu.Tags != nil {
		objectMap["tags"] = smiu.Tags
	}
	return json.Marshal(objectMap)
}

// SQLServerInstance a SqlServerInstance.
type SQLServerInstance struct {
	autorest.Response `json:"-"`
	// SQLServerInstanceProperties - null
	*SQLServerInstanceProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLServerInstance.
func (ssi SQLServerInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssi.SQLServerInstanceProperties != nil {
		objectMap["properties"] = ssi.SQLServerInstanceProperties
	}
	if ssi.Tags != nil {
		objectMap["tags"] = ssi.Tags
	}
	if ssi.Location != nil {
		objectMap["location"] = ssi.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SQLServerInstance struct.
func (ssi *SQLServerInstance) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var SQLServerInstanceProperties SQLServerInstanceProperties
				err = json.Unmarshal(*v, &SQLServerInstanceProperties)
				if err != nil {
					return err
				}
				ssi.SQLServerInstanceProperties = &SQLServerInstanceProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				ssi.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ssi.Location = &location
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				ssi.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssi.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssi.Type = &typeVar
			}
		}
	}

	return nil
}

// SQLServerInstanceListResult a list of SqlServerInstance.
type SQLServerInstanceListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; Array of results.
	Value *[]SQLServerInstance `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// SQLServerInstanceListResultIterator provides access to a complete listing of SQLServerInstance values.
type SQLServerInstanceListResultIterator struct {
	i    int
	page SQLServerInstanceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SQLServerInstanceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SQLServerInstanceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SQLServerInstanceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SQLServerInstanceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SQLServerInstanceListResultIterator) Response() SQLServerInstanceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SQLServerInstanceListResultIterator) Value() SQLServerInstance {
	if !iter.page.NotDone() {
		return SQLServerInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SQLServerInstanceListResultIterator type.
func NewSQLServerInstanceListResultIterator(page SQLServerInstanceListResultPage) SQLServerInstanceListResultIterator {
	return SQLServerInstanceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ssilr SQLServerInstanceListResult) IsEmpty() bool {
	return ssilr.Value == nil || len(*ssilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ssilr SQLServerInstanceListResult) hasNextLink() bool {
	return ssilr.NextLink != nil && len(*ssilr.NextLink) != 0
}

// sQLServerInstanceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ssilr SQLServerInstanceListResult) sQLServerInstanceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ssilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ssilr.NextLink)))
}

// SQLServerInstanceListResultPage contains a page of SQLServerInstance values.
type SQLServerInstanceListResultPage struct {
	fn    func(context.Context, SQLServerInstanceListResult) (SQLServerInstanceListResult, error)
	ssilr SQLServerInstanceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SQLServerInstanceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SQLServerInstanceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ssilr)
		if err != nil {
			return err
		}
		page.ssilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SQLServerInstanceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SQLServerInstanceListResultPage) NotDone() bool {
	return !page.ssilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SQLServerInstanceListResultPage) Response() SQLServerInstanceListResult {
	return page.ssilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SQLServerInstanceListResultPage) Values() []SQLServerInstance {
	if page.ssilr.IsEmpty() {
		return nil
	}
	return *page.ssilr.Value
}

// Creates a new instance of the SQLServerInstanceListResultPage type.
func NewSQLServerInstanceListResultPage(getNextPage func(context.Context, SQLServerInstanceListResult) (SQLServerInstanceListResult, error)) SQLServerInstanceListResultPage {
	return SQLServerInstanceListResultPage{fn: getNextPage}
}

// SQLServerInstanceProperties properties of SqlServerInstance.
type SQLServerInstanceProperties struct {
	// Version - SQL Server version.
	Version *string `json:"version,omitempty"`
	// Edition - SQL Server edition.
	Edition *string `json:"edition,omitempty"`
	// ContainerResourceID - ARM Resource id of the container resource (Azure Arc for Servers)
	ContainerResourceID *string `json:"containerResourceId,omitempty"`
	// CreateTime - READ-ONLY; The time when the resource was created.
	CreateTime *string `json:"createTime,omitempty"`
	// UpdateTime - READ-ONLY; The time when the resource was last updated.
	UpdateTime *string `json:"updateTime,omitempty"`
	// VCore - The number of logical processors used by the SQL Server instance.
	VCore *string `json:"vCore,omitempty"`
	// Status - The cloud connectivity status.
	Status *string `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLServerInstanceProperties.
func (ssip SQLServerInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssip.Version != nil {
		objectMap["version"] = ssip.Version
	}
	if ssip.Edition != nil {
		objectMap["edition"] = ssip.Edition
	}
	if ssip.ContainerResourceID != nil {
		objectMap["containerResourceId"] = ssip.ContainerResourceID
	}
	if ssip.VCore != nil {
		objectMap["vCore"] = ssip.VCore
	}
	if ssip.Status != nil {
		objectMap["status"] = ssip.Status
	}
	return json.Marshal(objectMap)
}

// SQLServerInstanceUpdate an update to a SQL Server Instance.
type SQLServerInstanceUpdate struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for SQLServerInstanceUpdate.
func (ssiu SQLServerInstanceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssiu.Tags != nil {
		objectMap["tags"] = ssiu.Tags
	}
	return json.Marshal(objectMap)
}

// SystemData read only system data
type SystemData struct {
	// CreatedBy - An identifier for the identity that created the resource
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - The type of identity that created the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	CreatedByType IdentityType `json:"createdByType,omitempty"`
	// CreatedAt - The timestamp of resource creation (UTC)
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// LastModifiedBy - An identifier for the identity that last modified the resource
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - The type of identity that last modified the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	LastModifiedByType IdentityType `json:"lastModifiedByType,omitempty"`
	// LastModifiedAt - The timestamp of resource last modification (UTC)
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
}

// TrackedResource the resource model definition for a ARM tracked top level resource
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}
