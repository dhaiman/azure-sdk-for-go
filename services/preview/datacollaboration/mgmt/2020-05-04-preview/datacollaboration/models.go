package datacollaboration

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/datacollaboration/mgmt/2020-05-04-preview/datacollaboration"

// ADLSGen2FileDataSet an ADLS Gen 2 file data set.
type ADLSGen2FileDataSet struct {
	// ADLSGen2FileProperties - AdlsGen2File data source properties.
	*ADLSGen2FileProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
	// Kind - Possible values include: 'KindDataSet', 'KindAdlsGen2File', 'KindAdlsGen2FileSystem', 'KindAdlsGen2Folder', 'KindContainer', 'KindBlob', 'KindBlobFolder'
	Kind KindBasicDataSet `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) MarshalJSON() ([]byte, error) {
	ag2fds.Kind = KindAdlsGen2File
	objectMap := make(map[string]interface{})
	if ag2fds.ADLSGen2FileProperties != nil {
		objectMap["properties"] = ag2fds.ADLSGen2FileProperties
	}
	if ag2fds.Kind != "" {
		objectMap["kind"] = ag2fds.Kind
	}
	return json.Marshal(objectMap)
}

// AsADLSGen2FileDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool) {
	return &ag2fds, true
}

// AsADLSGen2FileSystemDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool) {
	return nil, false
}

// AsADLSGen2FolderDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool) {
	return nil, false
}

// AsBlobContainerDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsBlobContainerDataSet() (*BlobContainerDataSet, bool) {
	return nil, false
}

// AsBlobDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsBlobDataSet() (*BlobDataSet, bool) {
	return nil, false
}

// AsBlobFolderDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsBlobFolderDataSet() (*BlobFolderDataSet, bool) {
	return nil, false
}

// AsDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsDataSet() (*DataSet, bool) {
	return nil, false
}

// AsBasicDataSet is the BasicDataSet implementation for ADLSGen2FileDataSet.
func (ag2fds ADLSGen2FileDataSet) AsBasicDataSet() (BasicDataSet, bool) {
	return &ag2fds, true
}

// UnmarshalJSON is the custom unmarshaler for ADLSGen2FileDataSet struct.
func (ag2fds *ADLSGen2FileDataSet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var aDLSGen2FileProperties ADLSGen2FileProperties
				err = json.Unmarshal(*v, &aDLSGen2FileProperties)
				if err != nil {
					return err
				}
				ag2fds.ADLSGen2FileProperties = &aDLSGen2FileProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicDataSet
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ag2fds.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ag2fds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ag2fds.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ag2fds.Type = &typeVar
			}
		}
	}

	return nil
}

// ADLSGen2FileProperties properties of the ADLS Gen2 file data set.
type ADLSGen2FileProperties struct {
	// DataSetID - READ-ONLY; Unique id for identifying a data set resource
	DataSetID *string `json:"dataSetId,omitempty"`
	// FilePath - File path within the file system.
	FilePath *string `json:"filePath,omitempty"`
	// FileSystem - File system to which the file belongs.
	FileSystem *string `json:"fileSystem,omitempty"`
	// StorageAccountID - Resource id of the storage account.
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// MarshalJSON is the custom marshaler for ADLSGen2FileProperties.
func (ag2fp ADLSGen2FileProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ag2fp.FilePath != nil {
		objectMap["filePath"] = ag2fp.FilePath
	}
	if ag2fp.FileSystem != nil {
		objectMap["fileSystem"] = ag2fp.FileSystem
	}
	if ag2fp.StorageAccountID != nil {
		objectMap["storageAccountId"] = ag2fp.StorageAccountID
	}
	return json.Marshal(objectMap)
}

// ADLSGen2FileSystemDataSet an ADLS Gen 2 file system data set.
type ADLSGen2FileSystemDataSet struct {
	// ADLSGen2FileSystemProperties - AdlsGen2FileSystem data source properties.
	*ADLSGen2FileSystemProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindDataSet', 'KindAdlsGen2File', 'KindAdlsGen2FileSystem', 'KindAdlsGen2Folder', 'KindContainer', 'KindBlob', 'KindBlobFolder'
	Kind KindBasicDataSet `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) MarshalJSON() ([]byte, error) {
	ag2fsds.Kind = KindAdlsGen2FileSystem
	objectMap := make(map[string]interface{})
	if ag2fsds.ADLSGen2FileSystemProperties != nil {
		objectMap["properties"] = ag2fsds.ADLSGen2FileSystemProperties
	}
	if ag2fsds.Kind != "" {
		objectMap["kind"] = ag2fsds.Kind
	}
	return json.Marshal(objectMap)
}

// AsADLSGen2FileDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool) {
	return nil, false
}

// AsADLSGen2FileSystemDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool) {
	return &ag2fsds, true
}

// AsADLSGen2FolderDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool) {
	return nil, false
}

// AsBlobContainerDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsBlobContainerDataSet() (*BlobContainerDataSet, bool) {
	return nil, false
}

// AsBlobDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsBlobDataSet() (*BlobDataSet, bool) {
	return nil, false
}

// AsBlobFolderDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsBlobFolderDataSet() (*BlobFolderDataSet, bool) {
	return nil, false
}

// AsDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsDataSet() (*DataSet, bool) {
	return nil, false
}

// AsBasicDataSet is the BasicDataSet implementation for ADLSGen2FileSystemDataSet.
func (ag2fsds ADLSGen2FileSystemDataSet) AsBasicDataSet() (BasicDataSet, bool) {
	return &ag2fsds, true
}

// UnmarshalJSON is the custom unmarshaler for ADLSGen2FileSystemDataSet struct.
func (ag2fsds *ADLSGen2FileSystemDataSet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var aDLSGen2FileSystemProperties ADLSGen2FileSystemProperties
				err = json.Unmarshal(*v, &aDLSGen2FileSystemProperties)
				if err != nil {
					return err
				}
				ag2fsds.ADLSGen2FileSystemProperties = &aDLSGen2FileSystemProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicDataSet
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ag2fsds.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ag2fsds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ag2fsds.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ag2fsds.Type = &typeVar
			}
		}
	}

	return nil
}

// ADLSGen2FileSystemProperties properties of the ADLS Gen2 file system data set.
type ADLSGen2FileSystemProperties struct {
	// DataSetID - READ-ONLY; Unique id for identifying a data set resource
	DataSetID *string `json:"dataSetId,omitempty"`
	// FileSystem - The file system name.
	FileSystem *string `json:"fileSystem,omitempty"`
	// StorageAccountID - Resource id of the storage account.
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// MarshalJSON is the custom marshaler for ADLSGen2FileSystemProperties.
func (ag2fsp ADLSGen2FileSystemProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ag2fsp.FileSystem != nil {
		objectMap["fileSystem"] = ag2fsp.FileSystem
	}
	if ag2fsp.StorageAccountID != nil {
		objectMap["storageAccountId"] = ag2fsp.StorageAccountID
	}
	return json.Marshal(objectMap)
}

// ADLSGen2FolderDataSet an ADLS Gen 2 folder data set.
type ADLSGen2FolderDataSet struct {
	// ADLSGen2FolderProperties - AdlsGen2FileSystem data source properties.
	*ADLSGen2FolderProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindDataSet', 'KindAdlsGen2File', 'KindAdlsGen2FileSystem', 'KindAdlsGen2Folder', 'KindContainer', 'KindBlob', 'KindBlobFolder'
	Kind KindBasicDataSet `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) MarshalJSON() ([]byte, error) {
	ag2fds.Kind = KindAdlsGen2Folder
	objectMap := make(map[string]interface{})
	if ag2fds.ADLSGen2FolderProperties != nil {
		objectMap["properties"] = ag2fds.ADLSGen2FolderProperties
	}
	if ag2fds.Kind != "" {
		objectMap["kind"] = ag2fds.Kind
	}
	return json.Marshal(objectMap)
}

// AsADLSGen2FileDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool) {
	return nil, false
}

// AsADLSGen2FileSystemDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool) {
	return nil, false
}

// AsADLSGen2FolderDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool) {
	return &ag2fds, true
}

// AsBlobContainerDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsBlobContainerDataSet() (*BlobContainerDataSet, bool) {
	return nil, false
}

// AsBlobDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsBlobDataSet() (*BlobDataSet, bool) {
	return nil, false
}

// AsBlobFolderDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsBlobFolderDataSet() (*BlobFolderDataSet, bool) {
	return nil, false
}

// AsDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsDataSet() (*DataSet, bool) {
	return nil, false
}

// AsBasicDataSet is the BasicDataSet implementation for ADLSGen2FolderDataSet.
func (ag2fds ADLSGen2FolderDataSet) AsBasicDataSet() (BasicDataSet, bool) {
	return &ag2fds, true
}

// UnmarshalJSON is the custom unmarshaler for ADLSGen2FolderDataSet struct.
func (ag2fds *ADLSGen2FolderDataSet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var aDLSGen2FolderProperties ADLSGen2FolderProperties
				err = json.Unmarshal(*v, &aDLSGen2FolderProperties)
				if err != nil {
					return err
				}
				ag2fds.ADLSGen2FolderProperties = &aDLSGen2FolderProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicDataSet
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ag2fds.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ag2fds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ag2fds.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ag2fds.Type = &typeVar
			}
		}
	}

	return nil
}

// ADLSGen2FolderProperties properties of the ADLS Gen2 folder data set.
type ADLSGen2FolderProperties struct {
	// DataSetID - READ-ONLY; Unique id for identifying a data set resource
	DataSetID *string `json:"dataSetId,omitempty"`
	// FileSystem - File system to which the folder belongs.
	FileSystem *string `json:"fileSystem,omitempty"`
	// FolderPath - Folder path within the file system.
	FolderPath *string `json:"folderPath,omitempty"`
	// StorageAccountID - Resource id of the storage account.
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// MarshalJSON is the custom marshaler for ADLSGen2FolderProperties.
func (ag2fp ADLSGen2FolderProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ag2fp.FileSystem != nil {
		objectMap["fileSystem"] = ag2fp.FileSystem
	}
	if ag2fp.FolderPath != nil {
		objectMap["folderPath"] = ag2fp.FolderPath
	}
	if ag2fp.StorageAccountID != nil {
		objectMap["storageAccountId"] = ag2fp.StorageAccountID
	}
	return json.Marshal(objectMap)
}

// BlobContainerDataSet an Azure storage blob container data set.
type BlobContainerDataSet struct {
	// BlobContainerProperties - Blob container data source properties.
	*BlobContainerProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindDataSet', 'KindAdlsGen2File', 'KindAdlsGen2FileSystem', 'KindAdlsGen2Folder', 'KindContainer', 'KindBlob', 'KindBlobFolder'
	Kind KindBasicDataSet `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobContainerDataSet.
func (bcds BlobContainerDataSet) MarshalJSON() ([]byte, error) {
	bcds.Kind = KindContainer
	objectMap := make(map[string]interface{})
	if bcds.BlobContainerProperties != nil {
		objectMap["properties"] = bcds.BlobContainerProperties
	}
	if bcds.Kind != "" {
		objectMap["kind"] = bcds.Kind
	}
	return json.Marshal(objectMap)
}

// AsADLSGen2FileDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool) {
	return nil, false
}

// AsADLSGen2FileSystemDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool) {
	return nil, false
}

// AsADLSGen2FolderDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool) {
	return nil, false
}

// AsBlobContainerDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsBlobContainerDataSet() (*BlobContainerDataSet, bool) {
	return &bcds, true
}

// AsBlobDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsBlobDataSet() (*BlobDataSet, bool) {
	return nil, false
}

// AsBlobFolderDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsBlobFolderDataSet() (*BlobFolderDataSet, bool) {
	return nil, false
}

// AsDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsDataSet() (*DataSet, bool) {
	return nil, false
}

// AsBasicDataSet is the BasicDataSet implementation for BlobContainerDataSet.
func (bcds BlobContainerDataSet) AsBasicDataSet() (BasicDataSet, bool) {
	return &bcds, true
}

// UnmarshalJSON is the custom unmarshaler for BlobContainerDataSet struct.
func (bcds *BlobContainerDataSet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var blobContainerProperties BlobContainerProperties
				err = json.Unmarshal(*v, &blobContainerProperties)
				if err != nil {
					return err
				}
				bcds.BlobContainerProperties = &blobContainerProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicDataSet
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				bcds.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bcds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bcds.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bcds.Type = &typeVar
			}
		}
	}

	return nil
}

// BlobContainerProperties properties of the BLOB container data set.
type BlobContainerProperties struct {
	// ContainerName - BLOB Container name.
	ContainerName *string `json:"containerName,omitempty"`
	// DataSetID - READ-ONLY; Unique id for identifying a data set resource
	DataSetID *string `json:"dataSetId,omitempty"`
	// StorageAccountID - Resource id of the storage account.
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobContainerProperties.
func (bcp BlobContainerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bcp.ContainerName != nil {
		objectMap["containerName"] = bcp.ContainerName
	}
	if bcp.StorageAccountID != nil {
		objectMap["storageAccountId"] = bcp.StorageAccountID
	}
	return json.Marshal(objectMap)
}

// BlobDataSet an Azure storage blob data set.
type BlobDataSet struct {
	// BlobProperties - Blob data source properties.
	*BlobProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindDataSet', 'KindAdlsGen2File', 'KindAdlsGen2FileSystem', 'KindAdlsGen2Folder', 'KindContainer', 'KindBlob', 'KindBlobFolder'
	Kind KindBasicDataSet `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobDataSet.
func (bds BlobDataSet) MarshalJSON() ([]byte, error) {
	bds.Kind = KindBlob
	objectMap := make(map[string]interface{})
	if bds.BlobProperties != nil {
		objectMap["properties"] = bds.BlobProperties
	}
	if bds.Kind != "" {
		objectMap["kind"] = bds.Kind
	}
	return json.Marshal(objectMap)
}

// AsADLSGen2FileDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool) {
	return nil, false
}

// AsADLSGen2FileSystemDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool) {
	return nil, false
}

// AsADLSGen2FolderDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool) {
	return nil, false
}

// AsBlobContainerDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsBlobContainerDataSet() (*BlobContainerDataSet, bool) {
	return nil, false
}

// AsBlobDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsBlobDataSet() (*BlobDataSet, bool) {
	return &bds, true
}

// AsBlobFolderDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsBlobFolderDataSet() (*BlobFolderDataSet, bool) {
	return nil, false
}

// AsDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsDataSet() (*DataSet, bool) {
	return nil, false
}

// AsBasicDataSet is the BasicDataSet implementation for BlobDataSet.
func (bds BlobDataSet) AsBasicDataSet() (BasicDataSet, bool) {
	return &bds, true
}

// UnmarshalJSON is the custom unmarshaler for BlobDataSet struct.
func (bds *BlobDataSet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var blobProperties BlobProperties
				err = json.Unmarshal(*v, &blobProperties)
				if err != nil {
					return err
				}
				bds.BlobProperties = &blobProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicDataSet
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				bds.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bds.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bds.Type = &typeVar
			}
		}
	}

	return nil
}

// BlobFolderDataSet an Azure storage blob folder data set.
type BlobFolderDataSet struct {
	// BlobFolderProperties - Blob folder data source properties.
	*BlobFolderProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindDataSet', 'KindAdlsGen2File', 'KindAdlsGen2FileSystem', 'KindAdlsGen2Folder', 'KindContainer', 'KindBlob', 'KindBlobFolder'
	Kind KindBasicDataSet `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobFolderDataSet.
func (bfds BlobFolderDataSet) MarshalJSON() ([]byte, error) {
	bfds.Kind = KindBlobFolder
	objectMap := make(map[string]interface{})
	if bfds.BlobFolderProperties != nil {
		objectMap["properties"] = bfds.BlobFolderProperties
	}
	if bfds.Kind != "" {
		objectMap["kind"] = bfds.Kind
	}
	return json.Marshal(objectMap)
}

// AsADLSGen2FileDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool) {
	return nil, false
}

// AsADLSGen2FileSystemDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool) {
	return nil, false
}

// AsADLSGen2FolderDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool) {
	return nil, false
}

// AsBlobContainerDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsBlobContainerDataSet() (*BlobContainerDataSet, bool) {
	return nil, false
}

// AsBlobDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsBlobDataSet() (*BlobDataSet, bool) {
	return nil, false
}

// AsBlobFolderDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsBlobFolderDataSet() (*BlobFolderDataSet, bool) {
	return &bfds, true
}

// AsDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsDataSet() (*DataSet, bool) {
	return nil, false
}

// AsBasicDataSet is the BasicDataSet implementation for BlobFolderDataSet.
func (bfds BlobFolderDataSet) AsBasicDataSet() (BasicDataSet, bool) {
	return &bfds, true
}

// UnmarshalJSON is the custom unmarshaler for BlobFolderDataSet struct.
func (bfds *BlobFolderDataSet) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var blobFolderProperties BlobFolderProperties
				err = json.Unmarshal(*v, &blobFolderProperties)
				if err != nil {
					return err
				}
				bfds.BlobFolderProperties = &blobFolderProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicDataSet
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				bfds.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				bfds.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				bfds.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				bfds.Type = &typeVar
			}
		}
	}

	return nil
}

// BlobFolderProperties properties of the blob folder data set.
type BlobFolderProperties struct {
	// ContainerName - Container that has the file path.
	ContainerName *string `json:"containerName,omitempty"`
	// DataSetID - READ-ONLY; Unique id for identifying a data set resource
	DataSetID *string `json:"dataSetId,omitempty"`
	// Prefix - Prefix for blob folder
	Prefix *string `json:"prefix,omitempty"`
	// StorageAccountID - Resource id of the storage account.
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobFolderProperties.
func (bfp BlobFolderProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bfp.ContainerName != nil {
		objectMap["containerName"] = bfp.ContainerName
	}
	if bfp.Prefix != nil {
		objectMap["prefix"] = bfp.Prefix
	}
	if bfp.StorageAccountID != nil {
		objectMap["storageAccountId"] = bfp.StorageAccountID
	}
	return json.Marshal(objectMap)
}

// BlobProperties properties of the internal blob data set.
type BlobProperties struct {
	// ContainerName - Container that has the file path.
	ContainerName *string `json:"containerName,omitempty"`
	// DataSetID - READ-ONLY; Unique id for identifying a data set resource
	DataSetID *string `json:"dataSetId,omitempty"`
	// FilePath - File path within the source data source
	FilePath *string `json:"filePath,omitempty"`
	// StorageAccountID - Resource id of the storage account.
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// MarshalJSON is the custom marshaler for BlobProperties.
func (bp BlobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bp.ContainerName != nil {
		objectMap["containerName"] = bp.ContainerName
	}
	if bp.FilePath != nil {
		objectMap["filePath"] = bp.FilePath
	}
	if bp.StorageAccountID != nil {
		objectMap["storageAccountId"] = bp.StorageAccountID
	}
	return json.Marshal(objectMap)
}

// BasicConstraint constraint for entitlement, restricts the access granted by it.
type BasicConstraint interface {
	AsLocationConstraint() (*LocationConstraint, bool)
	AsScriptConstraint() (*ScriptConstraint, bool)
	AsConstraint() (*Constraint, bool)
}

// Constraint constraint for entitlement, restricts the access granted by it.
type Constraint struct {
	autorest.Response `json:"-"`
	// SystemData - SystemData Info of script
	SystemData *SystemData `json:"systemData,omitempty"`
	// Kind - Possible values include: 'KindConstraint', 'KindLocation', 'KindScript'
	Kind Kind `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

func unmarshalBasicConstraint(body []byte) (BasicConstraint, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindLocation):
		var lc LocationConstraint
		err := json.Unmarshal(body, &lc)
		return lc, err
	case string(KindScript):
		var sc ScriptConstraint
		err := json.Unmarshal(body, &sc)
		return sc, err
	default:
		var c Constraint
		err := json.Unmarshal(body, &c)
		return c, err
	}
}
func unmarshalBasicConstraintArray(body []byte) ([]BasicConstraint, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	cArray := make([]BasicConstraint, len(rawMessages))

	for index, rawMessage := range rawMessages {
		c, err := unmarshalBasicConstraint(*rawMessage)
		if err != nil {
			return nil, err
		}
		cArray[index] = c
	}
	return cArray, nil
}

// MarshalJSON is the custom marshaler for Constraint.
func (c Constraint) MarshalJSON() ([]byte, error) {
	c.Kind = KindConstraint
	objectMap := make(map[string]interface{})
	if c.SystemData != nil {
		objectMap["systemData"] = c.SystemData
	}
	if c.Kind != "" {
		objectMap["kind"] = c.Kind
	}
	return json.Marshal(objectMap)
}

// AsLocationConstraint is the BasicConstraint implementation for Constraint.
func (c Constraint) AsLocationConstraint() (*LocationConstraint, bool) {
	return nil, false
}

// AsScriptConstraint is the BasicConstraint implementation for Constraint.
func (c Constraint) AsScriptConstraint() (*ScriptConstraint, bool) {
	return nil, false
}

// AsConstraint is the BasicConstraint implementation for Constraint.
func (c Constraint) AsConstraint() (*Constraint, bool) {
	return &c, true
}

// AsBasicConstraint is the BasicConstraint implementation for Constraint.
func (c Constraint) AsBasicConstraint() (BasicConstraint, bool) {
	return &c, true
}

// ConstraintList list response for get Constraints
type ConstraintList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]BasicConstraint `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ConstraintList struct.
func (cl *ConstraintList) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				cl.NextLink = &nextLink
			}
		case "value":
			if v != nil {
				value, err := unmarshalBasicConstraintArray(*v)
				if err != nil {
					return err
				}
				cl.Value = &value
			}
		}
	}

	return nil
}

// ConstraintListIterator provides access to a complete listing of Constraint values.
type ConstraintListIterator struct {
	i    int
	page ConstraintListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ConstraintListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConstraintListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ConstraintListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ConstraintListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ConstraintListIterator) Response() ConstraintList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ConstraintListIterator) Value() BasicConstraint {
	if !iter.page.NotDone() {
		return Constraint{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ConstraintListIterator type.
func NewConstraintListIterator(page ConstraintListPage) ConstraintListIterator {
	return ConstraintListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cl ConstraintList) IsEmpty() bool {
	return cl.Value == nil || len(*cl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cl ConstraintList) hasNextLink() bool {
	return cl.NextLink != nil && len(*cl.NextLink) != 0
}

// constraintListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cl ConstraintList) constraintListPreparer(ctx context.Context) (*http.Request, error) {
	if !cl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cl.NextLink)))
}

// ConstraintListPage contains a page of BasicConstraint values.
type ConstraintListPage struct {
	fn func(context.Context, ConstraintList) (ConstraintList, error)
	cl ConstraintList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ConstraintListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConstraintListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cl)
		if err != nil {
			return err
		}
		page.cl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ConstraintListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ConstraintListPage) NotDone() bool {
	return !page.cl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ConstraintListPage) Response() ConstraintList {
	return page.cl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ConstraintListPage) Values() []BasicConstraint {
	if page.cl.IsEmpty() {
		return nil
	}
	return *page.cl.Value
}

// Creates a new instance of the ConstraintListPage type.
func NewConstraintListPage(getNextPage func(context.Context, ConstraintList) (ConstraintList, error)) ConstraintListPage {
	return ConstraintListPage{fn: getNextPage}
}

// ConstraintModel ...
type ConstraintModel struct {
	autorest.Response `json:"-"`
	Value             BasicConstraint `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ConstraintModel struct.
func (cm *ConstraintModel) UnmarshalJSON(body []byte) error {
	c, err := unmarshalBasicConstraint(body)
	if err != nil {
		return err
	}
	cm.Value = c

	return nil
}

// ConstraintsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ConstraintsDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ConstraintsDeleteFuture) Result(client ConstraintsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ConstraintsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ConsumerInvitation a consumer Invitation data transfer object.
type ConsumerInvitation struct {
	autorest.Response `json:"-"`
	// Location - READ-ONLY; Invitation location
	Location *string `json:"location,omitempty"`
	// ConsumerInvitationProperties - Properties on the account
	*ConsumerInvitationProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ConsumerInvitation.
func (ci ConsumerInvitation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ci.ConsumerInvitationProperties != nil {
		objectMap["properties"] = ci.ConsumerInvitationProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ConsumerInvitation struct.
func (ci *ConsumerInvitation) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ci.Location = &location
			}
		case "properties":
			if v != nil {
				var consumerInvitationProperties ConsumerInvitationProperties
				err = json.Unmarshal(*v, &consumerInvitationProperties)
				if err != nil {
					return err
				}
				ci.ConsumerInvitationProperties = &consumerInvitationProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ci.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ci.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ci.Type = &typeVar
			}
		}
	}

	return nil
}

// ConsumerInvitationList list response for get InvitationList
type ConsumerInvitationList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]ConsumerInvitation `json:"value,omitempty"`
}

// ConsumerInvitationListIterator provides access to a complete listing of ConsumerInvitation values.
type ConsumerInvitationListIterator struct {
	i    int
	page ConsumerInvitationListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ConsumerInvitationListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConsumerInvitationListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ConsumerInvitationListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ConsumerInvitationListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ConsumerInvitationListIterator) Response() ConsumerInvitationList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ConsumerInvitationListIterator) Value() ConsumerInvitation {
	if !iter.page.NotDone() {
		return ConsumerInvitation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ConsumerInvitationListIterator type.
func NewConsumerInvitationListIterator(page ConsumerInvitationListPage) ConsumerInvitationListIterator {
	return ConsumerInvitationListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cil ConsumerInvitationList) IsEmpty() bool {
	return cil.Value == nil || len(*cil.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cil ConsumerInvitationList) hasNextLink() bool {
	return cil.NextLink != nil && len(*cil.NextLink) != 0
}

// consumerInvitationListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cil ConsumerInvitationList) consumerInvitationListPreparer(ctx context.Context) (*http.Request, error) {
	if !cil.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cil.NextLink)))
}

// ConsumerInvitationListPage contains a page of ConsumerInvitation values.
type ConsumerInvitationListPage struct {
	fn  func(context.Context, ConsumerInvitationList) (ConsumerInvitationList, error)
	cil ConsumerInvitationList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ConsumerInvitationListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConsumerInvitationListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cil)
		if err != nil {
			return err
		}
		page.cil = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ConsumerInvitationListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ConsumerInvitationListPage) NotDone() bool {
	return !page.cil.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ConsumerInvitationListPage) Response() ConsumerInvitationList {
	return page.cil
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ConsumerInvitationListPage) Values() []ConsumerInvitation {
	if page.cil.IsEmpty() {
		return nil
	}
	return *page.cil.Value
}

// Creates a new instance of the ConsumerInvitationListPage type.
func NewConsumerInvitationListPage(getNextPage func(context.Context, ConsumerInvitationList) (ConsumerInvitationList, error)) ConsumerInvitationListPage {
	return ConsumerInvitationListPage{fn: getNextPage}
}

// ConsumerInvitationProperties properties of consumer invitation
type ConsumerInvitationProperties struct {
	// Description - READ-ONLY; Description shared when the invitation was created
	Description *string `json:"description,omitempty"`
	// InvitationID - Unique id of the invitation.
	InvitationID *string `json:"invitationId,omitempty"`
	// InvitationStatus - READ-ONLY; The status of the invitation. Possible values include: 'Pending', 'Rejected', 'Accepted'
	InvitationStatus InvitationStatus `json:"invitationStatus,omitempty"`
	// ProposalName - READ-ONLY; Gets the source proposal Name.
	ProposalName *string `json:"proposalName,omitempty"`
	// ProviderEmail - READ-ONLY; Email of the provider who created the resource
	ProviderEmail *string `json:"providerEmail,omitempty"`
	// ProviderName - READ-ONLY; Name of the provider who created the resource
	ProviderName *string `json:"providerName,omitempty"`
	// ProviderTenantName - READ-ONLY; Tenant name of the provider who created the resource
	ProviderTenantName *string `json:"providerTenantName,omitempty"`
	// RespondedAt - READ-ONLY; The time the recipient responded to the invitation.
	RespondedAt *date.Time `json:"respondedAt,omitempty"`
	// SentAt - READ-ONLY; Gets the time at which the invitation was sent.
	SentAt *date.Time `json:"sentAt,omitempty"`
	// TermsOfUse - READ-ONLY; Terms of use proposal when the invitation was created
	TermsOfUse *string `json:"termsOfUse,omitempty"`
	// UserEmail - READ-ONLY; Email of the user who created the resource
	UserEmail *string `json:"userEmail,omitempty"`
	// UserName - READ-ONLY; Name of the user who created the resource
	UserName *string `json:"userName,omitempty"`
}

// MarshalJSON is the custom marshaler for ConsumerInvitationProperties.
func (cip ConsumerInvitationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cip.InvitationID != nil {
		objectMap["invitationId"] = cip.InvitationID
	}
	return json.Marshal(objectMap)
}

// DataAsset data asset that can be referenced from a proposal.
type DataAsset struct {
	autorest.Response `json:"-"`
	// DataAssetProperties - The property bag of the DataAsset
	*DataAssetProperties `json:"properties,omitempty"`
	// SystemData - SystemData Info of dataAsset
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DataAsset.
func (da DataAsset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if da.DataAssetProperties != nil {
		objectMap["properties"] = da.DataAssetProperties
	}
	if da.SystemData != nil {
		objectMap["systemData"] = da.SystemData
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DataAsset struct.
func (da *DataAsset) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var dataAssetProperties DataAssetProperties
				err = json.Unmarshal(*v, &dataAssetProperties)
				if err != nil {
					return err
				}
				da.DataAssetProperties = &dataAssetProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				da.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				da.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				da.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				da.Type = &typeVar
			}
		}
	}

	return nil
}

// DataAssetList list response for get data assets
type DataAssetList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]DataAsset `json:"value,omitempty"`
}

// DataAssetListIterator provides access to a complete listing of DataAsset values.
type DataAssetListIterator struct {
	i    int
	page DataAssetListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DataAssetListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataAssetListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DataAssetListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DataAssetListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DataAssetListIterator) Response() DataAssetList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DataAssetListIterator) Value() DataAsset {
	if !iter.page.NotDone() {
		return DataAsset{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DataAssetListIterator type.
func NewDataAssetListIterator(page DataAssetListPage) DataAssetListIterator {
	return DataAssetListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dal DataAssetList) IsEmpty() bool {
	return dal.Value == nil || len(*dal.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dal DataAssetList) hasNextLink() bool {
	return dal.NextLink != nil && len(*dal.NextLink) != 0
}

// dataAssetListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dal DataAssetList) dataAssetListPreparer(ctx context.Context) (*http.Request, error) {
	if !dal.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dal.NextLink)))
}

// DataAssetListPage contains a page of DataAsset values.
type DataAssetListPage struct {
	fn  func(context.Context, DataAssetList) (DataAssetList, error)
	dal DataAssetList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DataAssetListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataAssetListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dal)
		if err != nil {
			return err
		}
		page.dal = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DataAssetListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DataAssetListPage) NotDone() bool {
	return !page.dal.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DataAssetListPage) Response() DataAssetList {
	return page.dal
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DataAssetListPage) Values() []DataAsset {
	if page.dal.IsEmpty() {
		return nil
	}
	return *page.dal.Value
}

// Creates a new instance of the DataAssetListPage type.
func NewDataAssetListPage(getNextPage func(context.Context, DataAssetList) (DataAssetList, error)) DataAssetListPage {
	return DataAssetListPage{fn: getNextPage}
}

// DataAssetProperties properties of the DataAsset
type DataAssetProperties struct {
	// DataAssetID - READ-ONLY; Unique id for identifying a data asset resource
	DataAssetID *string `json:"dataAssetId,omitempty"`
	// DataProcessingStrategy - Data processing strategy to use for the the child DataSets. Possible values include: 'CopyBased', 'InPlace'
	DataProcessingStrategy DataProcessingStrategy `json:"dataProcessingStrategy,omitempty"`
	// Description - General Description of the DataSet content
	Description *string `json:"description,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the DataAsset. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateMoving', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for DataAssetProperties.
func (dap DataAssetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dap.DataProcessingStrategy != "" {
		objectMap["dataProcessingStrategy"] = dap.DataProcessingStrategy
	}
	if dap.Description != nil {
		objectMap["description"] = dap.Description
	}
	return json.Marshal(objectMap)
}

// DataAssetReference reference to a data asset.
type DataAssetReference struct {
	autorest.Response `json:"-"`
	// DataAssetReferenceProperties - Properties on the dataset reference
	*DataAssetReferenceProperties `json:"properties,omitempty"`
	// SystemData - SystemData Info of dataAssetReference
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DataAssetReference.
func (dar DataAssetReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dar.DataAssetReferenceProperties != nil {
		objectMap["properties"] = dar.DataAssetReferenceProperties
	}
	if dar.SystemData != nil {
		objectMap["systemData"] = dar.SystemData
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DataAssetReference struct.
func (dar *DataAssetReference) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var dataAssetReferenceProperties DataAssetReferenceProperties
				err = json.Unmarshal(*v, &dataAssetReferenceProperties)
				if err != nil {
					return err
				}
				dar.DataAssetReferenceProperties = &dataAssetReferenceProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				dar.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dar.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dar.Type = &typeVar
			}
		}
	}

	return nil
}

// DataAssetReferenceList list response for get dataSet references
type DataAssetReferenceList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]DataAssetReference `json:"value,omitempty"`
}

// DataAssetReferenceListIterator provides access to a complete listing of DataAssetReference values.
type DataAssetReferenceListIterator struct {
	i    int
	page DataAssetReferenceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DataAssetReferenceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataAssetReferenceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DataAssetReferenceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DataAssetReferenceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DataAssetReferenceListIterator) Response() DataAssetReferenceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DataAssetReferenceListIterator) Value() DataAssetReference {
	if !iter.page.NotDone() {
		return DataAssetReference{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DataAssetReferenceListIterator type.
func NewDataAssetReferenceListIterator(page DataAssetReferenceListPage) DataAssetReferenceListIterator {
	return DataAssetReferenceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (darl DataAssetReferenceList) IsEmpty() bool {
	return darl.Value == nil || len(*darl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (darl DataAssetReferenceList) hasNextLink() bool {
	return darl.NextLink != nil && len(*darl.NextLink) != 0
}

// dataAssetReferenceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (darl DataAssetReferenceList) dataAssetReferenceListPreparer(ctx context.Context) (*http.Request, error) {
	if !darl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(darl.NextLink)))
}

// DataAssetReferenceListPage contains a page of DataAssetReference values.
type DataAssetReferenceListPage struct {
	fn   func(context.Context, DataAssetReferenceList) (DataAssetReferenceList, error)
	darl DataAssetReferenceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DataAssetReferenceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataAssetReferenceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.darl)
		if err != nil {
			return err
		}
		page.darl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DataAssetReferenceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DataAssetReferenceListPage) NotDone() bool {
	return !page.darl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DataAssetReferenceListPage) Response() DataAssetReferenceList {
	return page.darl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DataAssetReferenceListPage) Values() []DataAssetReference {
	if page.darl.IsEmpty() {
		return nil
	}
	return *page.darl.Value
}

// Creates a new instance of the DataAssetReferenceListPage type.
func NewDataAssetReferenceListPage(getNextPage func(context.Context, DataAssetReferenceList) (DataAssetReferenceList, error)) DataAssetReferenceListPage {
	return DataAssetReferenceListPage{fn: getNextPage}
}

// DataAssetReferenceProperties properties of data set reference data transfer object.
type DataAssetReferenceProperties struct {
	// DataAssetID - The unique identifier of the referenced data asset
	DataAssetID *string `json:"dataAssetId,omitempty"`
	// DataAssetReferenceID - READ-ONLY; Unique id for identifying a dataset reference resource
	DataAssetReferenceID *string `json:"dataAssetReferenceId,omitempty"`
	// Description - General Description of the data asset reference
	Description *string `json:"description,omitempty"`
	// OwnerID - READ-ONLY; The participant id of the data asset owner
	OwnerID *string `json:"ownerId,omitempty"`
}

// MarshalJSON is the custom marshaler for DataAssetReferenceProperties.
func (darp DataAssetReferenceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if darp.DataAssetID != nil {
		objectMap["dataAssetId"] = darp.DataAssetID
	}
	if darp.Description != nil {
		objectMap["description"] = darp.Description
	}
	return json.Marshal(objectMap)
}

// DataAssetReferencesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type DataAssetReferencesDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *DataAssetReferencesDeleteFuture) Result(client DataAssetReferencesClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.DataAssetReferencesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.DataAssetReferencesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.DataAssetReferencesDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// DataAssetsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type DataAssetsDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *DataAssetsDeleteFuture) Result(client DataAssetsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.DataAssetsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.DataAssetsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.DataAssetsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BasicDataSet a set of data from external storage
type BasicDataSet interface {
	AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool)
	AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool)
	AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool)
	AsBlobContainerDataSet() (*BlobContainerDataSet, bool)
	AsBlobDataSet() (*BlobDataSet, bool)
	AsBlobFolderDataSet() (*BlobFolderDataSet, bool)
	AsDataSet() (*DataSet, bool)
}

// DataSet a set of data from external storage
type DataSet struct {
	autorest.Response `json:"-"`
	// Kind - Possible values include: 'KindDataSet', 'KindAdlsGen2File', 'KindAdlsGen2FileSystem', 'KindAdlsGen2Folder', 'KindContainer', 'KindBlob', 'KindBlobFolder'
	Kind KindBasicDataSet `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

func unmarshalBasicDataSet(body []byte) (BasicDataSet, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindAdlsGen2File):
		var ag2fds ADLSGen2FileDataSet
		err := json.Unmarshal(body, &ag2fds)
		return ag2fds, err
	case string(KindAdlsGen2FileSystem):
		var ag2fsds ADLSGen2FileSystemDataSet
		err := json.Unmarshal(body, &ag2fsds)
		return ag2fsds, err
	case string(KindAdlsGen2Folder):
		var ag2fds ADLSGen2FolderDataSet
		err := json.Unmarshal(body, &ag2fds)
		return ag2fds, err
	case string(KindContainer):
		var bcds BlobContainerDataSet
		err := json.Unmarshal(body, &bcds)
		return bcds, err
	case string(KindBlob):
		var bds BlobDataSet
		err := json.Unmarshal(body, &bds)
		return bds, err
	case string(KindBlobFolder):
		var bfds BlobFolderDataSet
		err := json.Unmarshal(body, &bfds)
		return bfds, err
	default:
		var ds DataSet
		err := json.Unmarshal(body, &ds)
		return ds, err
	}
}
func unmarshalBasicDataSetArray(body []byte) ([]BasicDataSet, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	dsArray := make([]BasicDataSet, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ds, err := unmarshalBasicDataSet(*rawMessage)
		if err != nil {
			return nil, err
		}
		dsArray[index] = ds
	}
	return dsArray, nil
}

// MarshalJSON is the custom marshaler for DataSet.
func (ds DataSet) MarshalJSON() ([]byte, error) {
	ds.Kind = KindDataSet
	objectMap := make(map[string]interface{})
	if ds.Kind != "" {
		objectMap["kind"] = ds.Kind
	}
	return json.Marshal(objectMap)
}

// AsADLSGen2FileDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsADLSGen2FileDataSet() (*ADLSGen2FileDataSet, bool) {
	return nil, false
}

// AsADLSGen2FileSystemDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsADLSGen2FileSystemDataSet() (*ADLSGen2FileSystemDataSet, bool) {
	return nil, false
}

// AsADLSGen2FolderDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsADLSGen2FolderDataSet() (*ADLSGen2FolderDataSet, bool) {
	return nil, false
}

// AsBlobContainerDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsBlobContainerDataSet() (*BlobContainerDataSet, bool) {
	return nil, false
}

// AsBlobDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsBlobDataSet() (*BlobDataSet, bool) {
	return nil, false
}

// AsBlobFolderDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsBlobFolderDataSet() (*BlobFolderDataSet, bool) {
	return nil, false
}

// AsDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsDataSet() (*DataSet, bool) {
	return &ds, true
}

// AsBasicDataSet is the BasicDataSet implementation for DataSet.
func (ds DataSet) AsBasicDataSet() (BasicDataSet, bool) {
	return &ds, true
}

// DataSetList list response for get data assets
type DataSetList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]BasicDataSet `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for DataSetList struct.
func (dsl *DataSetList) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				dsl.NextLink = &nextLink
			}
		case "value":
			if v != nil {
				value, err := unmarshalBasicDataSetArray(*v)
				if err != nil {
					return err
				}
				dsl.Value = &value
			}
		}
	}

	return nil
}

// DataSetListIterator provides access to a complete listing of DataSet values.
type DataSetListIterator struct {
	i    int
	page DataSetListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DataSetListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataSetListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DataSetListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DataSetListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DataSetListIterator) Response() DataSetList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DataSetListIterator) Value() BasicDataSet {
	if !iter.page.NotDone() {
		return DataSet{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DataSetListIterator type.
func NewDataSetListIterator(page DataSetListPage) DataSetListIterator {
	return DataSetListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dsl DataSetList) IsEmpty() bool {
	return dsl.Value == nil || len(*dsl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dsl DataSetList) hasNextLink() bool {
	return dsl.NextLink != nil && len(*dsl.NextLink) != 0
}

// dataSetListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dsl DataSetList) dataSetListPreparer(ctx context.Context) (*http.Request, error) {
	if !dsl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dsl.NextLink)))
}

// DataSetListPage contains a page of BasicDataSet values.
type DataSetListPage struct {
	fn  func(context.Context, DataSetList) (DataSetList, error)
	dsl DataSetList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DataSetListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataSetListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dsl)
		if err != nil {
			return err
		}
		page.dsl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DataSetListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DataSetListPage) NotDone() bool {
	return !page.dsl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DataSetListPage) Response() DataSetList {
	return page.dsl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DataSetListPage) Values() []BasicDataSet {
	if page.dsl.IsEmpty() {
		return nil
	}
	return *page.dsl.Value
}

// Creates a new instance of the DataSetListPage type.
func NewDataSetListPage(getNextPage func(context.Context, DataSetList) (DataSetList, error)) DataSetListPage {
	return DataSetListPage{fn: getNextPage}
}

// DataSetModel ...
type DataSetModel struct {
	autorest.Response `json:"-"`
	Value             BasicDataSet `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for DataSetModel struct.
func (dsm *DataSetModel) UnmarshalJSON(body []byte) error {
	ds, err := unmarshalBasicDataSet(body)
	if err != nil {
		return err
	}
	dsm.Value = ds

	return nil
}

// DataSetsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type DataSetsDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *DataSetsDeleteFuture) Result(client DataSetsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.DataSetsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.DataSetsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.DataSetsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// DefaultDto base data transfer object implementation for default resources.
type DefaultDto struct {
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Location - Location of the azure resource.
	Location *string `json:"location,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Tags - Tags on the azure resource.
	Tags map[string]*string `json:"tags"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DefaultDto.
func (dd DefaultDto) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dd.Location != nil {
		objectMap["location"] = dd.Location
	}
	if dd.Tags != nil {
		objectMap["tags"] = dd.Tags
	}
	return json.Marshal(objectMap)
}

// DiagnosticPolicy a diagnostic policy.
type DiagnosticPolicy struct {
	// DiagnosticPolicyProperties - Properties for diagnostic policy
	*DiagnosticPolicyProperties `json:"properties,omitempty"`
	// SystemData - SystemData Info of policy
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
	// Kind - Possible values include: 'KindPolicy', 'KindDiagnosticLevel'
	Kind KindBasicPolicy `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for DiagnosticPolicy.
func (dp DiagnosticPolicy) MarshalJSON() ([]byte, error) {
	dp.Kind = KindDiagnosticLevel
	objectMap := make(map[string]interface{})
	if dp.DiagnosticPolicyProperties != nil {
		objectMap["properties"] = dp.DiagnosticPolicyProperties
	}
	if dp.SystemData != nil {
		objectMap["systemData"] = dp.SystemData
	}
	if dp.Kind != "" {
		objectMap["kind"] = dp.Kind
	}
	return json.Marshal(objectMap)
}

// AsDiagnosticPolicy is the BasicPolicy implementation for DiagnosticPolicy.
func (dp DiagnosticPolicy) AsDiagnosticPolicy() (*DiagnosticPolicy, bool) {
	return &dp, true
}

// AsPolicy is the BasicPolicy implementation for DiagnosticPolicy.
func (dp DiagnosticPolicy) AsPolicy() (*Policy, bool) {
	return nil, false
}

// AsBasicPolicy is the BasicPolicy implementation for DiagnosticPolicy.
func (dp DiagnosticPolicy) AsBasicPolicy() (BasicPolicy, bool) {
	return &dp, true
}

// UnmarshalJSON is the custom unmarshaler for DiagnosticPolicy struct.
func (dp *DiagnosticPolicy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var diagnosticPolicyProperties DiagnosticPolicyProperties
				err = json.Unmarshal(*v, &diagnosticPolicyProperties)
				if err != nil {
					return err
				}
				dp.DiagnosticPolicyProperties = &diagnosticPolicyProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				dp.SystemData = &systemData
			}
		case "kind":
			if v != nil {
				var kind KindBasicPolicy
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				dp.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dp.Type = &typeVar
			}
		}
	}

	return nil
}

// DiagnosticPolicyProperties a diagnostic policy transfer object.
type DiagnosticPolicyProperties struct {
	// Description - Description of the policy
	Description *string `json:"description,omitempty"`
	// LogLevel - The policy log level. Possible values include: 'LogLevelVerbose', 'LogLevelInformation', 'LogLevelWarning', 'LogLevelError', 'LogLevelCritical'
	LogLevel LogLevel `json:"logLevel,omitempty"`
}

// DimensionProperties properties for dimension
type DimensionProperties struct {
	// DisplayName - localized display name of the dimension to customer
	DisplayName *string `json:"displayName,omitempty"`
	// Name - dimension name
	Name *string `json:"name,omitempty"`
}

// Entitlement grants access to another shared resource in the same proposal, with optional constraints and
// policies
type Entitlement struct {
	autorest.Response `json:"-"`
	// EntitlementProperties - Properties on the entitlement
	*EntitlementProperties `json:"properties,omitempty"`
	// SystemData - SystemData Info of dataAssetReference
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Entitlement.
func (e Entitlement) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if e.EntitlementProperties != nil {
		objectMap["properties"] = e.EntitlementProperties
	}
	if e.SystemData != nil {
		objectMap["systemData"] = e.SystemData
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Entitlement struct.
func (e *Entitlement) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var entitlementProperties EntitlementProperties
				err = json.Unmarshal(*v, &entitlementProperties)
				if err != nil {
					return err
				}
				e.EntitlementProperties = &entitlementProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				e.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				e.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				e.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				e.Type = &typeVar
			}
		}
	}

	return nil
}

// EntitlementList list response for get Entitlements
type EntitlementList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]Entitlement `json:"value,omitempty"`
}

// EntitlementListIterator provides access to a complete listing of Entitlement values.
type EntitlementListIterator struct {
	i    int
	page EntitlementListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *EntitlementListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EntitlementListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *EntitlementListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter EntitlementListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter EntitlementListIterator) Response() EntitlementList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter EntitlementListIterator) Value() Entitlement {
	if !iter.page.NotDone() {
		return Entitlement{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the EntitlementListIterator type.
func NewEntitlementListIterator(page EntitlementListPage) EntitlementListIterator {
	return EntitlementListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (el EntitlementList) IsEmpty() bool {
	return el.Value == nil || len(*el.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (el EntitlementList) hasNextLink() bool {
	return el.NextLink != nil && len(*el.NextLink) != 0
}

// entitlementListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (el EntitlementList) entitlementListPreparer(ctx context.Context) (*http.Request, error) {
	if !el.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(el.NextLink)))
}

// EntitlementListPage contains a page of Entitlement values.
type EntitlementListPage struct {
	fn func(context.Context, EntitlementList) (EntitlementList, error)
	el EntitlementList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *EntitlementListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EntitlementListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.el)
		if err != nil {
			return err
		}
		page.el = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *EntitlementListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page EntitlementListPage) NotDone() bool {
	return !page.el.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page EntitlementListPage) Response() EntitlementList {
	return page.el
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page EntitlementListPage) Values() []Entitlement {
	if page.el.IsEmpty() {
		return nil
	}
	return *page.el.Value
}

// Creates a new instance of the EntitlementListPage type.
func NewEntitlementListPage(getNextPage func(context.Context, EntitlementList) (EntitlementList, error)) EntitlementListPage {
	return EntitlementListPage{fn: getNextPage}
}

// EntitlementProperties grants access to another shared resource in the same proposal, with optional some
// constraints and policies
type EntitlementProperties struct {
	// Description - Textual description of the entitlement
	Description *string `json:"description,omitempty"`
	// ResourceID - The unique identifier of the resource of the entitlement.
	// Must be a reference resource from the same proposal.
	ResourceID *string `json:"resourceId,omitempty"`
	// ResourceType - The type of resourced used by the entitlement. Possible values include: 'ResourceTypeDataAssetReference', 'ResourceTypeScriptReference'
	ResourceType ResourceType `json:"resourceType,omitempty"`
	// SubjectID - The unique identifier of the subject of the entitlement.
	// The subject must be a participant in the same proposal.
	SubjectID *string `json:"subjectId,omitempty"`
}

// EntitlementsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type EntitlementsDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *EntitlementsDeleteFuture) Result(client EntitlementsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.EntitlementsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.EntitlementsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.EntitlementsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// Error the data collaboration error model.
type Error struct {
	// Error - The data share error body
	Error *ErrorInfo `json:"error,omitempty"`
}

// ErrorInfo the data collaboration error body model.
type ErrorInfo struct {
	// Code - Code of the error
	Code *string `json:"code,omitempty"`
	// Details - Nested details of the error model
	Details *[]ErrorInfo `json:"details,omitempty"`
	// Message - Message of the error
	Message *string `json:"message,omitempty"`
	// Target - Target of the error
	Target *string `json:"target,omitempty"`
}

// Identity identity of resource
type Identity struct {
	// PrincipalID - READ-ONLY; service principal Id
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; Tenant Id
	TenantID *string `json:"tenantId,omitempty"`
	// Type - Identity Type. Possible values include: 'SystemAssigned'
	Type Type `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.Type != "" {
		objectMap["type"] = i.Type
	}
	return json.Marshal(objectMap)
}

// Invitation invitation to participate in a shared proposal
type Invitation struct {
	autorest.Response `json:"-"`
	// InvitationProperties - Properties on the Invitation
	*InvitationProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Invitation.
func (i Invitation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.InvitationProperties != nil {
		objectMap["properties"] = i.InvitationProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Invitation struct.
func (i *Invitation) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var invitationProperties InvitationProperties
				err = json.Unmarshal(*v, &invitationProperties)
				if err != nil {
					return err
				}
				i.InvitationProperties = &invitationProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				i.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				i.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				i.Type = &typeVar
			}
		}
	}

	return nil
}

// InvitationList list response for get InvitationList
type InvitationList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]Invitation `json:"value,omitempty"`
}

// InvitationListIterator provides access to a complete listing of Invitation values.
type InvitationListIterator struct {
	i    int
	page InvitationListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *InvitationListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InvitationListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *InvitationListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter InvitationListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter InvitationListIterator) Response() InvitationList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter InvitationListIterator) Value() Invitation {
	if !iter.page.NotDone() {
		return Invitation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the InvitationListIterator type.
func NewInvitationListIterator(page InvitationListPage) InvitationListIterator {
	return InvitationListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (il InvitationList) IsEmpty() bool {
	return il.Value == nil || len(*il.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (il InvitationList) hasNextLink() bool {
	return il.NextLink != nil && len(*il.NextLink) != 0
}

// invitationListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (il InvitationList) invitationListPreparer(ctx context.Context) (*http.Request, error) {
	if !il.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(il.NextLink)))
}

// InvitationListPage contains a page of Invitation values.
type InvitationListPage struct {
	fn func(context.Context, InvitationList) (InvitationList, error)
	il InvitationList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *InvitationListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InvitationListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.il)
		if err != nil {
			return err
		}
		page.il = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *InvitationListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page InvitationListPage) NotDone() bool {
	return !page.il.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page InvitationListPage) Response() InvitationList {
	return page.il
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page InvitationListPage) Values() []Invitation {
	if page.il.IsEmpty() {
		return nil
	}
	return *page.il.Value
}

// Creates a new instance of the InvitationListPage type.
func NewInvitationListPage(getNextPage func(context.Context, InvitationList) (InvitationList, error)) InvitationListPage {
	return InvitationListPage{fn: getNextPage}
}

// InvitationProperties invitation property bag.
type InvitationProperties struct {
	// InvitationID - READ-ONLY; unique invitation id
	InvitationID *string `json:"invitationId,omitempty"`
	// InvitationStatus - READ-ONLY; The status of the invitation. Possible values include: 'Pending', 'Rejected', 'Accepted'
	InvitationStatus InvitationStatus `json:"invitationStatus,omitempty"`
	// RespondedAt - READ-ONLY; The time the recipient responded to the invitation.
	RespondedAt *date.Time `json:"respondedAt,omitempty"`
	// SentAt - READ-ONLY; Gets the time at which the invitation was sent.
	SentAt *date.Time `json:"sentAt,omitempty"`
	// TargetActiveDirectoryID - The target Azure AD Id. Can't be combined with email.
	TargetActiveDirectoryID *string `json:"targetActiveDirectoryId,omitempty"`
	// TargetEmail - The email the invitation is directed to.
	TargetEmail *string `json:"targetEmail,omitempty"`
	// TargetObjectID - The target user or application Id that invitation is being sent to.
	// Must be specified along TargetActiveDirectoryId. This enables sending
	// invitations to specific users or applications in an AD tenant.
	TargetObjectID *string `json:"targetObjectId,omitempty"`
	// UserEmail - READ-ONLY; Email of the user who created the resource
	UserEmail *string `json:"userEmail,omitempty"`
	// UserName - READ-ONLY; Name of the user who created the resource
	UserName *string `json:"userName,omitempty"`
}

// MarshalJSON is the custom marshaler for InvitationProperties.
func (IP InvitationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if IP.TargetActiveDirectoryID != nil {
		objectMap["targetActiveDirectoryId"] = IP.TargetActiveDirectoryID
	}
	if IP.TargetEmail != nil {
		objectMap["targetEmail"] = IP.TargetEmail
	}
	if IP.TargetObjectID != nil {
		objectMap["targetObjectId"] = IP.TargetObjectID
	}
	return json.Marshal(objectMap)
}

// LocationConstraint constraint used to only allow access if the resource is used within the specified Azure
// location.
type LocationConstraint struct {
	// LocationConstraintProperties - Properties for location constraint
	*LocationConstraintProperties `json:"properties,omitempty"`
	// SystemData - SystemData Info of script
	SystemData *SystemData `json:"systemData,omitempty"`
	// Kind - Possible values include: 'KindConstraint', 'KindLocation', 'KindScript'
	Kind Kind `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for LocationConstraint.
func (lc LocationConstraint) MarshalJSON() ([]byte, error) {
	lc.Kind = KindLocation
	objectMap := make(map[string]interface{})
	if lc.LocationConstraintProperties != nil {
		objectMap["properties"] = lc.LocationConstraintProperties
	}
	if lc.SystemData != nil {
		objectMap["systemData"] = lc.SystemData
	}
	if lc.Kind != "" {
		objectMap["kind"] = lc.Kind
	}
	return json.Marshal(objectMap)
}

// AsLocationConstraint is the BasicConstraint implementation for LocationConstraint.
func (lc LocationConstraint) AsLocationConstraint() (*LocationConstraint, bool) {
	return &lc, true
}

// AsScriptConstraint is the BasicConstraint implementation for LocationConstraint.
func (lc LocationConstraint) AsScriptConstraint() (*ScriptConstraint, bool) {
	return nil, false
}

// AsConstraint is the BasicConstraint implementation for LocationConstraint.
func (lc LocationConstraint) AsConstraint() (*Constraint, bool) {
	return nil, false
}

// AsBasicConstraint is the BasicConstraint implementation for LocationConstraint.
func (lc LocationConstraint) AsBasicConstraint() (BasicConstraint, bool) {
	return &lc, true
}

// UnmarshalJSON is the custom unmarshaler for LocationConstraint struct.
func (lc *LocationConstraint) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var locationConstraintProperties LocationConstraintProperties
				err = json.Unmarshal(*v, &locationConstraintProperties)
				if err != nil {
					return err
				}
				lc.LocationConstraintProperties = &locationConstraintProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				lc.SystemData = &systemData
			}
		case "kind":
			if v != nil {
				var kind Kind
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				lc.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				lc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				lc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				lc.Type = &typeVar
			}
		}
	}

	return nil
}

// LocationConstraintProperties properties for location constraint used to only allow access if the resource is
// used within the specified Azure location.
type LocationConstraintProperties struct {
	// Description - Description of the constraint.
	Description *string `json:"description,omitempty"`
	// Location - Location of the Azure resource (e.g. West US 2)
	Location *string `json:"location,omitempty"`
}

// OperationList list response for get operations.
type OperationList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]OperationModel `json:"value,omitempty"`
}

// OperationListIterator provides access to a complete listing of OperationModel values.
type OperationListIterator struct {
	i    int
	page OperationListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListIterator) Response() OperationList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListIterator) Value() OperationModel {
	if !iter.page.NotDone() {
		return OperationModel{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListIterator type.
func NewOperationListIterator(page OperationListPage) OperationListIterator {
	return OperationListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ol OperationList) IsEmpty() bool {
	return ol.Value == nil || len(*ol.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ol OperationList) hasNextLink() bool {
	return ol.NextLink != nil && len(*ol.NextLink) != 0
}

// operationListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ol OperationList) operationListPreparer(ctx context.Context) (*http.Request, error) {
	if !ol.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ol.NextLink)))
}

// OperationListPage contains a page of OperationModel values.
type OperationListPage struct {
	fn func(context.Context, OperationList) (OperationList, error)
	ol OperationList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ol)
		if err != nil {
			return err
		}
		page.ol = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListPage) NotDone() bool {
	return !page.ol.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListPage) Response() OperationList {
	return page.ol
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListPage) Values() []OperationModel {
	if page.ol.IsEmpty() {
		return nil
	}
	return *page.ol.Value
}

// Creates a new instance of the OperationListPage type.
func NewOperationListPage(getNextPage func(context.Context, OperationList) (OperationList, error)) OperationListPage {
	return OperationListPage{fn: getNextPage}
}

// OperationMetaLogSpecification log specifications for operation api
type OperationMetaLogSpecification struct {
	// BlobDuration - blob duration of the log
	BlobDuration *string `json:"blobDuration,omitempty"`
	// DisplayName - localized name of the log category
	DisplayName *string `json:"displayName,omitempty"`
	// Name - name of the log category
	Name *string `json:"name,omitempty"`
}

// OperationMetaMetricSpecification metric specifications for the operation
type OperationMetaMetricSpecification struct {
	// AggregationType - aggregation type of metric
	AggregationType *string `json:"aggregationType,omitempty"`
	// Dimensions - properties for dimension
	Dimensions *[]DimensionProperties `json:"dimensions,omitempty"`
	// DisplayDescription - description of the metric
	DisplayDescription *string `json:"displayDescription,omitempty"`
	// DisplayName - localized name of the metric
	DisplayName *string `json:"displayName,omitempty"`
	// EnableRegionalMdmAccount - enable regional mdm account
	EnableRegionalMdmAccount *string `json:"enableRegionalMdmAccount,omitempty"`
	// InternalMetricName - internal metric name
	InternalMetricName *string `json:"internalMetricName,omitempty"`
	// Name - name of the metric
	Name *string `json:"name,omitempty"`
	// ResourceIDDimensionNameOverride - dimension name use to replace resource id if specified
	ResourceIDDimensionNameOverride *string `json:"resourceIdDimensionNameOverride,omitempty"`
	// SupportedAggregationTypes - supported aggregation types
	SupportedAggregationTypes *[]string `json:"supportedAggregationTypes,omitempty"`
	// SupportedTimeGrainTypes - supported time grain types
	SupportedTimeGrainTypes *[]string `json:"supportedTimeGrainTypes,omitempty"`
	// Unit - units for the metric
	Unit *string `json:"unit,omitempty"`
}

// OperationMetaPropertyInfo properties on meta info
type OperationMetaPropertyInfo struct {
	// ServiceSpecification - meta service specification
	ServiceSpecification *OperationMetaServiceSpecification `json:"serviceSpecification,omitempty"`
}

// OperationMetaServiceSpecification the operation meta service specification
type OperationMetaServiceSpecification struct {
	// LogSpecifications - log specifications for the operation
	LogSpecifications *[]OperationMetaLogSpecification `json:"logSpecifications,omitempty"`
	// MetricSpecifications - metric specifications for the operation
	MetricSpecifications *[]OperationMetaMetricSpecification `json:"metricSpecifications,omitempty"`
}

// OperationModel the response model for get operations
type OperationModel struct {
	// Display - Properties on the operation
	Display *OperationModelProperties `json:"display,omitempty"`
	// Name - Operation name for display purposes
	Name *string `json:"name,omitempty"`
	// Origin - origin of the operation
	Origin *string `json:"origin,omitempty"`
	// OperationMetaPropertyInfo - properties for the operation meta info
	*OperationMetaPropertyInfo `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationModel.
func (om OperationModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if om.Display != nil {
		objectMap["display"] = om.Display
	}
	if om.Name != nil {
		objectMap["name"] = om.Name
	}
	if om.Origin != nil {
		objectMap["origin"] = om.Origin
	}
	if om.OperationMetaPropertyInfo != nil {
		objectMap["properties"] = om.OperationMetaPropertyInfo
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for OperationModel struct.
func (om *OperationModel) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "display":
			if v != nil {
				var display OperationModelProperties
				err = json.Unmarshal(*v, &display)
				if err != nil {
					return err
				}
				om.Display = &display
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				om.Name = &name
			}
		case "origin":
			if v != nil {
				var origin string
				err = json.Unmarshal(*v, &origin)
				if err != nil {
					return err
				}
				om.Origin = &origin
			}
		case "properties":
			if v != nil {
				var operationMetaPropertyInfo OperationMetaPropertyInfo
				err = json.Unmarshal(*v, &operationMetaPropertyInfo)
				if err != nil {
					return err
				}
				om.OperationMetaPropertyInfo = &operationMetaPropertyInfo
			}
		}
	}

	return nil
}

// OperationModelProperties properties on operations
type OperationModelProperties struct {
	// Description - Description of the operation for display purposes
	Description *string `json:"description,omitempty"`
	// Operation - Name of the operation for display purposes
	Operation *string `json:"operation,omitempty"`
	// Provider - Name of the provider for display purposes
	Provider *string `json:"provider,omitempty"`
	// Resource - Name of the resource type for display purposes
	Resource *string `json:"resource,omitempty"`
}

// OperationResponse response for long running operation
type OperationResponse struct {
	autorest.Response `json:"-"`
	// EndTime - start time
	EndTime *date.Time `json:"endTime,omitempty"`
	// Error - The error property when status is failed.
	Error *ErrorInfo `json:"error,omitempty"`
	// StartTime - start time
	StartTime *date.Time `json:"startTime,omitempty"`
	// Status - Operation state of the long running operation. Possible values include: 'StatusAccepted', 'StatusInProgress', 'StatusTransientFailure', 'StatusSucceeded', 'StatusFailed', 'StatusCanceled'
	Status Status `json:"status,omitempty"`
}

// Participant participant information
type Participant struct {
	autorest.Response `json:"-"`
	// ParticipantProperties - Properties on the participant
	*ParticipantProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Participant.
func (p Participant) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.ParticipantProperties != nil {
		objectMap["properties"] = p.ParticipantProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Participant struct.
func (p *Participant) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var participantProperties ParticipantProperties
				err = json.Unmarshal(*v, &participantProperties)
				if err != nil {
					return err
				}
				p.ParticipantProperties = &participantProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				p.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				p.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				p.Type = &typeVar
			}
		}
	}

	return nil
}

// ParticipantList list response for get participants.
type ParticipantList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]Participant `json:"value,omitempty"`
}

// ParticipantListIterator provides access to a complete listing of Participant values.
type ParticipantListIterator struct {
	i    int
	page ParticipantListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ParticipantListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ParticipantListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ParticipantListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ParticipantListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ParticipantListIterator) Response() ParticipantList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ParticipantListIterator) Value() Participant {
	if !iter.page.NotDone() {
		return Participant{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ParticipantListIterator type.
func NewParticipantListIterator(page ParticipantListPage) ParticipantListIterator {
	return ParticipantListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pl ParticipantList) IsEmpty() bool {
	return pl.Value == nil || len(*pl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pl ParticipantList) hasNextLink() bool {
	return pl.NextLink != nil && len(*pl.NextLink) != 0
}

// participantListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pl ParticipantList) participantListPreparer(ctx context.Context) (*http.Request, error) {
	if !pl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pl.NextLink)))
}

// ParticipantListPage contains a page of Participant values.
type ParticipantListPage struct {
	fn func(context.Context, ParticipantList) (ParticipantList, error)
	pl ParticipantList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ParticipantListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ParticipantListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pl)
		if err != nil {
			return err
		}
		page.pl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ParticipantListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ParticipantListPage) NotDone() bool {
	return !page.pl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ParticipantListPage) Response() ParticipantList {
	return page.pl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ParticipantListPage) Values() []Participant {
	if page.pl.IsEmpty() {
		return nil
	}
	return *page.pl.Value
}

// Creates a new instance of the ParticipantListPage type.
func NewParticipantListPage(getNextPage func(context.Context, ParticipantList) (ParticipantList, error)) ParticipantListPage {
	return ParticipantListPage{fn: getNextPage}
}

// ParticipantProperties participant property bag.
type ParticipantProperties struct {
	// CreatedAt - READ-ONLY; Time at which the account was created.
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// ParticipantID - READ-ONLY; Unique id for identifying a participant
	ParticipantID *string `json:"participantId,omitempty"`
	// ProposalApprovalStatus - READ-ONLY; Current approval status. Possible values include: 'ProposalApprovalStatusPending', 'ProposalApprovalStatusApproved', 'ProposalApprovalStatusExpired'
	ProposalApprovalStatus ProposalApprovalStatus `json:"proposalApprovalStatus,omitempty"`
	// UserEmail - READ-ONLY; Email of the user who created the resource
	UserEmail *string `json:"userEmail,omitempty"`
	// UserName - READ-ONLY; Name of the user who created the resource
	UserName *string `json:"userName,omitempty"`
}

// Pipeline a pipeline data transfer object.
type Pipeline struct {
	autorest.Response `json:"-"`
	// PipelineProperties - Properties on the pipeline
	*PipelineProperties `json:"properties,omitempty"`
	// SystemData - SystemData Info of pipeline
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Pipeline.
func (p Pipeline) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.PipelineProperties != nil {
		objectMap["properties"] = p.PipelineProperties
	}
	if p.SystemData != nil {
		objectMap["systemData"] = p.SystemData
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Pipeline struct.
func (p *Pipeline) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var pipelineProperties PipelineProperties
				err = json.Unmarshal(*v, &pipelineProperties)
				if err != nil {
					return err
				}
				p.PipelineProperties = &pipelineProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				p.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				p.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				p.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				p.Type = &typeVar
			}
		}
	}

	return nil
}

// PipelineList list response for get Pipelines
type PipelineList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]Pipeline `json:"value,omitempty"`
}

// PipelineListIterator provides access to a complete listing of Pipeline values.
type PipelineListIterator struct {
	i    int
	page PipelineListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PipelineListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PipelineListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PipelineListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PipelineListIterator) Response() PipelineList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PipelineListIterator) Value() Pipeline {
	if !iter.page.NotDone() {
		return Pipeline{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PipelineListIterator type.
func NewPipelineListIterator(page PipelineListPage) PipelineListIterator {
	return PipelineListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pl PipelineList) IsEmpty() bool {
	return pl.Value == nil || len(*pl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pl PipelineList) hasNextLink() bool {
	return pl.NextLink != nil && len(*pl.NextLink) != 0
}

// pipelineListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pl PipelineList) pipelineListPreparer(ctx context.Context) (*http.Request, error) {
	if !pl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pl.NextLink)))
}

// PipelineListPage contains a page of Pipeline values.
type PipelineListPage struct {
	fn func(context.Context, PipelineList) (PipelineList, error)
	pl PipelineList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PipelineListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pl)
		if err != nil {
			return err
		}
		page.pl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PipelineListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PipelineListPage) NotDone() bool {
	return !page.pl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PipelineListPage) Response() PipelineList {
	return page.pl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PipelineListPage) Values() []Pipeline {
	if page.pl.IsEmpty() {
		return nil
	}
	return *page.pl.Value
}

// Creates a new instance of the PipelineListPage type.
func NewPipelineListPage(getNextPage func(context.Context, PipelineList) (PipelineList, error)) PipelineListPage {
	return PipelineListPage{fn: getNextPage}
}

// PipelineProperties pipeline property bag.
type PipelineProperties struct {
	// Description - General Description of the pipeline content
	Description *string `json:"description,omitempty"`
	// PipelineID - READ-ONLY; Unique id for identifying a pipeline resource
	PipelineID *string `json:"pipelineId,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the pipeline. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateMoving', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for PipelineProperties.
func (pp PipelineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pp.Description != nil {
		objectMap["description"] = pp.Description
	}
	return json.Marshal(objectMap)
}

// PipelineRun a pipeline run data transfer object.
type PipelineRun struct {
	autorest.Response `json:"-"`
	// PipelineRunProperties - Properties on the pipeline
	*PipelineRunProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PipelineRun.
func (pr PipelineRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pr.PipelineRunProperties != nil {
		objectMap["properties"] = pr.PipelineRunProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PipelineRun struct.
func (pr *PipelineRun) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var pipelineRunProperties PipelineRunProperties
				err = json.Unmarshal(*v, &pipelineRunProperties)
				if err != nil {
					return err
				}
				pr.PipelineRunProperties = &pipelineRunProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pr.Type = &typeVar
			}
		}
	}

	return nil
}

// PipelineRunList list response for get pipeline run.
type PipelineRunList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]PipelineRun `json:"value,omitempty"`
}

// PipelineRunListIterator provides access to a complete listing of PipelineRun values.
type PipelineRunListIterator struct {
	i    int
	page PipelineRunListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PipelineRunListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineRunListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PipelineRunListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PipelineRunListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PipelineRunListIterator) Response() PipelineRunList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PipelineRunListIterator) Value() PipelineRun {
	if !iter.page.NotDone() {
		return PipelineRun{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PipelineRunListIterator type.
func NewPipelineRunListIterator(page PipelineRunListPage) PipelineRunListIterator {
	return PipelineRunListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (prl PipelineRunList) IsEmpty() bool {
	return prl.Value == nil || len(*prl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (prl PipelineRunList) hasNextLink() bool {
	return prl.NextLink != nil && len(*prl.NextLink) != 0
}

// pipelineRunListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (prl PipelineRunList) pipelineRunListPreparer(ctx context.Context) (*http.Request, error) {
	if !prl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(prl.NextLink)))
}

// PipelineRunListPage contains a page of PipelineRun values.
type PipelineRunListPage struct {
	fn  func(context.Context, PipelineRunList) (PipelineRunList, error)
	prl PipelineRunList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PipelineRunListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineRunListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.prl)
		if err != nil {
			return err
		}
		page.prl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PipelineRunListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PipelineRunListPage) NotDone() bool {
	return !page.prl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PipelineRunListPage) Response() PipelineRunList {
	return page.prl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PipelineRunListPage) Values() []PipelineRun {
	if page.prl.IsEmpty() {
		return nil
	}
	return *page.prl.Value
}

// Creates a new instance of the PipelineRunListPage type.
func NewPipelineRunListPage(getNextPage func(context.Context, PipelineRunList) (PipelineRunList, error)) PipelineRunListPage {
	return PipelineRunListPage{fn: getNextPage}
}

// PipelineRunProperties a pipeline run property bag.
type PipelineRunProperties struct {
	// DurationMs - READ-ONLY; Pipeline run duration
	DurationMs *int32 `json:"durationMs,omitempty"`
	// EndTime - READ-ONLY; End time of pipeline
	EndTime *date.Time `json:"endTime,omitempty"`
	// ErrorMessage - READ-ONLY; Error message if any
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// PipelineRunStatus - READ-ONLY; Pipeline run status. Possible values include: 'Succeeded', 'Failed', 'InProgress', 'Queued', 'Cancelled', 'Canceling'
	PipelineRunStatus PipelineRunStatus `json:"pipelineRunStatus,omitempty"`
	// StartTime - READ-ONLY; Start time of pipeline
	StartTime *date.Time `json:"startTime,omitempty"`
	// UserEmail - READ-ONLY; Email of the user who created the resource
	UserEmail *string `json:"userEmail,omitempty"`
	// UserName - READ-ONLY; Name of the user who created the resource
	UserName *string `json:"userName,omitempty"`
}

// PipelineRunsCancelFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PipelineRunsCancelFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *PipelineRunsCancelFuture) Result(client PipelineRunsClient) (pr PipelineRun, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.PipelineRunsCancelFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.PipelineRunsCancelFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pr.Response.Response, err = future.GetResult(sender); err == nil && pr.Response.Response.StatusCode != http.StatusNoContent {
		pr, err = client.CancelResponder(pr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.PipelineRunsCancelFuture", "Result", pr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PipelinesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type PipelinesDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *PipelinesDeleteFuture) Result(client PipelinesClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.PipelinesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.PipelinesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.PipelinesDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BasicPipelineStep a single step of a pipeline.
type BasicPipelineStep interface {
	AsSynapseSparkPipelineStep() (*SynapseSparkPipelineStep, bool)
	AsPipelineStep() (*PipelineStep, bool)
}

// PipelineStep a single step of a pipeline.
type PipelineStep struct {
	autorest.Response `json:"-"`
	// Kind - Possible values include: 'KindPipelineStep', 'KindSynapseSpark'
	Kind KindBasicPipelineStep `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

func unmarshalBasicPipelineStep(body []byte) (BasicPipelineStep, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindSynapseSpark):
		var ssps SynapseSparkPipelineStep
		err := json.Unmarshal(body, &ssps)
		return ssps, err
	default:
		var ps PipelineStep
		err := json.Unmarshal(body, &ps)
		return ps, err
	}
}
func unmarshalBasicPipelineStepArray(body []byte) ([]BasicPipelineStep, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	psArray := make([]BasicPipelineStep, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ps, err := unmarshalBasicPipelineStep(*rawMessage)
		if err != nil {
			return nil, err
		}
		psArray[index] = ps
	}
	return psArray, nil
}

// MarshalJSON is the custom marshaler for PipelineStep.
func (ps PipelineStep) MarshalJSON() ([]byte, error) {
	ps.Kind = KindPipelineStep
	objectMap := make(map[string]interface{})
	if ps.Kind != "" {
		objectMap["kind"] = ps.Kind
	}
	return json.Marshal(objectMap)
}

// AsSynapseSparkPipelineStep is the BasicPipelineStep implementation for PipelineStep.
func (ps PipelineStep) AsSynapseSparkPipelineStep() (*SynapseSparkPipelineStep, bool) {
	return nil, false
}

// AsPipelineStep is the BasicPipelineStep implementation for PipelineStep.
func (ps PipelineStep) AsPipelineStep() (*PipelineStep, bool) {
	return &ps, true
}

// AsBasicPipelineStep is the BasicPipelineStep implementation for PipelineStep.
func (ps PipelineStep) AsBasicPipelineStep() (BasicPipelineStep, bool) {
	return &ps, true
}

// PipelineStepList list response for get Pipeline steps
type PipelineStepList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]BasicPipelineStep `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for PipelineStepList struct.
func (psl *PipelineStepList) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				psl.NextLink = &nextLink
			}
		case "value":
			if v != nil {
				value, err := unmarshalBasicPipelineStepArray(*v)
				if err != nil {
					return err
				}
				psl.Value = &value
			}
		}
	}

	return nil
}

// PipelineStepListIterator provides access to a complete listing of PipelineStep values.
type PipelineStepListIterator struct {
	i    int
	page PipelineStepListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PipelineStepListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineStepListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PipelineStepListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PipelineStepListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PipelineStepListIterator) Response() PipelineStepList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PipelineStepListIterator) Value() BasicPipelineStep {
	if !iter.page.NotDone() {
		return PipelineStep{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PipelineStepListIterator type.
func NewPipelineStepListIterator(page PipelineStepListPage) PipelineStepListIterator {
	return PipelineStepListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (psl PipelineStepList) IsEmpty() bool {
	return psl.Value == nil || len(*psl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (psl PipelineStepList) hasNextLink() bool {
	return psl.NextLink != nil && len(*psl.NextLink) != 0
}

// pipelineStepListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (psl PipelineStepList) pipelineStepListPreparer(ctx context.Context) (*http.Request, error) {
	if !psl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(psl.NextLink)))
}

// PipelineStepListPage contains a page of BasicPipelineStep values.
type PipelineStepListPage struct {
	fn  func(context.Context, PipelineStepList) (PipelineStepList, error)
	psl PipelineStepList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PipelineStepListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineStepListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.psl)
		if err != nil {
			return err
		}
		page.psl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PipelineStepListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PipelineStepListPage) NotDone() bool {
	return !page.psl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PipelineStepListPage) Response() PipelineStepList {
	return page.psl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PipelineStepListPage) Values() []BasicPipelineStep {
	if page.psl.IsEmpty() {
		return nil
	}
	return *page.psl.Value
}

// Creates a new instance of the PipelineStepListPage type.
func NewPipelineStepListPage(getNextPage func(context.Context, PipelineStepList) (PipelineStepList, error)) PipelineStepListPage {
	return PipelineStepListPage{fn: getNextPage}
}

// PipelineStepModel ...
type PipelineStepModel struct {
	autorest.Response `json:"-"`
	Value             BasicPipelineStep `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for PipelineStepModel struct.
func (psm *PipelineStepModel) UnmarshalJSON(body []byte) error {
	ps, err := unmarshalBasicPipelineStep(body)
	if err != nil {
		return err
	}
	psm.Value = ps

	return nil
}

// PipelineStepRun pipeline step run at data set level
type PipelineStepRun struct {
	autorest.Response `json:"-"`
	// PipelineStepRunProperties - Properties on the pipeline step run
	*PipelineStepRunProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PipelineStepRun.
func (psr PipelineStepRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if psr.PipelineStepRunProperties != nil {
		objectMap["properties"] = psr.PipelineStepRunProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PipelineStepRun struct.
func (psr *PipelineStepRun) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var pipelineStepRunProperties PipelineStepRunProperties
				err = json.Unmarshal(*v, &pipelineStepRunProperties)
				if err != nil {
					return err
				}
				psr.PipelineStepRunProperties = &pipelineStepRunProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				psr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				psr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				psr.Type = &typeVar
			}
		}
	}

	return nil
}

// PipelineStepRunList details of pipeline run
type PipelineStepRunList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]PipelineStepRun `json:"value,omitempty"`
}

// PipelineStepRunListIterator provides access to a complete listing of PipelineStepRun values.
type PipelineStepRunListIterator struct {
	i    int
	page PipelineStepRunListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PipelineStepRunListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineStepRunListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PipelineStepRunListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PipelineStepRunListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PipelineStepRunListIterator) Response() PipelineStepRunList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PipelineStepRunListIterator) Value() PipelineStepRun {
	if !iter.page.NotDone() {
		return PipelineStepRun{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PipelineStepRunListIterator type.
func NewPipelineStepRunListIterator(page PipelineStepRunListPage) PipelineStepRunListIterator {
	return PipelineStepRunListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (psrl PipelineStepRunList) IsEmpty() bool {
	return psrl.Value == nil || len(*psrl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (psrl PipelineStepRunList) hasNextLink() bool {
	return psrl.NextLink != nil && len(*psrl.NextLink) != 0
}

// pipelineStepRunListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (psrl PipelineStepRunList) pipelineStepRunListPreparer(ctx context.Context) (*http.Request, error) {
	if !psrl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(psrl.NextLink)))
}

// PipelineStepRunListPage contains a page of PipelineStepRun values.
type PipelineStepRunListPage struct {
	fn   func(context.Context, PipelineStepRunList) (PipelineStepRunList, error)
	psrl PipelineStepRunList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PipelineStepRunListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PipelineStepRunListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.psrl)
		if err != nil {
			return err
		}
		page.psrl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PipelineStepRunListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PipelineStepRunListPage) NotDone() bool {
	return !page.psrl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PipelineStepRunListPage) Response() PipelineStepRunList {
	return page.psrl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PipelineStepRunListPage) Values() []PipelineStepRun {
	if page.psrl.IsEmpty() {
		return nil
	}
	return *page.psrl.Value
}

// Creates a new instance of the PipelineStepRunListPage type.
func NewPipelineStepRunListPage(getNextPage func(context.Context, PipelineStepRunList) (PipelineStepRunList, error)) PipelineStepRunListPage {
	return PipelineStepRunListPage{fn: getNextPage}
}

// PipelineStepRunProperties pipeline step run property bag.
type PipelineStepRunProperties struct {
	// DurationMs - READ-ONLY; Duration of pipeline step
	DurationMs *int32 `json:"durationMs,omitempty"`
	// EndTime - READ-ONLY; End time of pipeline step
	EndTime *date.Time `json:"endTime,omitempty"`
	// ErrorMessage - READ-ONLY; Error message if any
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// PipelineStepID - READ-ONLY; The id of pipeline step.
	PipelineStepID *string `json:"pipelineStepId,omitempty"`
	// PipelineStepRunStatus - READ-ONLY; Pipeline step run status. Possible values include: 'PipelineStepRunStatusSucceeded', 'PipelineStepRunStatusFailed', 'PipelineStepRunStatusInProgress', 'PipelineStepRunStatusQueued', 'PipelineStepRunStatusCancelled', 'PipelineStepRunStatusCanceling'
	PipelineStepRunStatus PipelineStepRunStatus `json:"pipelineStepRunStatus,omitempty"`
	// StartTime - READ-ONLY; Start time of pipeline step
	StartTime *date.Time `json:"startTime,omitempty"`
}

// PipelineStepsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PipelineStepsDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *PipelineStepsDeleteFuture) Result(client PipelineStepsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.PipelineStepsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.PipelineStepsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.PipelineStepsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PoliciesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type PoliciesDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *PoliciesDeleteFuture) Result(client PoliciesClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.PoliciesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.PoliciesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.PoliciesDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BasicPolicy policy for entitlement
type BasicPolicy interface {
	AsDiagnosticPolicy() (*DiagnosticPolicy, bool)
	AsPolicy() (*Policy, bool)
}

// Policy policy for entitlement
type Policy struct {
	autorest.Response `json:"-"`
	// SystemData - SystemData Info of policy
	SystemData *SystemData `json:"systemData,omitempty"`
	// Kind - Possible values include: 'KindPolicy', 'KindDiagnosticLevel'
	Kind KindBasicPolicy `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

func unmarshalBasicPolicy(body []byte) (BasicPolicy, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindDiagnosticLevel):
		var dp DiagnosticPolicy
		err := json.Unmarshal(body, &dp)
		return dp, err
	default:
		var p Policy
		err := json.Unmarshal(body, &p)
		return p, err
	}
}
func unmarshalBasicPolicyArray(body []byte) ([]BasicPolicy, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	pArray := make([]BasicPolicy, len(rawMessages))

	for index, rawMessage := range rawMessages {
		p, err := unmarshalBasicPolicy(*rawMessage)
		if err != nil {
			return nil, err
		}
		pArray[index] = p
	}
	return pArray, nil
}

// MarshalJSON is the custom marshaler for Policy.
func (p Policy) MarshalJSON() ([]byte, error) {
	p.Kind = KindPolicy
	objectMap := make(map[string]interface{})
	if p.SystemData != nil {
		objectMap["systemData"] = p.SystemData
	}
	if p.Kind != "" {
		objectMap["kind"] = p.Kind
	}
	return json.Marshal(objectMap)
}

// AsDiagnosticPolicy is the BasicPolicy implementation for Policy.
func (p Policy) AsDiagnosticPolicy() (*DiagnosticPolicy, bool) {
	return nil, false
}

// AsPolicy is the BasicPolicy implementation for Policy.
func (p Policy) AsPolicy() (*Policy, bool) {
	return &p, true
}

// AsBasicPolicy is the BasicPolicy implementation for Policy.
func (p Policy) AsBasicPolicy() (BasicPolicy, bool) {
	return &p, true
}

// PolicyList list response for get Policies
type PolicyList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]BasicPolicy `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for PolicyList struct.
func (pl *PolicyList) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				pl.NextLink = &nextLink
			}
		case "value":
			if v != nil {
				value, err := unmarshalBasicPolicyArray(*v)
				if err != nil {
					return err
				}
				pl.Value = &value
			}
		}
	}

	return nil
}

// PolicyListIterator provides access to a complete listing of Policy values.
type PolicyListIterator struct {
	i    int
	page PolicyListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PolicyListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PolicyListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PolicyListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PolicyListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PolicyListIterator) Response() PolicyList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PolicyListIterator) Value() BasicPolicy {
	if !iter.page.NotDone() {
		return Policy{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PolicyListIterator type.
func NewPolicyListIterator(page PolicyListPage) PolicyListIterator {
	return PolicyListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pl PolicyList) IsEmpty() bool {
	return pl.Value == nil || len(*pl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pl PolicyList) hasNextLink() bool {
	return pl.NextLink != nil && len(*pl.NextLink) != 0
}

// policyListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pl PolicyList) policyListPreparer(ctx context.Context) (*http.Request, error) {
	if !pl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pl.NextLink)))
}

// PolicyListPage contains a page of BasicPolicy values.
type PolicyListPage struct {
	fn func(context.Context, PolicyList) (PolicyList, error)
	pl PolicyList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PolicyListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PolicyListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pl)
		if err != nil {
			return err
		}
		page.pl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PolicyListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PolicyListPage) NotDone() bool {
	return !page.pl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PolicyListPage) Response() PolicyList {
	return page.pl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PolicyListPage) Values() []BasicPolicy {
	if page.pl.IsEmpty() {
		return nil
	}
	return *page.pl.Value
}

// Creates a new instance of the PolicyListPage type.
func NewPolicyListPage(getNextPage func(context.Context, PolicyList) (PolicyList, error)) PolicyListPage {
	return PolicyListPage{fn: getNextPage}
}

// PolicyModel ...
type PolicyModel struct {
	autorest.Response `json:"-"`
	Value             BasicPolicy `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for PolicyModel struct.
func (pm *PolicyModel) UnmarshalJSON(body []byte) error {
	p, err := unmarshalBasicPolicy(body)
	if err != nil {
		return err
	}
	pm.Value = p

	return nil
}

// Proposal a proposal for data collaboration contract, can be shared and edited by multiple participants
// before signing.
type Proposal struct {
	autorest.Response `json:"-"`
	// ProposalProperties - Properties on the proposal
	*ProposalProperties `json:"properties,omitempty"`
	// SystemData - SystemData Info of Workspace
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Proposal.
func (p Proposal) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.ProposalProperties != nil {
		objectMap["properties"] = p.ProposalProperties
	}
	if p.SystemData != nil {
		objectMap["systemData"] = p.SystemData
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Proposal struct.
func (p *Proposal) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var proposalProperties ProposalProperties
				err = json.Unmarshal(*v, &proposalProperties)
				if err != nil {
					return err
				}
				p.ProposalProperties = &proposalProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				p.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				p.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				p.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				p.Type = &typeVar
			}
		}
	}

	return nil
}

// ProposalList list response for get proposals
type ProposalList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]Proposal `json:"value,omitempty"`
}

// ProposalListIterator provides access to a complete listing of Proposal values.
type ProposalListIterator struct {
	i    int
	page ProposalListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ProposalListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProposalListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ProposalListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ProposalListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ProposalListIterator) Response() ProposalList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ProposalListIterator) Value() Proposal {
	if !iter.page.NotDone() {
		return Proposal{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ProposalListIterator type.
func NewProposalListIterator(page ProposalListPage) ProposalListIterator {
	return ProposalListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pl ProposalList) IsEmpty() bool {
	return pl.Value == nil || len(*pl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pl ProposalList) hasNextLink() bool {
	return pl.NextLink != nil && len(*pl.NextLink) != 0
}

// proposalListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pl ProposalList) proposalListPreparer(ctx context.Context) (*http.Request, error) {
	if !pl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pl.NextLink)))
}

// ProposalListPage contains a page of Proposal values.
type ProposalListPage struct {
	fn func(context.Context, ProposalList) (ProposalList, error)
	pl ProposalList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ProposalListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProposalListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pl)
		if err != nil {
			return err
		}
		page.pl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ProposalListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ProposalListPage) NotDone() bool {
	return !page.pl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ProposalListPage) Response() ProposalList {
	return page.pl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ProposalListPage) Values() []Proposal {
	if page.pl.IsEmpty() {
		return nil
	}
	return *page.pl.Value
}

// Creates a new instance of the ProposalListPage type.
func NewProposalListPage(getNextPage func(context.Context, ProposalList) (ProposalList, error)) ProposalListPage {
	return ProposalListPage{fn: getNextPage}
}

// ProposalProperties properties of proposal data transfer object.
type ProposalProperties struct {
	// ContractStatus - READ-ONLY; Indicate if the contract is an editable Draft or a readonly Active contract. Possible values include: 'Draft', 'Active'
	ContractStatus ContractStatus `json:"contractStatus,omitempty"`
	// CurrentVersion - READ-ONLY; The proposal version, any change to the proposal or any of its underlying resources will result in a different value.
	CurrentVersion *string `json:"currentVersion,omitempty"`
	// CurrentVersionTimestamp - READ-ONLY; Timestamp of the last time the proposal or any of its underlying resources were updated.
	CurrentVersionTimestamp *date.Time `json:"currentVersionTimestamp,omitempty"`
	// Description - Textual description of the proposal
	Description *string `json:"description,omitempty"`
	// DisplayName - Display name of the proposal
	DisplayName *string `json:"displayName,omitempty"`
	// InvitationID - The invitation id for joining a proposal
	InvitationID *string `json:"invitationId,omitempty"`
	// InvitationLocation - The invitation id for joining a proposal
	InvitationLocation *string `json:"invitationLocation,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the proposal. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateMoving', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Terms - Terms of the proposal
	Terms *string `json:"terms,omitempty"`
}

// MarshalJSON is the custom marshaler for ProposalProperties.
func (pp ProposalProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pp.Description != nil {
		objectMap["description"] = pp.Description
	}
	if pp.DisplayName != nil {
		objectMap["displayName"] = pp.DisplayName
	}
	if pp.InvitationID != nil {
		objectMap["invitationId"] = pp.InvitationID
	}
	if pp.InvitationLocation != nil {
		objectMap["invitationLocation"] = pp.InvitationLocation
	}
	if pp.Terms != nil {
		objectMap["terms"] = pp.Terms
	}
	return json.Marshal(objectMap)
}

// ProposalsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ProposalsCreateOrUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ProposalsCreateOrUpdateFuture) Result(client ProposalsClient) (p Proposal, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ProposalsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ProposalsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if p.Response.Response, err = future.GetResult(sender); err == nil && p.Response.Response.StatusCode != http.StatusNoContent {
		p, err = client.CreateOrUpdateResponder(p.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ProposalsCreateOrUpdateFuture", "Result", p.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ProposalsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type ProposalsDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ProposalsDeleteFuture) Result(client ProposalsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ProposalsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ProposalsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ProposalsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ProposalSignature dto for Proposal Signing request
type ProposalSignature struct {
	// ProposalVersion - Proposal version to be signed
	ProposalVersion *string `json:"proposalVersion,omitempty"`
}

// ProposalsSignFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type ProposalsSignFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ProposalsSignFuture) Result(client ProposalsClient) (p Proposal, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ProposalsSignFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ProposalsSignFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if p.Response.Response, err = future.GetResult(sender); err == nil && p.Response.Response.StatusCode != http.StatusNoContent {
		p, err = client.SignResponder(p.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ProposalsSignFuture", "Result", p.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ProxyDto base data transfer object implementation for proxy resources.
type ProxyDto struct {
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// BasicScript a script data transfer object
type BasicScript interface {
	AsSynapseSparkScript() (*SynapseSparkScript, bool)
	AsScript() (*Script, bool)
}

// Script a script data transfer object
type Script struct {
	autorest.Response `json:"-"`
	// SystemData - SystemData Info of script
	SystemData *SystemData `json:"systemData,omitempty"`
	// Kind - Possible values include: 'KindBasicScriptKindScript', 'KindBasicScriptKindSynapseSpark'
	Kind KindBasicScript `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

func unmarshalBasicScript(body []byte) (BasicScript, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["kind"] {
	case string(KindBasicScriptKindSynapseSpark):
		var sss SynapseSparkScript
		err := json.Unmarshal(body, &sss)
		return sss, err
	default:
		var s Script
		err := json.Unmarshal(body, &s)
		return s, err
	}
}
func unmarshalBasicScriptArray(body []byte) ([]BasicScript, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	sArray := make([]BasicScript, len(rawMessages))

	for index, rawMessage := range rawMessages {
		s, err := unmarshalBasicScript(*rawMessage)
		if err != nil {
			return nil, err
		}
		sArray[index] = s
	}
	return sArray, nil
}

// MarshalJSON is the custom marshaler for Script.
func (s Script) MarshalJSON() ([]byte, error) {
	s.Kind = KindBasicScriptKindScript
	objectMap := make(map[string]interface{})
	if s.SystemData != nil {
		objectMap["systemData"] = s.SystemData
	}
	if s.Kind != "" {
		objectMap["kind"] = s.Kind
	}
	return json.Marshal(objectMap)
}

// AsSynapseSparkScript is the BasicScript implementation for Script.
func (s Script) AsSynapseSparkScript() (*SynapseSparkScript, bool) {
	return nil, false
}

// AsScript is the BasicScript implementation for Script.
func (s Script) AsScript() (*Script, bool) {
	return &s, true
}

// AsBasicScript is the BasicScript implementation for Script.
func (s Script) AsBasicScript() (BasicScript, bool) {
	return &s, true
}

// ScriptConstraint constraint used to only allow access if the resource is used with a specific script.
type ScriptConstraint struct {
	// ScriptConstraintProperties - Properties for script constraint
	*ScriptConstraintProperties `json:"properties,omitempty"`
	// SystemData - SystemData Info of script
	SystemData *SystemData `json:"systemData,omitempty"`
	// Kind - Possible values include: 'KindConstraint', 'KindLocation', 'KindScript'
	Kind Kind `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptConstraint.
func (sc ScriptConstraint) MarshalJSON() ([]byte, error) {
	sc.Kind = KindScript
	objectMap := make(map[string]interface{})
	if sc.ScriptConstraintProperties != nil {
		objectMap["properties"] = sc.ScriptConstraintProperties
	}
	if sc.SystemData != nil {
		objectMap["systemData"] = sc.SystemData
	}
	if sc.Kind != "" {
		objectMap["kind"] = sc.Kind
	}
	return json.Marshal(objectMap)
}

// AsLocationConstraint is the BasicConstraint implementation for ScriptConstraint.
func (sc ScriptConstraint) AsLocationConstraint() (*LocationConstraint, bool) {
	return nil, false
}

// AsScriptConstraint is the BasicConstraint implementation for ScriptConstraint.
func (sc ScriptConstraint) AsScriptConstraint() (*ScriptConstraint, bool) {
	return &sc, true
}

// AsConstraint is the BasicConstraint implementation for ScriptConstraint.
func (sc ScriptConstraint) AsConstraint() (*Constraint, bool) {
	return nil, false
}

// AsBasicConstraint is the BasicConstraint implementation for ScriptConstraint.
func (sc ScriptConstraint) AsBasicConstraint() (BasicConstraint, bool) {
	return &sc, true
}

// UnmarshalJSON is the custom unmarshaler for ScriptConstraint struct.
func (sc *ScriptConstraint) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var scriptConstraintProperties ScriptConstraintProperties
				err = json.Unmarshal(*v, &scriptConstraintProperties)
				if err != nil {
					return err
				}
				sc.ScriptConstraintProperties = &scriptConstraintProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sc.SystemData = &systemData
			}
		case "kind":
			if v != nil {
				var kind Kind
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sc.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sc.Type = &typeVar
			}
		}
	}

	return nil
}

// ScriptConstraintProperties properties for script constraint used to only allow access if the resource is
// used with a specific script.
type ScriptConstraintProperties struct {
	// Description - Description of the constraint.
	Description *string `json:"description,omitempty"`
	// ScriptReferenceID - The unique identifier of the script reference.
	ScriptReferenceID *string `json:"scriptReferenceId,omitempty"`
}

// ScriptDataAssetBinding binds a data asset reference to a script source or sink by key.
type ScriptDataAssetBinding struct {
	// DataAssetID - The bounded data asset Id
	DataAssetID *string `json:"dataAssetId,omitempty"`
	// Key - The key of script's source or sink
	Key *string `json:"key,omitempty"`
}

// ScriptList list response for get Scripts
type ScriptList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]BasicScript `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ScriptList struct.
func (sl *ScriptList) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "nextLink":
			if v != nil {
				var nextLink string
				err = json.Unmarshal(*v, &nextLink)
				if err != nil {
					return err
				}
				sl.NextLink = &nextLink
			}
		case "value":
			if v != nil {
				value, err := unmarshalBasicScriptArray(*v)
				if err != nil {
					return err
				}
				sl.Value = &value
			}
		}
	}

	return nil
}

// ScriptListIterator provides access to a complete listing of Script values.
type ScriptListIterator struct {
	i    int
	page ScriptListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ScriptListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ScriptListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ScriptListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ScriptListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ScriptListIterator) Response() ScriptList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ScriptListIterator) Value() BasicScript {
	if !iter.page.NotDone() {
		return Script{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ScriptListIterator type.
func NewScriptListIterator(page ScriptListPage) ScriptListIterator {
	return ScriptListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sl ScriptList) IsEmpty() bool {
	return sl.Value == nil || len(*sl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sl ScriptList) hasNextLink() bool {
	return sl.NextLink != nil && len(*sl.NextLink) != 0
}

// scriptListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sl ScriptList) scriptListPreparer(ctx context.Context) (*http.Request, error) {
	if !sl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sl.NextLink)))
}

// ScriptListPage contains a page of BasicScript values.
type ScriptListPage struct {
	fn func(context.Context, ScriptList) (ScriptList, error)
	sl ScriptList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ScriptListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ScriptListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sl)
		if err != nil {
			return err
		}
		page.sl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ScriptListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ScriptListPage) NotDone() bool {
	return !page.sl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ScriptListPage) Response() ScriptList {
	return page.sl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ScriptListPage) Values() []BasicScript {
	if page.sl.IsEmpty() {
		return nil
	}
	return *page.sl.Value
}

// Creates a new instance of the ScriptListPage type.
func NewScriptListPage(getNextPage func(context.Context, ScriptList) (ScriptList, error)) ScriptListPage {
	return ScriptListPage{fn: getNextPage}
}

// ScriptModel ...
type ScriptModel struct {
	autorest.Response `json:"-"`
	Value             BasicScript `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ScriptModel struct.
func (sm *ScriptModel) UnmarshalJSON(body []byte) error {
	s, err := unmarshalBasicScript(body)
	if err != nil {
		return err
	}
	sm.Value = s

	return nil
}

// ScriptReference script reference dto.
type ScriptReference struct {
	autorest.Response `json:"-"`
	// ScriptReferenceProperties - Properties on the script reference
	*ScriptReferenceProperties `json:"properties,omitempty"`
	// SystemData - SystemData Info of dataAssetReference
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptReference.
func (sr ScriptReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sr.ScriptReferenceProperties != nil {
		objectMap["properties"] = sr.ScriptReferenceProperties
	}
	if sr.SystemData != nil {
		objectMap["systemData"] = sr.SystemData
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ScriptReference struct.
func (sr *ScriptReference) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var scriptReferenceProperties ScriptReferenceProperties
				err = json.Unmarshal(*v, &scriptReferenceProperties)
				if err != nil {
					return err
				}
				sr.ScriptReferenceProperties = &scriptReferenceProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sr.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sr.Type = &typeVar
			}
		}
	}

	return nil
}

// ScriptReferenceList list response for get script references
type ScriptReferenceList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]ScriptReference `json:"value,omitempty"`
}

// ScriptReferenceListIterator provides access to a complete listing of ScriptReference values.
type ScriptReferenceListIterator struct {
	i    int
	page ScriptReferenceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ScriptReferenceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ScriptReferenceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ScriptReferenceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ScriptReferenceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ScriptReferenceListIterator) Response() ScriptReferenceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ScriptReferenceListIterator) Value() ScriptReference {
	if !iter.page.NotDone() {
		return ScriptReference{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ScriptReferenceListIterator type.
func NewScriptReferenceListIterator(page ScriptReferenceListPage) ScriptReferenceListIterator {
	return ScriptReferenceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (srl ScriptReferenceList) IsEmpty() bool {
	return srl.Value == nil || len(*srl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (srl ScriptReferenceList) hasNextLink() bool {
	return srl.NextLink != nil && len(*srl.NextLink) != 0
}

// scriptReferenceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (srl ScriptReferenceList) scriptReferenceListPreparer(ctx context.Context) (*http.Request, error) {
	if !srl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(srl.NextLink)))
}

// ScriptReferenceListPage contains a page of ScriptReference values.
type ScriptReferenceListPage struct {
	fn  func(context.Context, ScriptReferenceList) (ScriptReferenceList, error)
	srl ScriptReferenceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ScriptReferenceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ScriptReferenceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.srl)
		if err != nil {
			return err
		}
		page.srl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ScriptReferenceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ScriptReferenceListPage) NotDone() bool {
	return !page.srl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ScriptReferenceListPage) Response() ScriptReferenceList {
	return page.srl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ScriptReferenceListPage) Values() []ScriptReference {
	if page.srl.IsEmpty() {
		return nil
	}
	return *page.srl.Value
}

// Creates a new instance of the ScriptReferenceListPage type.
func NewScriptReferenceListPage(getNextPage func(context.Context, ScriptReferenceList) (ScriptReferenceList, error)) ScriptReferenceListPage {
	return ScriptReferenceListPage{fn: getNextPage}
}

// ScriptReferenceProperties properties of data set reference data transfer object.
type ScriptReferenceProperties struct {
	// OwnerID - READ-ONLY; The participant id of the script owner
	OwnerID *string `json:"ownerId,omitempty"`
	// Revision - The revision number of the script being referenced.
	// If omitted, the script latest version will be referenced.
	Revision *int32 `json:"revision,omitempty"`
	// ScriptID - The unique identifier of the referenced script
	ScriptID *string `json:"scriptId,omitempty"`
	// ScriptKind - READ-ONLY; Kind of the referenced script. Possible values include: 'SynapseSpark'
	ScriptKind ScriptKind `json:"scriptKind,omitempty"`
	// ScriptReferenceID - READ-ONLY; Unique id for identifying a script reference resource
	ScriptReferenceID *string `json:"scriptReferenceId,omitempty"`
	// ScriptVisibility - READ-ONLY; The referenced script visibility modifier. Possible values include: 'ShowAll', 'HiddenContent'
	ScriptVisibility ScriptVisibility `json:"scriptVisibility,omitempty"`
	// Sinks - READ-ONLY; The list of parameters the script can use as it's data sinks
	Sinks *[]string `json:"sinks,omitempty"`
	// Sources - READ-ONLY; The list of parameters the script can use as it's data sources
	Sources *[]string `json:"sources,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptReferenceProperties.
func (srp ScriptReferenceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if srp.Revision != nil {
		objectMap["revision"] = srp.Revision
	}
	if srp.ScriptID != nil {
		objectMap["scriptId"] = srp.ScriptID
	}
	return json.Marshal(objectMap)
}

// ScriptReferencesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ScriptReferencesDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ScriptReferencesDeleteFuture) Result(client ScriptReferencesClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ScriptReferencesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ScriptReferencesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ScriptReferencesDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ScriptsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type ScriptsDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ScriptsDeleteFuture) Result(client ScriptsClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ScriptsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.ScriptsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.ScriptsDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SynapseSparkPipelineStep a Synapse Spark based pipeline step.
type SynapseSparkPipelineStep struct {
	// SynapseSparkPipelineStepProperties - Properties of Synapse Spark pipelineStep
	*SynapseSparkPipelineStepProperties `json:"properties,omitempty"`
	// Kind - Possible values include: 'KindPipelineStep', 'KindSynapseSpark'
	Kind KindBasicPipelineStep `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SynapseSparkPipelineStep.
func (ssps SynapseSparkPipelineStep) MarshalJSON() ([]byte, error) {
	ssps.Kind = KindSynapseSpark
	objectMap := make(map[string]interface{})
	if ssps.SynapseSparkPipelineStepProperties != nil {
		objectMap["properties"] = ssps.SynapseSparkPipelineStepProperties
	}
	if ssps.Kind != "" {
		objectMap["kind"] = ssps.Kind
	}
	return json.Marshal(objectMap)
}

// AsSynapseSparkPipelineStep is the BasicPipelineStep implementation for SynapseSparkPipelineStep.
func (ssps SynapseSparkPipelineStep) AsSynapseSparkPipelineStep() (*SynapseSparkPipelineStep, bool) {
	return &ssps, true
}

// AsPipelineStep is the BasicPipelineStep implementation for SynapseSparkPipelineStep.
func (ssps SynapseSparkPipelineStep) AsPipelineStep() (*PipelineStep, bool) {
	return nil, false
}

// AsBasicPipelineStep is the BasicPipelineStep implementation for SynapseSparkPipelineStep.
func (ssps SynapseSparkPipelineStep) AsBasicPipelineStep() (BasicPipelineStep, bool) {
	return &ssps, true
}

// UnmarshalJSON is the custom unmarshaler for SynapseSparkPipelineStep struct.
func (ssps *SynapseSparkPipelineStep) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var synapseSparkPipelineStepProperties SynapseSparkPipelineStepProperties
				err = json.Unmarshal(*v, &synapseSparkPipelineStepProperties)
				if err != nil {
					return err
				}
				ssps.SynapseSparkPipelineStepProperties = &synapseSparkPipelineStepProperties
			}
		case "kind":
			if v != nil {
				var kind KindBasicPipelineStep
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ssps.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssps.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssps.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssps.Type = &typeVar
			}
		}
	}

	return nil
}

// SynapseSparkPipelineStepProperties a Synapse Spark PipelineStep data transfer object.
type SynapseSparkPipelineStepProperties struct {
	// ClusterSize - Defines the cluster size for running a SynapseSpark pipeline step
	ClusterSize *int32 `json:"clusterSize,omitempty"`
	// Dependencies - List of other steps names, in the same pipeline, which this step is depended on
	// and should run only when they finish.
	Dependencies *[]string `json:"dependencies,omitempty"`
	// ScriptID - The script Id that the pipeline step should execute
	ScriptID *string `json:"scriptId,omitempty"`
	// ScriptRevision - The script's revision that the pipeline step should execute
	ScriptRevision *int32 `json:"scriptRevision,omitempty"`
	// ScriptSinkBindings - Bindings between the script's sink keys and data assets
	ScriptSinkBindings *[]ScriptDataAssetBinding `json:"scriptSinkBindings,omitempty"`
	// ScriptSourceBindings - Bindings between the script's source keys and data assets
	ScriptSourceBindings *[]ScriptDataAssetBinding `json:"scriptSourceBindings,omitempty"`
}

// SynapseSparkScript a type of script based on the compute engine
type SynapseSparkScript struct {
	// SynapseSparkScriptProperties - Properties of Synapse Spark script
	*SynapseSparkScriptProperties `json:"properties,omitempty"`
	// SystemData - SystemData Info of script
	SystemData *SystemData `json:"systemData,omitempty"`
	// Kind - Possible values include: 'KindBasicScriptKindScript', 'KindBasicScriptKindSynapseSpark'
	Kind KindBasicScript `json:"kind,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SynapseSparkScript.
func (sss SynapseSparkScript) MarshalJSON() ([]byte, error) {
	sss.Kind = KindBasicScriptKindSynapseSpark
	objectMap := make(map[string]interface{})
	if sss.SynapseSparkScriptProperties != nil {
		objectMap["properties"] = sss.SynapseSparkScriptProperties
	}
	if sss.SystemData != nil {
		objectMap["systemData"] = sss.SystemData
	}
	if sss.Kind != "" {
		objectMap["kind"] = sss.Kind
	}
	return json.Marshal(objectMap)
}

// AsSynapseSparkScript is the BasicScript implementation for SynapseSparkScript.
func (sss SynapseSparkScript) AsSynapseSparkScript() (*SynapseSparkScript, bool) {
	return &sss, true
}

// AsScript is the BasicScript implementation for SynapseSparkScript.
func (sss SynapseSparkScript) AsScript() (*Script, bool) {
	return nil, false
}

// AsBasicScript is the BasicScript implementation for SynapseSparkScript.
func (sss SynapseSparkScript) AsBasicScript() (BasicScript, bool) {
	return &sss, true
}

// UnmarshalJSON is the custom unmarshaler for SynapseSparkScript struct.
func (sss *SynapseSparkScript) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var synapseSparkScriptProperties SynapseSparkScriptProperties
				err = json.Unmarshal(*v, &synapseSparkScriptProperties)
				if err != nil {
					return err
				}
				sss.SynapseSparkScriptProperties = &synapseSparkScriptProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sss.SystemData = &systemData
			}
		case "kind":
			if v != nil {
				var kind KindBasicScript
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				sss.Kind = kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sss.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sss.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sss.Type = &typeVar
			}
		}
	}

	return nil
}

// SynapseSparkScriptProperties a Synapse Spark Script data transfer object.
type SynapseSparkScriptProperties struct {
	// Content - The script content
	Content *string `json:"content,omitempty"`
	// Language - The script language
	Language *string `json:"language,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the script. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateMoving', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Revision - READ-ONLY; Latest script revision
	Revision *int32 `json:"revision,omitempty"`
	// ScriptID - READ-ONLY; Unique id for identifying a script resource
	ScriptID *string `json:"scriptId,omitempty"`
	// Sinks - The list of parameters the script can use as it's data sinks
	Sinks *[]string `json:"sinks,omitempty"`
	// Sources - The list of parameters the script can use as it's data sources
	Sources *[]string `json:"sources,omitempty"`
	// Visibility - Script visibility mode. Possible values include: 'VisibilityShowAll', 'VisibilityHiddenContent'
	Visibility Visibility `json:"visibility,omitempty"`
}

// MarshalJSON is the custom marshaler for SynapseSparkScriptProperties.
func (sssp SynapseSparkScriptProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sssp.Content != nil {
		objectMap["content"] = sssp.Content
	}
	if sssp.Language != nil {
		objectMap["language"] = sssp.Language
	}
	if sssp.Sinks != nil {
		objectMap["sinks"] = sssp.Sinks
	}
	if sssp.Sources != nil {
		objectMap["sources"] = sssp.Sources
	}
	if sssp.Visibility != "" {
		objectMap["visibility"] = sssp.Visibility
	}
	return json.Marshal(objectMap)
}

// SystemData systemData of resource
type SystemData struct {
	// CreatedAt - READ-ONLY; The timestamp of resource creation (UTC).
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// CreatedBy - READ-ONLY; A string identifier for the identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - READ-ONLY; The type of identity that created the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	CreatedByType CreatedByType `json:"createdByType,omitempty"`
	// LastModifiedAt - READ-ONLY; The timestamp of resource last modification (UTC).
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
	// LastModifiedBy - READ-ONLY; A string identifier for the identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - READ-ONLY; The type of identity that last modified the resource. Possible values include: 'LastModifiedByTypeUser', 'LastModifiedByTypeApplication', 'LastModifiedByTypeManagedIdentity', 'LastModifiedByTypeKey'
	LastModifiedByType LastModifiedByType `json:"lastModifiedByType,omitempty"`
}

// Workspace workspace to hold data collaboration workloads.
type Workspace struct {
	autorest.Response `json:"-"`
	// Identity - Identity Info on the Workspace
	Identity *Identity `json:"identity,omitempty"`
	// WorkspaceProperties - Properties on the workspace
	*WorkspaceProperties `json:"properties,omitempty"`
	// SystemData - SystemData Info of Workspace
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; The resource id of the azure resource
	ID *string `json:"id,omitempty"`
	// Location - Location of the azure resource.
	Location *string `json:"location,omitempty"`
	// Name - READ-ONLY; Name of the azure resource
	Name *string `json:"name,omitempty"`
	// Tags - Tags on the azure resource.
	Tags map[string]*string `json:"tags"`
	// Type - READ-ONLY; Type of the azure resource
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Workspace.
func (w Workspace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if w.Identity != nil {
		objectMap["identity"] = w.Identity
	}
	if w.WorkspaceProperties != nil {
		objectMap["properties"] = w.WorkspaceProperties
	}
	if w.SystemData != nil {
		objectMap["systemData"] = w.SystemData
	}
	if w.Location != nil {
		objectMap["location"] = w.Location
	}
	if w.Tags != nil {
		objectMap["tags"] = w.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Workspace struct.
func (w *Workspace) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "identity":
			if v != nil {
				var identity Identity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				w.Identity = &identity
			}
		case "properties":
			if v != nil {
				var workspaceProperties WorkspaceProperties
				err = json.Unmarshal(*v, &workspaceProperties)
				if err != nil {
					return err
				}
				w.WorkspaceProperties = &workspaceProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				w.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				w.ID = &ID
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				w.Location = &location
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				w.Name = &name
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				w.Tags = tags
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				w.Type = &typeVar
			}
		}
	}

	return nil
}

// WorkspaceList list response for get Workspaces.
type WorkspaceList struct {
	autorest.Response `json:"-"`
	// NextLink - The Url of next result page.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Collection of items of type DataTransferObjects.
	Value *[]Workspace `json:"value,omitempty"`
}

// WorkspaceListIterator provides access to a complete listing of Workspace values.
type WorkspaceListIterator struct {
	i    int
	page WorkspaceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WorkspaceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkspaceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WorkspaceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WorkspaceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WorkspaceListIterator) Response() WorkspaceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WorkspaceListIterator) Value() Workspace {
	if !iter.page.NotDone() {
		return Workspace{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WorkspaceListIterator type.
func NewWorkspaceListIterator(page WorkspaceListPage) WorkspaceListIterator {
	return WorkspaceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wl WorkspaceList) IsEmpty() bool {
	return wl.Value == nil || len(*wl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wl WorkspaceList) hasNextLink() bool {
	return wl.NextLink != nil && len(*wl.NextLink) != 0
}

// workspaceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wl WorkspaceList) workspaceListPreparer(ctx context.Context) (*http.Request, error) {
	if !wl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wl.NextLink)))
}

// WorkspaceListPage contains a page of Workspace values.
type WorkspaceListPage struct {
	fn func(context.Context, WorkspaceList) (WorkspaceList, error)
	wl WorkspaceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WorkspaceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkspaceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wl)
		if err != nil {
			return err
		}
		page.wl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WorkspaceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WorkspaceListPage) NotDone() bool {
	return !page.wl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WorkspaceListPage) Response() WorkspaceList {
	return page.wl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WorkspaceListPage) Values() []Workspace {
	if page.wl.IsEmpty() {
		return nil
	}
	return *page.wl.Value
}

// Creates a new instance of the WorkspaceListPage type.
func NewWorkspaceListPage(getNextPage func(context.Context, WorkspaceList) (WorkspaceList, error)) WorkspaceListPage {
	return WorkspaceListPage{fn: getNextPage}
}

// WorkspaceProperties workspace property bag.
type WorkspaceProperties struct {
	// ProvisioningState - READ-ONLY; Provisioning state of the Workspace. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateCreating', 'ProvisioningStateUpdating', 'ProvisioningStateDeleting', 'ProvisioningStateMoving', 'ProvisioningStateFailed'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// UserEmail - READ-ONLY; Email of the user who created the resource
	UserEmail *string `json:"userEmail,omitempty"`
	// UserName - READ-ONLY; Name of the user who created the resource
	UserName *string `json:"userName,omitempty"`
}

// WorkspacesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type WorkspacesCreateOrUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *WorkspacesCreateOrUpdateFuture) Result(client WorkspacesClient) (w Workspace, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.WorkspacesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.WorkspacesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if w.Response.Response, err = future.GetResult(sender); err == nil && w.Response.Response.StatusCode != http.StatusNoContent {
		w, err = client.CreateOrUpdateResponder(w.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.WorkspacesCreateOrUpdateFuture", "Result", w.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WorkspacesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type WorkspacesDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *WorkspacesDeleteFuture) Result(client WorkspacesClient) (or OperationResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.WorkspacesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("datacollaboration.WorkspacesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.DeleteResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "datacollaboration.WorkspacesDeleteFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WorkspaceUpdateParameters update parameters for workspaces
type WorkspaceUpdateParameters struct {
	// Tags - Tags on the azure resource.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for WorkspaceUpdateParameters.
func (wup WorkspaceUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wup.Tags != nil {
		objectMap["tags"] = wup.Tags
	}
	return json.Marshal(objectMap)
}
