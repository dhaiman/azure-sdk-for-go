package datacollaboration

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// ConstraintsClient is the creates a Microsoft.DataCollaboration management client.
type ConstraintsClient struct {
	BaseClient
}

// NewConstraintsClient creates an instance of the ConstraintsClient client.
func NewConstraintsClient(subscriptionID string) ConstraintsClient {
	return NewConstraintsClientWithBaseURI(DefaultBaseURI, subscriptionID)
}

// NewConstraintsClientWithBaseURI creates an instance of the ConstraintsClient client using a custom endpoint.  Use
// this when interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
func NewConstraintsClientWithBaseURI(baseURI string, subscriptionID string) ConstraintsClient {
	return ConstraintsClient{NewWithBaseURI(baseURI, subscriptionID)}
}

// CreateOrUpdate create or update a constraint in an entitlement
// Parameters:
// resourceGroupName - the resource group name.
// workspaceName - the name of the workspace.
// proposalName - the name of the proposal.
// entitlementName - the name of the entitlement.
// constraintName - the name of the constraint.
// constraint - the new constraint information.
func (client ConstraintsClient) CreateOrUpdate(ctx context.Context, resourceGroupName string, workspaceName string, proposalName string, entitlementName string, constraintName string, constraint BasicConstraint) (result ConstraintModel, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConstraintsClient.CreateOrUpdate")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CreateOrUpdatePreparer(ctx, resourceGroupName, workspaceName, proposalName, entitlementName, constraintName, constraint)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsClient", "CreateOrUpdate", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsClient", "CreateOrUpdate", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsClient", "CreateOrUpdate", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdatePreparer prepares the CreateOrUpdate request.
func (client ConstraintsClient) CreateOrUpdatePreparer(ctx context.Context, resourceGroupName string, workspaceName string, proposalName string, entitlementName string, constraintName string, constraint BasicConstraint) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"constraintName":    autorest.Encode("path", constraintName),
		"entitlementName":   autorest.Encode("path", entitlementName),
		"proposalName":      autorest.Encode("path", proposalName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	const APIVersion = "2020-05-04-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataCollaboration/workspaces/{workspaceName}/proposals/{proposalName}/entitlements/{entitlementName}/constraints/{constraintName}", pathParameters),
		autorest.WithJSON(constraint),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateSender sends the CreateOrUpdate request. The method will close the
// http.Response Body if it receives an error.
func (client ConstraintsClient) CreateOrUpdateSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateResponder handles the response to the CreateOrUpdate request. The method always
// closes the http.Response Body.
func (client ConstraintsClient) CreateOrUpdateResponder(resp *http.Response) (result ConstraintModel, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Delete delete a constraint from an entitlement
// Parameters:
// resourceGroupName - the resource group name.
// workspaceName - the name of the workspace.
// proposalName - the name of the proposal.
// entitlementName - the name of the entitlement.
// constraintName - the name of the constraint.
func (client ConstraintsClient) Delete(ctx context.Context, resourceGroupName string, workspaceName string, proposalName string, entitlementName string, constraintName string) (result ConstraintsDeleteFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConstraintsClient.Delete")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeletePreparer(ctx, resourceGroupName, workspaceName, proposalName, entitlementName, constraintName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsClient", "Delete", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsClient", "Delete", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeletePreparer prepares the Delete request.
func (client ConstraintsClient) DeletePreparer(ctx context.Context, resourceGroupName string, workspaceName string, proposalName string, entitlementName string, constraintName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"constraintName":    autorest.Encode("path", constraintName),
		"entitlementName":   autorest.Encode("path", entitlementName),
		"proposalName":      autorest.Encode("path", proposalName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	const APIVersion = "2020-05-04-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataCollaboration/workspaces/{workspaceName}/proposals/{proposalName}/entitlements/{entitlementName}/constraints/{constraintName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteSender sends the Delete request. The method will close the
// http.Response Body if it receives an error.
func (client ConstraintsClient) DeleteSender(req *http.Request) (future ConstraintsDeleteFuture, err error) {
	var resp *http.Response
	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// DeleteResponder handles the response to the Delete request. The method always
// closes the http.Response Body.
func (client ConstraintsClient) DeleteResponder(resp *http.Response) (result OperationResponse, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Get get a constraint from an entitlement
// Parameters:
// resourceGroupName - the resource group name.
// workspaceName - the name of the workspace.
// proposalName - the name of the proposal.
// entitlementName - the name of the entitlement.
// constraintName - the name of the constraint.
func (client ConstraintsClient) Get(ctx context.Context, resourceGroupName string, workspaceName string, proposalName string, entitlementName string, constraintName string) (result ConstraintModel, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConstraintsClient.Get")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetPreparer(ctx, resourceGroupName, workspaceName, proposalName, entitlementName, constraintName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsClient", "Get", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsClient", "Get", resp, "Failure sending request")
		return
	}

	result, err = client.GetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsClient", "Get", resp, "Failure responding to request")
	}

	return
}

// GetPreparer prepares the Get request.
func (client ConstraintsClient) GetPreparer(ctx context.Context, resourceGroupName string, workspaceName string, proposalName string, entitlementName string, constraintName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"constraintName":    autorest.Encode("path", constraintName),
		"entitlementName":   autorest.Encode("path", entitlementName),
		"proposalName":      autorest.Encode("path", proposalName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	const APIVersion = "2020-05-04-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataCollaboration/workspaces/{workspaceName}/proposals/{proposalName}/entitlements/{entitlementName}/constraints/{constraintName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSender sends the Get request. The method will close the
// http.Response Body if it receives an error.
func (client ConstraintsClient) GetSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// GetResponder handles the response to the Get request. The method always
// closes the http.Response Body.
func (client ConstraintsClient) GetResponder(resp *http.Response) (result ConstraintModel, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListByEntitlement list constraints in an entitlement
// Parameters:
// resourceGroupName - the resource group name.
// workspaceName - the name of the workspace.
// proposalName - the name of the proposal.
// entitlementName - the name of the entitlement.
// skipToken - continuation token
// filter - filters the results using OData syntax.
// orderby - sorts the results using OData syntax.
func (client ConstraintsClient) ListByEntitlement(ctx context.Context, resourceGroupName string, workspaceName string, proposalName string, entitlementName string, skipToken string, filter string, orderby string) (result ConstraintListPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConstraintsClient.ListByEntitlement")
		defer func() {
			sc := -1
			if result.cl.Response.Response != nil {
				sc = result.cl.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.listByEntitlementNextResults
	req, err := client.ListByEntitlementPreparer(ctx, resourceGroupName, workspaceName, proposalName, entitlementName, skipToken, filter, orderby)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsClient", "ListByEntitlement", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListByEntitlementSender(req)
	if err != nil {
		result.cl.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsClient", "ListByEntitlement", resp, "Failure sending request")
		return
	}

	result.cl, err = client.ListByEntitlementResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsClient", "ListByEntitlement", resp, "Failure responding to request")
	}
	if result.cl.hasNextLink() && result.cl.IsEmpty() {
		err = result.NextWithContext(ctx)
	}

	return
}

// ListByEntitlementPreparer prepares the ListByEntitlement request.
func (client ConstraintsClient) ListByEntitlementPreparer(ctx context.Context, resourceGroupName string, workspaceName string, proposalName string, entitlementName string, skipToken string, filter string, orderby string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"entitlementName":   autorest.Encode("path", entitlementName),
		"proposalName":      autorest.Encode("path", proposalName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"workspaceName":     autorest.Encode("path", workspaceName),
	}

	const APIVersion = "2020-05-04-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(skipToken) > 0 {
		queryParameters["$skipToken"] = autorest.Encode("query", skipToken)
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataCollaboration/workspaces/{workspaceName}/proposals/{proposalName}/entitlements/{entitlementName}/constraints", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListByEntitlementSender sends the ListByEntitlement request. The method will close the
// http.Response Body if it receives an error.
func (client ConstraintsClient) ListByEntitlementSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// ListByEntitlementResponder handles the response to the ListByEntitlement request. The method always
// closes the http.Response Body.
func (client ConstraintsClient) ListByEntitlementResponder(resp *http.Response) (result ConstraintList, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listByEntitlementNextResults retrieves the next set of results, if any.
func (client ConstraintsClient) listByEntitlementNextResults(ctx context.Context, lastResults ConstraintList) (result ConstraintList, err error) {
	req, err := lastResults.constraintListPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "datacollaboration.ConstraintsClient", "listByEntitlementNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListByEntitlementSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "datacollaboration.ConstraintsClient", "listByEntitlementNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListByEntitlementResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "datacollaboration.ConstraintsClient", "listByEntitlementNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListByEntitlementComplete enumerates all values, automatically crossing page boundaries as required.
func (client ConstraintsClient) ListByEntitlementComplete(ctx context.Context, resourceGroupName string, workspaceName string, proposalName string, entitlementName string, skipToken string, filter string, orderby string) (result ConstraintListIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConstraintsClient.ListByEntitlement")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListByEntitlement(ctx, resourceGroupName, workspaceName, proposalName, entitlementName, skipToken, filter, orderby)
	return
}
