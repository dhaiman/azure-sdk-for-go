package quantum

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/quantum/mgmt/2019-11-04-preview/quantum"

// ErrorDefinition error definition.
type ErrorDefinition struct {
	// Code - READ-ONLY; Service specific error code which serves as the substatus for the HTTP error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Description of the error.
	Message *string `json:"message,omitempty"`
	// Details - READ-ONLY; Internal error details.
	Details *[]ErrorDefinition `json:"details,omitempty"`
}

// ErrorResponse error response.
type ErrorResponse struct {
	// Error - The error details.
	Error *ErrorDefinition `json:"error,omitempty"`
}

// Operation operation provided by provider
type Operation struct {
	// Name - Name of the operation
	Name *string `json:"name,omitempty"`
	// Display - Properties of the operation
	Display *OperationDisplay `json:"display,omitempty"`
}

// OperationDisplay properties of the operation
type OperationDisplay struct {
	// Provider - Provider name
	Provider *string `json:"provider,omitempty"`
	// Resource - Resource name
	Resource *string `json:"resource,omitempty"`
	// Operation - Operation name
	Operation *string `json:"operation,omitempty"`
	// Description - Description of the operation
	Description *string `json:"description,omitempty"`
}

// OperationsList lists the operations available.
type OperationsList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of operations.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of operations
	Value *[]Operation `json:"value,omitempty"`
}

// OperationsListIterator provides access to a complete listing of Operation values.
type OperationsListIterator struct {
	i    int
	page OperationsListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationsListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationsListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationsListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationsListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationsListIterator) Response() OperationsList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationsListIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationsListIterator type.
func NewOperationsListIterator(page OperationsListPage) OperationsListIterator {
	return OperationsListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ol OperationsList) IsEmpty() bool {
	return ol.Value == nil || len(*ol.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ol OperationsList) hasNextLink() bool {
	return ol.NextLink != nil && len(*ol.NextLink) != 0
}

// operationsListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ol OperationsList) operationsListPreparer(ctx context.Context) (*http.Request, error) {
	if !ol.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ol.NextLink)))
}

// OperationsListPage contains a page of Operation values.
type OperationsListPage struct {
	fn func(context.Context, OperationsList) (OperationsList, error)
	ol OperationsList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationsListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationsListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ol)
		if err != nil {
			return err
		}
		page.ol = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationsListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationsListPage) NotDone() bool {
	return !page.ol.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationsListPage) Response() OperationsList {
	return page.ol
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationsListPage) Values() []Operation {
	if page.ol.IsEmpty() {
		return nil
	}
	return *page.ol.Value
}

// Creates a new instance of the OperationsListPage type.
func NewOperationsListPage(getNextPage func(context.Context, OperationsList) (OperationsList, error)) OperationsListPage {
	return OperationsListPage{fn: getNextPage}
}

// PricingDetail descript pricing detail information to end customer.
type PricingDetail struct {
	// ID - id of the pricing dimension
	ID *string `json:"id,omitempty"`
	// Value - value of the pricing dimension
	Value *string `json:"value,omitempty"`
}

// PricingDimension descript pricing dimension information to end customer.
type PricingDimension struct {
	// ID - id of the pricing dimension
	ID *string `json:"id,omitempty"`
	// Name - name of the pricing dimension
	Name *string `json:"name,omitempty"`
}

// Provider json representation of provider, used for json serialization and deserialization and save the meta
// information
// of provider (including both first party and 3rd party.
type Provider struct {
	// ProviderID - partner id field
	ProviderID *string `json:"providerId,omitempty"`
	// ProviderSku - sku field
	ProviderSku *string `json:"providerSku,omitempty"`
	// InstanceURI - serviceUri field
	InstanceURI *string `json:"instanceUri,omitempty"`
	// ApplicationName - application name field
	ApplicationName *string `json:"applicationName,omitempty"`
	// ProvisioningState - Provisioning status field. Possible values include: 'StatusSucceeded', 'StatusLaunching', 'StatusUpdating', 'StatusDeleting', 'StatusDeleted', 'StatusFailed'
	ProvisioningState Status `json:"provisioningState,omitempty"`
	// ResourceUsageID - Id to track resource usage for the provider.
	ResourceUsageID *string `json:"resourceUsageId,omitempty"`
}

// ProviderDescription descript provider's information to end customer.
type ProviderDescription struct {
	// ID - unique provider id
	ID *string `json:"id,omitempty"`
	// Name - display name of provider
	Name *string `json:"name,omitempty"`
	// Properties - provider properties
	Properties *ProviderDescriptionProperties `json:"properties,omitempty"`
}

// ProviderDescriptionProperties provider properties
type ProviderDescriptionProperties struct {
	// Description - Description about this provider
	Description *string `json:"description,omitempty"`
	// ProviderType - Provider type.
	ProviderType *string `json:"providerType,omitempty"`
	// Company - Company name.
	Company *string `json:"company,omitempty"`
	// DefaultEndpoint - Provider's default endpoint
	DefaultEndpoint *string `json:"defaultEndpoint,omitempty"`
	// Aad - Azure Acitve Directory info
	Aad *ProviderPropertiesAad `json:"aad,omitempty"`
	// ManagedApplication - Managed application info
	ManagedApplication *ProviderPropertiesManagedApplication `json:"managedApplication,omitempty"`
	// Targets - list of targets from the provider
	Targets *[]TargetDescription `json:"targets,omitempty"`
	// Skus - list of skus from the provider
	Skus *[]SkuDescription `json:"skus,omitempty"`
	// QuotaDimensions - list of quota dimensions from the provider
	QuotaDimensions *[]QuotaDimension `json:"quotaDimensions,omitempty"`
	// PricingDimensions - list of pricing dimensions rendered for each sku
	PricingDimensions *[]PricingDimension `json:"pricingDimensions,omitempty"`
}

// ProviderListResult the response of the List Providers operation.
type ProviderListResult struct {
	autorest.Response `json:"-"`
	// Value - Result of the List Providers operation.
	Value *[]ProviderDescription `json:"value,omitempty"`
	// NextLink - Link to the next set of results. Not empty if Value contains incomplete list of Namespaces.
	NextLink *string `json:"nextLink,omitempty"`
}

// ProviderListResultIterator provides access to a complete listing of ProviderDescription values.
type ProviderListResultIterator struct {
	i    int
	page ProviderListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ProviderListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProviderListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ProviderListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ProviderListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ProviderListResultIterator) Response() ProviderListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ProviderListResultIterator) Value() ProviderDescription {
	if !iter.page.NotDone() {
		return ProviderDescription{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ProviderListResultIterator type.
func NewProviderListResultIterator(page ProviderListResultPage) ProviderListResultIterator {
	return ProviderListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (plr ProviderListResult) IsEmpty() bool {
	return plr.Value == nil || len(*plr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (plr ProviderListResult) hasNextLink() bool {
	return plr.NextLink != nil && len(*plr.NextLink) != 0
}

// providerListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (plr ProviderListResult) providerListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !plr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(plr.NextLink)))
}

// ProviderListResultPage contains a page of ProviderDescription values.
type ProviderListResultPage struct {
	fn  func(context.Context, ProviderListResult) (ProviderListResult, error)
	plr ProviderListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ProviderListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProviderListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.plr)
		if err != nil {
			return err
		}
		page.plr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ProviderListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ProviderListResultPage) NotDone() bool {
	return !page.plr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ProviderListResultPage) Response() ProviderListResult {
	return page.plr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ProviderListResultPage) Values() []ProviderDescription {
	if page.plr.IsEmpty() {
		return nil
	}
	return *page.plr.Value
}

// Creates a new instance of the ProviderListResultPage type.
func NewProviderListResultPage(getNextPage func(context.Context, ProviderListResult) (ProviderListResult, error)) ProviderListResultPage {
	return ProviderListResultPage{fn: getNextPage}
}

// ProviderProperties provider properties.
type ProviderProperties struct {
	// Description - Description about this provider
	Description *string `json:"description,omitempty"`
	// ProviderType - Provider type.
	ProviderType *string `json:"providerType,omitempty"`
	// Company - Company name.
	Company *string `json:"company,omitempty"`
	// DefaultEndpoint - Provider's default endpoint
	DefaultEndpoint *string `json:"defaultEndpoint,omitempty"`
	// Aad - Azure Acitve Directory info
	Aad *ProviderPropertiesAad `json:"aad,omitempty"`
	// ManagedApplication - Managed application info
	ManagedApplication *ProviderPropertiesManagedApplication `json:"managedApplication,omitempty"`
	// Targets - list of targets from the provider
	Targets *[]TargetDescription `json:"targets,omitempty"`
	// Skus - list of skus from the provider
	Skus *[]SkuDescription `json:"skus,omitempty"`
	// QuotaDimensions - list of quota dimensions from the provider
	QuotaDimensions *[]QuotaDimension `json:"quotaDimensions,omitempty"`
	// PricingDimensions - list of pricing dimensions rendered for each sku
	PricingDimensions *[]PricingDimension `json:"pricingDimensions,omitempty"`
}

// ProviderPropertiesAad azure Acitve Directory info
type ProviderPropertiesAad struct {
	// ApplicationID - Provider's application id
	ApplicationID *string `json:"applicationId,omitempty"`
	// TenantID - Provider's tenant id
	TenantID *string `json:"tenantId,omitempty"`
}

// ProviderPropertiesManagedApplication managed application info
type ProviderPropertiesManagedApplication struct {
	// PublisherID - Provider's publisher id
	PublisherID *string `json:"publisherId,omitempty"`
	// OfferID - Provider's offer id
	OfferID *string `json:"offerId,omitempty"`
}

// QuotaDimension descript quota dimension information to end customer.
type QuotaDimension struct {
	// ID - dimension id of quota
	ID *string `json:"id,omitempty"`
	// Scope - scope of quota
	Scope *string `json:"scope,omitempty"`
	// Period - reset period of quota
	Period *string `json:"period,omitempty"`
	// Quota - limit of quota
	Quota *float64 `json:"quota,omitempty"`
	// Name - friendly name of the quota
	Name *string `json:"name,omitempty"`
	// Description - short description of the quota
	Description *string `json:"description,omitempty"`
	// Unit - the standard measurement used for the quota
	Unit *string `json:"unit,omitempty"`
	// UnitPlural - unit in the plural form
	UnitPlural *string `json:"unitPlural,omitempty"`
}

// SkuDescription descript provider's information to end customer.
type SkuDescription struct {
	// ID - unique sku id
	ID *string `json:"id,omitempty"`
	// Name - display name of sku
	Name *string `json:"name,omitempty"`
	// Description - Description about this sku
	Description *string `json:"description,omitempty"`
	// Targets - list of targets for the sku
	Targets *[]string `json:"targets,omitempty"`
	// QuotaDimensions - list of quota dimensions for the sku
	QuotaDimensions *[]QuotaDimension `json:"quotaDimensions,omitempty"`
	// PricingDetails - list of pricing details for the sku
	PricingDetails *[]PricingDetail `json:"pricingDetails,omitempty"`
}

// TargetDescription descript provider's target information to end customer.
type TargetDescription struct {
	// ID - unique target id
	ID *string `json:"id,omitempty"`
	// Name - "display name of target
	Name *string `json:"name,omitempty"`
	// Description - Description about this sku
	Description *string `json:"description,omitempty"`
	// AcceptedDataFormats - List of data formats
	AcceptedDataFormats *[]string `json:"acceptedDataFormats,omitempty"`
	// AcceptedContentEncodings - List of content encodings
	AcceptedContentEncodings *[]string `json:"acceptedContentEncodings,omitempty"`
}

// Workspace the resource proxy definition object for quantum workspace.
type Workspace struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Gets or sets the id for the resource.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Gets or sets the name of the resource definition.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource definition.
	Type *string `json:"type,omitempty"`
	// Location - Gets or sets the resource location.
	Location *string `json:"location,omitempty"`
	// WorkspaceProperties - Gets or sets the properties. Define quantum space's specific properties.
	*WorkspaceProperties `json:"properties,omitempty"`
	// Tags - Gets or sets the tags.
	Tags interface{} `json:"tags,omitempty"`
	// Identity - Managed Identity information
	Identity *WorkspaceIdentity `json:"identity,omitempty"`
}

// MarshalJSON is the custom marshaler for Workspace.
func (w Workspace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if w.Location != nil {
		objectMap["location"] = w.Location
	}
	if w.WorkspaceProperties != nil {
		objectMap["properties"] = w.WorkspaceProperties
	}
	if w.Tags != nil {
		objectMap["tags"] = w.Tags
	}
	if w.Identity != nil {
		objectMap["identity"] = w.Identity
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Workspace struct.
func (w *Workspace) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				w.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				w.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				w.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				w.Location = &location
			}
		case "properties":
			if v != nil {
				var workspaceProperties WorkspaceProperties
				err = json.Unmarshal(*v, &workspaceProperties)
				if err != nil {
					return err
				}
				w.WorkspaceProperties = &workspaceProperties
			}
		case "tags":
			if v != nil {
				var tags interface{}
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				w.Tags = tags
			}
		case "identity":
			if v != nil {
				var identity WorkspaceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				w.Identity = &identity
			}
		}
	}

	return nil
}

// WorkspaceIdentity managed Identity information
type WorkspaceIdentity struct {
	// Type - Type of identity. Supported: SystemAssigned or None (case insensitive)
	Type *string `json:"type,omitempty"`
	// PrincipalID - objectId of the managed identity,
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - tenantId where the managed identity lives.
	TenantID *string `json:"tenantId,omitempty"`
}

// WorkspaceListResult the response of the List Workspaces operation.
type WorkspaceListResult struct {
	autorest.Response `json:"-"`
	// Value - Result of the List Workspace operation.
	Value *[]Workspace `json:"value,omitempty"`
	// NextLink - Link to the next set of results. Not empty if Value contains incomplete list of Namespaces.
	NextLink *string `json:"nextLink,omitempty"`
}

// WorkspaceListResultIterator provides access to a complete listing of Workspace values.
type WorkspaceListResultIterator struct {
	i    int
	page WorkspaceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WorkspaceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkspaceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WorkspaceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WorkspaceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WorkspaceListResultIterator) Response() WorkspaceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WorkspaceListResultIterator) Value() Workspace {
	if !iter.page.NotDone() {
		return Workspace{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WorkspaceListResultIterator type.
func NewWorkspaceListResultIterator(page WorkspaceListResultPage) WorkspaceListResultIterator {
	return WorkspaceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wlr WorkspaceListResult) IsEmpty() bool {
	return wlr.Value == nil || len(*wlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wlr WorkspaceListResult) hasNextLink() bool {
	return wlr.NextLink != nil && len(*wlr.NextLink) != 0
}

// workspaceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wlr WorkspaceListResult) workspaceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !wlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wlr.NextLink)))
}

// WorkspaceListResultPage contains a page of Workspace values.
type WorkspaceListResultPage struct {
	fn  func(context.Context, WorkspaceListResult) (WorkspaceListResult, error)
	wlr WorkspaceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WorkspaceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkspaceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wlr)
		if err != nil {
			return err
		}
		page.wlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WorkspaceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WorkspaceListResultPage) NotDone() bool {
	return !page.wlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WorkspaceListResultPage) Response() WorkspaceListResult {
	return page.wlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WorkspaceListResultPage) Values() []Workspace {
	if page.wlr.IsEmpty() {
		return nil
	}
	return *page.wlr.Value
}

// Creates a new instance of the WorkspaceListResultPage type.
func NewWorkspaceListResultPage(getNextPage func(context.Context, WorkspaceListResult) (WorkspaceListResult, error)) WorkspaceListResultPage {
	return WorkspaceListResultPage{fn: getNextPage}
}

// WorkspaceProperties gets or sets the properties. Define quantum space's specific properties.
type WorkspaceProperties struct {
	// Providers - Providers requested from end-customer in the workspace
	Providers *[]Provider `json:"providers,omitempty"`
	// Usable - Whether the current workspace is usable. Possible values include: 'Yes', 'No', 'Partial'
	Usable UsableStatus `json:"usable,omitempty"`
	// ProvisioningState - Provisioning status field. Possible values include: 'Succeeded', 'ProviderLaunching', 'ProviderUpdating', 'ProviderDeleting', 'ProviderProvisioning', 'Deleted', 'Failed'
	ProvisioningState ProvisioningStatus `json:"provisioningState,omitempty"`
	// ResourceUsageID - Id to track resource usage.
	ResourceUsageID *string `json:"resourceUsageId,omitempty"`
	// StorageAccount - ARM Resource Id of the storage account associated with this workspace.
	StorageAccount *string `json:"storageAccount,omitempty"`
}

// WorkspaceResourceProperties resource status of workspace
type WorkspaceResourceProperties struct {
	// Providers - Providers requested from end-customer in the workspace
	Providers *[]Provider `json:"providers,omitempty"`
	// Usable - Whether the current workspace is usable. Possible values include: 'Yes', 'No', 'Partial'
	Usable UsableStatus `json:"usable,omitempty"`
	// ProvisioningState - Provisioning status field. Possible values include: 'Succeeded', 'ProviderLaunching', 'ProviderUpdating', 'ProviderDeleting', 'ProviderProvisioning', 'Deleted', 'Failed'
	ProvisioningState ProvisioningStatus `json:"provisioningState,omitempty"`
	// ResourceUsageID - Id to track resource usage.
	ResourceUsageID *string `json:"resourceUsageId,omitempty"`
	// StorageAccount - ARM Resource Id of the storage account associated with this workspace.
	StorageAccount *string `json:"storageAccount,omitempty"`
}

// WorkspacesCreateAndUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type WorkspacesCreateAndUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *WorkspacesCreateAndUpdateFuture) Result(client WorkspacesClient) (w Workspace, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "quantum.WorkspacesCreateAndUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("quantum.WorkspacesCreateAndUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if w.Response.Response, err = future.GetResult(sender); err == nil && w.Response.Response.StatusCode != http.StatusNoContent {
		w, err = client.CreateAndUpdateResponder(w.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "quantum.WorkspacesCreateAndUpdateFuture", "Result", w.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WorkspacesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type WorkspacesDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *WorkspacesDeleteFuture) Result(client WorkspacesClient) (w Workspace, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "quantum.WorkspacesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("quantum.WorkspacesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if w.Response.Response, err = future.GetResult(sender); err == nil && w.Response.Response.StatusCode != http.StatusNoContent {
		w, err = client.DeleteResponder(w.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "quantum.WorkspacesDeleteFuture", "Result", w.Response.Response, "Failure responding to request")
		}
	}
	return
}
