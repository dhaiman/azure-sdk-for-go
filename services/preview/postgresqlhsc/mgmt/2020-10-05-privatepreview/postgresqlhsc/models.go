package postgresqlhsc

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/postgresqlhsc/mgmt/2020-10-05-privatepreview/postgresqlhsc"

// AzureEntityResource the resource model definition for an Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	// Etag - READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// CloudError an error response from the Batch service.
type CloudError struct {
	// Error - The error.
	Error *CloudErrorBody `json:"error,omitempty"`
}

// CloudErrorBody an error response from the Batch service.
type CloudErrorBody struct {
	// Code - An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`
	// Message - A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`
	// Target - The target of the particular error. For example, the name of the property in error.
	Target *string `json:"target,omitempty"`
	// Details - A list of additional details about the error.
	Details *[]CloudErrorBody `json:"details,omitempty"`
}

// Configuration represents a configuration.
type Configuration struct {
	// ConfigurationProperties - The properties of a configuration.
	*ConfigurationProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Configuration.
func (c Configuration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if c.ConfigurationProperties != nil {
		objectMap["properties"] = c.ConfigurationProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Configuration struct.
func (c *Configuration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var configurationProperties ConfigurationProperties
				err = json.Unmarshal(*v, &configurationProperties)
				if err != nil {
					return err
				}
				c.ConfigurationProperties = &configurationProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				c.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				c.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				c.Type = &typeVar
			}
		}
	}

	return nil
}

// ConfigurationList a list of server configurations.
type ConfigurationList struct {
	autorest.Response `json:"-"`
	// Value - The list of server configurations.
	Value *[]Configuration `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ConfigurationList.
func (cl ConfigurationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cl.Value != nil {
		objectMap["value"] = cl.Value
	}
	return json.Marshal(objectMap)
}

// ConfigurationListIterator provides access to a complete listing of Configuration values.
type ConfigurationListIterator struct {
	i    int
	page ConfigurationListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ConfigurationListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConfigurationListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ConfigurationListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ConfigurationListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ConfigurationListIterator) Response() ConfigurationList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ConfigurationListIterator) Value() Configuration {
	if !iter.page.NotDone() {
		return Configuration{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ConfigurationListIterator type.
func NewConfigurationListIterator(page ConfigurationListPage) ConfigurationListIterator {
	return ConfigurationListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cl ConfigurationList) IsEmpty() bool {
	return cl.Value == nil || len(*cl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cl ConfigurationList) hasNextLink() bool {
	return cl.NextLink != nil && len(*cl.NextLink) != 0
}

// configurationListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cl ConfigurationList) configurationListPreparer(ctx context.Context) (*http.Request, error) {
	if !cl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cl.NextLink)))
}

// ConfigurationListPage contains a page of Configuration values.
type ConfigurationListPage struct {
	fn func(context.Context, ConfigurationList) (ConfigurationList, error)
	cl ConfigurationList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ConfigurationListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ConfigurationListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cl)
		if err != nil {
			return err
		}
		page.cl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ConfigurationListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ConfigurationListPage) NotDone() bool {
	return !page.cl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ConfigurationListPage) Response() ConfigurationList {
	return page.cl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ConfigurationListPage) Values() []Configuration {
	if page.cl.IsEmpty() {
		return nil
	}
	return *page.cl.Value
}

// Creates a new instance of the ConfigurationListPage type.
func NewConfigurationListPage(cur ConfigurationList, getNextPage func(context.Context, ConfigurationList) (ConfigurationList, error)) ConfigurationListPage {
	return ConfigurationListPage{
		fn: getNextPage,
		cl: cur,
	}
}

// ConfigurationProperties the properties of a configuration.
type ConfigurationProperties struct {
	// Value - Value of the configuration.
	Value *string `json:"value,omitempty"`
	// Source - Source of the configuration.
	Source *string `json:"source,omitempty"`
	// Description - READ-ONLY; Description of the configuration.
	Description *string `json:"description,omitempty"`
	// DefaultValue - READ-ONLY; Default value of the configuration.
	DefaultValue *string `json:"defaultValue,omitempty"`
	// DataType - READ-ONLY; Data type of the configuration. Possible values include: 'Boolean', 'Numeric', 'Integer', 'Enumeration'
	DataType ConfigurationDataType `json:"dataType,omitempty"`
	// AllowedValues - READ-ONLY; Allowed values of the configuration.
	AllowedValues *string `json:"allowedValues,omitempty"`
}

// MarshalJSON is the custom marshaler for ConfigurationProperties.
func (cp ConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cp.Value != nil {
		objectMap["value"] = cp.Value
	}
	if cp.Source != nil {
		objectMap["source"] = cp.Source
	}
	return json.Marshal(objectMap)
}

// ConfigurationPropertiesWithName the properties of a configuration with name.
type ConfigurationPropertiesWithName struct {
	// Name - Name of the configuration.
	Name *string `json:"name,omitempty"`
	// Value - Value of the configuration.
	Value *string `json:"value,omitempty"`
	// Source - Source of the configuration.
	Source *string `json:"source,omitempty"`
	// Description - READ-ONLY; Description of the configuration.
	Description *string `json:"description,omitempty"`
	// DefaultValue - READ-ONLY; Default value of the configuration.
	DefaultValue *string `json:"defaultValue,omitempty"`
	// DataType - READ-ONLY; Data type of the configuration. Possible values include: 'Boolean', 'Numeric', 'Integer', 'Enumeration'
	DataType ConfigurationDataType `json:"dataType,omitempty"`
	// AllowedValues - READ-ONLY; Allowed values of the configuration.
	AllowedValues *string `json:"allowedValues,omitempty"`
}

// MarshalJSON is the custom marshaler for ConfigurationPropertiesWithName.
func (cpwn ConfigurationPropertiesWithName) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cpwn.Name != nil {
		objectMap["name"] = cpwn.Name
	}
	if cpwn.Value != nil {
		objectMap["value"] = cpwn.Value
	}
	if cpwn.Source != nil {
		objectMap["source"] = cpwn.Source
	}
	return json.Marshal(objectMap)
}

// ConfigurationsBatchUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ConfigurationsBatchUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ConfigurationsBatchUpdateFuture) Result(client ConfigurationsClient) (sgc ServerGroupConfiguration, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ConfigurationsBatchUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ConfigurationsBatchUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sgc.Response.Response, err = future.GetResult(sender); err == nil && sgc.Response.Response.StatusCode != http.StatusNoContent {
		sgc, err = client.BatchUpdateResponder(sgc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "postgresqlhsc.ConfigurationsBatchUpdateFuture", "Result", sgc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ConfigurationsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ConfigurationsUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ConfigurationsUpdateFuture) Result(client ConfigurationsClient) (sgc ServerGroupConfiguration, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ConfigurationsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ConfigurationsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sgc.Response.Response, err = future.GetResult(sender); err == nil && sgc.Response.Response.StatusCode != http.StatusNoContent {
		sgc, err = client.UpdateResponder(sgc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "postgresqlhsc.ConfigurationsUpdateFuture", "Result", sgc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// FirewallRule represents a server group firewall rule.
type FirewallRule struct {
	autorest.Response `json:"-"`
	// FirewallRuleProperties - The properties of a firewall rule.
	*FirewallRuleProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for FirewallRule.
func (fr FirewallRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fr.FirewallRuleProperties != nil {
		objectMap["properties"] = fr.FirewallRuleProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for FirewallRule struct.
func (fr *FirewallRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var firewallRuleProperties FirewallRuleProperties
				err = json.Unmarshal(*v, &firewallRuleProperties)
				if err != nil {
					return err
				}
				fr.FirewallRuleProperties = &firewallRuleProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				fr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				fr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				fr.Type = &typeVar
			}
		}
	}

	return nil
}

// FirewallRuleListResult a list of firewall rules.
type FirewallRuleListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of firewall rules in a server group.
	Value *[]FirewallRule `json:"value,omitempty"`
}

// FirewallRuleProperties the properties of a server group firewall rule.
type FirewallRuleProperties struct {
	// StartIPAddress - The start IP address of the server group firewall rule. Must be IPv4 format.
	StartIPAddress *string `json:"startIpAddress,omitempty"`
	// EndIPAddress - The end IP address of the server group firewall rule. Must be IPv4 format.
	EndIPAddress *string `json:"endIpAddress,omitempty"`
}

// FirewallRulesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type FirewallRulesCreateOrUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *FirewallRulesCreateOrUpdateFuture) Result(client FirewallRulesClient) (fr FirewallRule, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.FirewallRulesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.FirewallRulesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if fr.Response.Response, err = future.GetResult(sender); err == nil && fr.Response.Response.StatusCode != http.StatusNoContent {
		fr, err = client.CreateOrUpdateResponder(fr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "postgresqlhsc.FirewallRulesCreateOrUpdateFuture", "Result", fr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// FirewallRulesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type FirewallRulesDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *FirewallRulesDeleteFuture) Result(client FirewallRulesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.FirewallRulesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.FirewallRulesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// NameAvailability represents a resource name availability.
type NameAvailability struct {
	autorest.Response `json:"-"`
	// Message - Error Message.
	Message *string `json:"message,omitempty"`
	// NameAvailable - Indicates whether the resource name is available.
	NameAvailable *bool `json:"nameAvailable,omitempty"`
	// Reason - Reason for name being unavailable.
	Reason *string `json:"reason,omitempty"`
}

// NameAvailabilityRequest request from client to check resource name availability.
type NameAvailabilityRequest struct {
	// Name - Resource name to verify.
	Name *string `json:"name,omitempty"`
	// Type - Resource type used for verification.
	Type *string `json:"type,omitempty"`
}

// Operation REST API operation definition.
type Operation struct {
	// Name - READ-ONLY; The name of the operation being performed on this particular object.
	Name *string `json:"name,omitempty"`
	// Display - READ-ONLY; The localized display information for this particular operation or action.
	Display *OperationDisplay `json:"display,omitempty"`
	// Origin - READ-ONLY; The intended executor of the operation. Possible values include: 'NotSpecified', 'User', 'System'
	Origin OperationOrigin `json:"origin,omitempty"`
	// Properties - READ-ONLY; Additional descriptions for the operation.
	Properties map[string]interface{} `json:"properties"`
}

// MarshalJSON is the custom marshaler for Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationDisplay display metadata associated with the operation.
type OperationDisplay struct {
	// Provider - READ-ONLY; Operation resource provider name.
	Provider *string `json:"provider,omitempty"`
	// Resource - READ-ONLY; Resource on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
	// Operation - READ-ONLY; Localized friendly name for the operation.
	Operation *string `json:"operation,omitempty"`
	// Description - READ-ONLY; Operation description.
	Description *string `json:"description,omitempty"`
}

// OperationListResult a list of resource provider operations.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of resource provider operations.
	Value *[]Operation `json:"value,omitempty"`
}

// ProxyResource the resource model definition for a Azure Resource Manager proxy resource. It will not
// have tags and a location
type ProxyResource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// Resource common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// Role represents a server group role.
type Role struct {
	autorest.Response `json:"-"`
	// RoleProperties - The properties of a role.
	*RoleProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Role.
func (r Role) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.RoleProperties != nil {
		objectMap["properties"] = r.RoleProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Role struct.
func (r *Role) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var roleProperties RoleProperties
				err = json.Unmarshal(*v, &roleProperties)
				if err != nil {
					return err
				}
				r.RoleProperties = &roleProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				r.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				r.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				r.Type = &typeVar
			}
		}
	}

	return nil
}

// RoleListResult a list of roles.
type RoleListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of roles in a server group.
	Value *[]Role `json:"value,omitempty"`
}

// RoleProperties the properties of a server group role.
type RoleProperties struct {
	// Password - The password of the server group role.
	Password *string `json:"password,omitempty"`
}

// RolesCreateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type RolesCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *RolesCreateFuture) Result(client RolesClient) (r Role, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.RolesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.RolesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if r.Response.Response, err = future.GetResult(sender); err == nil && r.Response.Response.StatusCode != http.StatusNoContent {
		r, err = client.CreateResponder(r.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "postgresqlhsc.RolesCreateFuture", "Result", r.Response.Response, "Failure responding to request")
		}
	}
	return
}

// RolesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type RolesDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *RolesDeleteFuture) Result(client RolesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.RolesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.RolesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ServerGroup represents a server group for create.
type ServerGroup struct {
	autorest.Response `json:"-"`
	// BasicServerGroupProperties - Properties of the server group create.
	BasicServerGroupProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroup.
func (sg ServerGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["properties"] = sg.BasicServerGroupProperties
	if sg.Tags != nil {
		objectMap["tags"] = sg.Tags
	}
	if sg.Location != nil {
		objectMap["location"] = sg.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServerGroup struct.
func (sg *ServerGroup) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				basicServerGroupProperties, err := unmarshalBasicServerGroupProperties(*v)
				if err != nil {
					return err
				}
				sg.BasicServerGroupProperties = basicServerGroupProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				sg.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				sg.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sg.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sg.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sg.Type = &typeVar
			}
		}
	}

	return nil
}

// ServerGroupConfiguration represents the configuration list of server role groups in a server group.
type ServerGroupConfiguration struct {
	autorest.Response `json:"-"`
	// ServerGroupConfigurationProperties - The properties of server group configuration.
	*ServerGroupConfigurationProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroupConfiguration.
func (sgc ServerGroupConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sgc.ServerGroupConfigurationProperties != nil {
		objectMap["properties"] = sgc.ServerGroupConfigurationProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServerGroupConfiguration struct.
func (sgc *ServerGroupConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var serverGroupConfigurationProperties ServerGroupConfigurationProperties
				err = json.Unmarshal(*v, &serverGroupConfigurationProperties)
				if err != nil {
					return err
				}
				sgc.ServerGroupConfigurationProperties = &serverGroupConfigurationProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sgc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sgc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sgc.Type = &typeVar
			}
		}
	}

	return nil
}

// ServerGroupConfigurationProperties the properties of server group configuration.
type ServerGroupConfigurationProperties struct {
	// ServerRoleGroupConfigurations - The list of server role group configurations.
	ServerRoleGroupConfigurations *[]ServerRoleGroupConfiguration `json:"serverRoleGroupConfigurations,omitempty"`
}

// ServerGroupForPatch represents a server group for update.
type ServerGroupForPatch struct {
	// Location - The location the resource resides in.
	Location *string `json:"location,omitempty"`
	// ServerGroupPropertiesForUpdate - Properties of the server group.
	*ServerGroupPropertiesForUpdate `json:"properties,omitempty"`
	// Tags - Application-specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ServerGroupForPatch.
func (sgfp ServerGroupForPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sgfp.Location != nil {
		objectMap["location"] = sgfp.Location
	}
	if sgfp.ServerGroupPropertiesForUpdate != nil {
		objectMap["properties"] = sgfp.ServerGroupPropertiesForUpdate
	}
	if sgfp.Tags != nil {
		objectMap["tags"] = sgfp.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServerGroupForPatch struct.
func (sgfp *ServerGroupForPatch) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				sgfp.Location = &location
			}
		case "properties":
			if v != nil {
				var serverGroupPropertiesForUpdate ServerGroupPropertiesForUpdate
				err = json.Unmarshal(*v, &serverGroupPropertiesForUpdate)
				if err != nil {
					return err
				}
				sgfp.ServerGroupPropertiesForUpdate = &serverGroupPropertiesForUpdate
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				sgfp.Tags = tags
			}
		}
	}

	return nil
}

// BasicServerGroupProperties the properties used to create a new server group.
type BasicServerGroupProperties interface {
	AsServerGroupPropertiesForUpdate() (*ServerGroupPropertiesForUpdate, bool)
	AsServerGroupPropertiesForDefault() (*ServerGroupPropertiesForDefault, bool)
	AsServerGroupPropertiesForRestore() (*ServerGroupPropertiesForRestore, bool)
	AsServerGroupProperties() (*ServerGroupProperties, bool)
}

// ServerGroupProperties the properties used to create a new server group.
type ServerGroupProperties struct {
	// AdministratorLogin - The administrator's login name of servers in server group. Can only be specified when the server is being created (and is required for creation).
	AdministratorLogin *string `json:"administratorLogin,omitempty"`
	// BackupRetentionDays - The backup retention days for server group.
	BackupRetentionDays *int32 `json:"backupRetentionDays,omitempty"`
	// Version - The version of servers. Possible values include: 'OneOne', 'OneTwo'
	Version ServerVersion `json:"version,omitempty"`
	// CitusVersion - The citus version of servers. Possible values include: 'EightFullStopThree', 'NineFullStopZero', 'NineFullStopOne', 'NineFullStopTwo', 'NineFullStopThree', 'NineFullStopFour', 'NineFullStopFive'
	CitusVersion ServerCitusVersion `json:"citusVersion,omitempty"`
	// IsMx - If zfs is enabled or not for the server group.
	IsMx *bool `json:"isMx,omitempty"`
	// IsZfs - If zfs is enabled or not for the server group.
	IsZfs *bool `json:"isZfs,omitempty"`
	// State - A state of a server group that is visible to user. Possible values include: 'Ready', 'Dropping', 'Disabled', 'Starting', 'Stopping', 'Stopped', 'Updating'
	State ServerState `json:"state,omitempty"`
	// EarliestRestoreTime - READ-ONLY; The earliest restore point time (ISO8601 format) for server group.
	EarliestRestoreTime *date.Time `json:"earliestRestoreTime,omitempty"`
	// ResourceProviderType - The resource provider type of server group. Possible values include: 'Meru', 'Marlin'
	ResourceProviderType ResourceProviderType `json:"resourceProviderType,omitempty"`
	// VnetInjArgs - The vnet injection arguments for server group.
	VnetInjArgs *VnetInjArgs `json:"vnetInjArgs,omitempty"`
	// ServerRoleGroups - The list of server role groups.
	ServerRoleGroups *[]ServerRoleGroup `json:"serverRoleGroups,omitempty"`
	// CreateMode - Possible values include: 'CreateModeServerGroupProperties', 'CreateModeUpdate', 'CreateModeDefault', 'CreateModePointInTimeRestore'
	CreateMode CreateMode `json:"createMode,omitempty"`
}

func unmarshalBasicServerGroupProperties(body []byte) (BasicServerGroupProperties, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["createMode"] {
	case string(CreateModeUpdate):
		var sgpfu ServerGroupPropertiesForUpdate
		err := json.Unmarshal(body, &sgpfu)
		return sgpfu, err
	case string(CreateModeDefault):
		var sgpfd ServerGroupPropertiesForDefault
		err := json.Unmarshal(body, &sgpfd)
		return sgpfd, err
	case string(CreateModePointInTimeRestore):
		var sgpfr ServerGroupPropertiesForRestore
		err := json.Unmarshal(body, &sgpfr)
		return sgpfr, err
	default:
		var sgp ServerGroupProperties
		err := json.Unmarshal(body, &sgp)
		return sgp, err
	}
}
func unmarshalBasicServerGroupPropertiesArray(body []byte) ([]BasicServerGroupProperties, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	sgpArray := make([]BasicServerGroupProperties, len(rawMessages))

	for index, rawMessage := range rawMessages {
		sgp, err := unmarshalBasicServerGroupProperties(*rawMessage)
		if err != nil {
			return nil, err
		}
		sgpArray[index] = sgp
	}
	return sgpArray, nil
}

// MarshalJSON is the custom marshaler for ServerGroupProperties.
func (sgp ServerGroupProperties) MarshalJSON() ([]byte, error) {
	sgp.CreateMode = CreateModeServerGroupProperties
	objectMap := make(map[string]interface{})
	if sgp.AdministratorLogin != nil {
		objectMap["administratorLogin"] = sgp.AdministratorLogin
	}
	if sgp.BackupRetentionDays != nil {
		objectMap["backupRetentionDays"] = sgp.BackupRetentionDays
	}
	if sgp.Version != "" {
		objectMap["version"] = sgp.Version
	}
	if sgp.CitusVersion != "" {
		objectMap["citusVersion"] = sgp.CitusVersion
	}
	if sgp.IsMx != nil {
		objectMap["isMx"] = sgp.IsMx
	}
	if sgp.IsZfs != nil {
		objectMap["isZfs"] = sgp.IsZfs
	}
	if sgp.State != "" {
		objectMap["state"] = sgp.State
	}
	if sgp.ResourceProviderType != "" {
		objectMap["resourceProviderType"] = sgp.ResourceProviderType
	}
	if sgp.VnetInjArgs != nil {
		objectMap["vnetInjArgs"] = sgp.VnetInjArgs
	}
	if sgp.ServerRoleGroups != nil {
		objectMap["serverRoleGroups"] = sgp.ServerRoleGroups
	}
	if sgp.CreateMode != "" {
		objectMap["createMode"] = sgp.CreateMode
	}
	return json.Marshal(objectMap)
}

// AsServerGroupPropertiesForUpdate is the BasicServerGroupProperties implementation for ServerGroupProperties.
func (sgp ServerGroupProperties) AsServerGroupPropertiesForUpdate() (*ServerGroupPropertiesForUpdate, bool) {
	return nil, false
}

// AsServerGroupPropertiesForDefault is the BasicServerGroupProperties implementation for ServerGroupProperties.
func (sgp ServerGroupProperties) AsServerGroupPropertiesForDefault() (*ServerGroupPropertiesForDefault, bool) {
	return nil, false
}

// AsServerGroupPropertiesForRestore is the BasicServerGroupProperties implementation for ServerGroupProperties.
func (sgp ServerGroupProperties) AsServerGroupPropertiesForRestore() (*ServerGroupPropertiesForRestore, bool) {
	return nil, false
}

// AsServerGroupProperties is the BasicServerGroupProperties implementation for ServerGroupProperties.
func (sgp ServerGroupProperties) AsServerGroupProperties() (*ServerGroupProperties, bool) {
	return &sgp, true
}

// AsBasicServerGroupProperties is the BasicServerGroupProperties implementation for ServerGroupProperties.
func (sgp ServerGroupProperties) AsBasicServerGroupProperties() (BasicServerGroupProperties, bool) {
	return &sgp, true
}

// ServerGroupPropertiesForDefault the properties used to create a new server group.
type ServerGroupPropertiesForDefault struct {
	// AdministratorLoginPassword - The password of the administrator login.
	AdministratorLoginPassword *string `json:"administratorLoginPassword,omitempty"`
	// AdministratorLogin - The administrator's login name of servers in server group. Can only be specified when the server is being created (and is required for creation).
	AdministratorLogin *string `json:"administratorLogin,omitempty"`
	// BackupRetentionDays - The backup retention days for server group.
	BackupRetentionDays *int32 `json:"backupRetentionDays,omitempty"`
	// Version - The version of servers. Possible values include: 'OneOne', 'OneTwo'
	Version ServerVersion `json:"version,omitempty"`
	// CitusVersion - The citus version of servers. Possible values include: 'EightFullStopThree', 'NineFullStopZero', 'NineFullStopOne', 'NineFullStopTwo', 'NineFullStopThree', 'NineFullStopFour', 'NineFullStopFive'
	CitusVersion ServerCitusVersion `json:"citusVersion,omitempty"`
	// IsMx - If zfs is enabled or not for the server group.
	IsMx *bool `json:"isMx,omitempty"`
	// IsZfs - If zfs is enabled or not for the server group.
	IsZfs *bool `json:"isZfs,omitempty"`
	// State - A state of a server group that is visible to user. Possible values include: 'Ready', 'Dropping', 'Disabled', 'Starting', 'Stopping', 'Stopped', 'Updating'
	State ServerState `json:"state,omitempty"`
	// EarliestRestoreTime - READ-ONLY; The earliest restore point time (ISO8601 format) for server group.
	EarliestRestoreTime *date.Time `json:"earliestRestoreTime,omitempty"`
	// ResourceProviderType - The resource provider type of server group. Possible values include: 'Meru', 'Marlin'
	ResourceProviderType ResourceProviderType `json:"resourceProviderType,omitempty"`
	// VnetInjArgs - The vnet injection arguments for server group.
	VnetInjArgs *VnetInjArgs `json:"vnetInjArgs,omitempty"`
	// ServerRoleGroups - The list of server role groups.
	ServerRoleGroups *[]ServerRoleGroup `json:"serverRoleGroups,omitempty"`
	// CreateMode - Possible values include: 'CreateModeServerGroupProperties', 'CreateModeUpdate', 'CreateModeDefault', 'CreateModePointInTimeRestore'
	CreateMode CreateMode `json:"createMode,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroupPropertiesForDefault.
func (sgpfd ServerGroupPropertiesForDefault) MarshalJSON() ([]byte, error) {
	sgpfd.CreateMode = CreateModeDefault
	objectMap := make(map[string]interface{})
	if sgpfd.AdministratorLoginPassword != nil {
		objectMap["administratorLoginPassword"] = sgpfd.AdministratorLoginPassword
	}
	if sgpfd.AdministratorLogin != nil {
		objectMap["administratorLogin"] = sgpfd.AdministratorLogin
	}
	if sgpfd.BackupRetentionDays != nil {
		objectMap["backupRetentionDays"] = sgpfd.BackupRetentionDays
	}
	if sgpfd.Version != "" {
		objectMap["version"] = sgpfd.Version
	}
	if sgpfd.CitusVersion != "" {
		objectMap["citusVersion"] = sgpfd.CitusVersion
	}
	if sgpfd.IsMx != nil {
		objectMap["isMx"] = sgpfd.IsMx
	}
	if sgpfd.IsZfs != nil {
		objectMap["isZfs"] = sgpfd.IsZfs
	}
	if sgpfd.State != "" {
		objectMap["state"] = sgpfd.State
	}
	if sgpfd.ResourceProviderType != "" {
		objectMap["resourceProviderType"] = sgpfd.ResourceProviderType
	}
	if sgpfd.VnetInjArgs != nil {
		objectMap["vnetInjArgs"] = sgpfd.VnetInjArgs
	}
	if sgpfd.ServerRoleGroups != nil {
		objectMap["serverRoleGroups"] = sgpfd.ServerRoleGroups
	}
	if sgpfd.CreateMode != "" {
		objectMap["createMode"] = sgpfd.CreateMode
	}
	return json.Marshal(objectMap)
}

// AsServerGroupPropertiesForUpdate is the BasicServerGroupProperties implementation for ServerGroupPropertiesForDefault.
func (sgpfd ServerGroupPropertiesForDefault) AsServerGroupPropertiesForUpdate() (*ServerGroupPropertiesForUpdate, bool) {
	return nil, false
}

// AsServerGroupPropertiesForDefault is the BasicServerGroupProperties implementation for ServerGroupPropertiesForDefault.
func (sgpfd ServerGroupPropertiesForDefault) AsServerGroupPropertiesForDefault() (*ServerGroupPropertiesForDefault, bool) {
	return &sgpfd, true
}

// AsServerGroupPropertiesForRestore is the BasicServerGroupProperties implementation for ServerGroupPropertiesForDefault.
func (sgpfd ServerGroupPropertiesForDefault) AsServerGroupPropertiesForRestore() (*ServerGroupPropertiesForRestore, bool) {
	return nil, false
}

// AsServerGroupProperties is the BasicServerGroupProperties implementation for ServerGroupPropertiesForDefault.
func (sgpfd ServerGroupPropertiesForDefault) AsServerGroupProperties() (*ServerGroupProperties, bool) {
	return nil, false
}

// AsBasicServerGroupProperties is the BasicServerGroupProperties implementation for ServerGroupPropertiesForDefault.
func (sgpfd ServerGroupPropertiesForDefault) AsBasicServerGroupProperties() (BasicServerGroupProperties, bool) {
	return &sgpfd, true
}

// ServerGroupPropertiesForRestore the properties used to create a new server group by restoring from a
// backup.
type ServerGroupPropertiesForRestore struct {
	// SourceSubscriptionID - The source subscription id to restore from.
	SourceSubscriptionID *string `json:"sourceSubscriptionId,omitempty"`
	// SourceResourceGroupName - The source resource group name to restore from.
	SourceResourceGroupName *string `json:"sourceResourceGroupName,omitempty"`
	// SourceServerGroupName - The source server group name to restore from.
	SourceServerGroupName *string `json:"sourceServerGroupName,omitempty"`
	// SourceLocation - The source server group location to restore from.
	SourceLocation *string `json:"sourceLocation,omitempty"`
	// PointInTimeUTC - Restore point creation time (ISO8601 format), specifying the time to restore from.
	PointInTimeUTC *date.Time `json:"pointInTimeUTC,omitempty"`
	// AdministratorLogin - The administrator's login name of servers in server group. Can only be specified when the server is being created (and is required for creation).
	AdministratorLogin *string `json:"administratorLogin,omitempty"`
	// BackupRetentionDays - The backup retention days for server group.
	BackupRetentionDays *int32 `json:"backupRetentionDays,omitempty"`
	// Version - The version of servers. Possible values include: 'OneOne', 'OneTwo'
	Version ServerVersion `json:"version,omitempty"`
	// CitusVersion - The citus version of servers. Possible values include: 'EightFullStopThree', 'NineFullStopZero', 'NineFullStopOne', 'NineFullStopTwo', 'NineFullStopThree', 'NineFullStopFour', 'NineFullStopFive'
	CitusVersion ServerCitusVersion `json:"citusVersion,omitempty"`
	// IsMx - If zfs is enabled or not for the server group.
	IsMx *bool `json:"isMx,omitempty"`
	// IsZfs - If zfs is enabled or not for the server group.
	IsZfs *bool `json:"isZfs,omitempty"`
	// State - A state of a server group that is visible to user. Possible values include: 'Ready', 'Dropping', 'Disabled', 'Starting', 'Stopping', 'Stopped', 'Updating'
	State ServerState `json:"state,omitempty"`
	// EarliestRestoreTime - READ-ONLY; The earliest restore point time (ISO8601 format) for server group.
	EarliestRestoreTime *date.Time `json:"earliestRestoreTime,omitempty"`
	// ResourceProviderType - The resource provider type of server group. Possible values include: 'Meru', 'Marlin'
	ResourceProviderType ResourceProviderType `json:"resourceProviderType,omitempty"`
	// VnetInjArgs - The vnet injection arguments for server group.
	VnetInjArgs *VnetInjArgs `json:"vnetInjArgs,omitempty"`
	// ServerRoleGroups - The list of server role groups.
	ServerRoleGroups *[]ServerRoleGroup `json:"serverRoleGroups,omitempty"`
	// CreateMode - Possible values include: 'CreateModeServerGroupProperties', 'CreateModeUpdate', 'CreateModeDefault', 'CreateModePointInTimeRestore'
	CreateMode CreateMode `json:"createMode,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroupPropertiesForRestore.
func (sgpfr ServerGroupPropertiesForRestore) MarshalJSON() ([]byte, error) {
	sgpfr.CreateMode = CreateModePointInTimeRestore
	objectMap := make(map[string]interface{})
	if sgpfr.SourceSubscriptionID != nil {
		objectMap["sourceSubscriptionId"] = sgpfr.SourceSubscriptionID
	}
	if sgpfr.SourceResourceGroupName != nil {
		objectMap["sourceResourceGroupName"] = sgpfr.SourceResourceGroupName
	}
	if sgpfr.SourceServerGroupName != nil {
		objectMap["sourceServerGroupName"] = sgpfr.SourceServerGroupName
	}
	if sgpfr.SourceLocation != nil {
		objectMap["sourceLocation"] = sgpfr.SourceLocation
	}
	if sgpfr.PointInTimeUTC != nil {
		objectMap["pointInTimeUTC"] = sgpfr.PointInTimeUTC
	}
	if sgpfr.AdministratorLogin != nil {
		objectMap["administratorLogin"] = sgpfr.AdministratorLogin
	}
	if sgpfr.BackupRetentionDays != nil {
		objectMap["backupRetentionDays"] = sgpfr.BackupRetentionDays
	}
	if sgpfr.Version != "" {
		objectMap["version"] = sgpfr.Version
	}
	if sgpfr.CitusVersion != "" {
		objectMap["citusVersion"] = sgpfr.CitusVersion
	}
	if sgpfr.IsMx != nil {
		objectMap["isMx"] = sgpfr.IsMx
	}
	if sgpfr.IsZfs != nil {
		objectMap["isZfs"] = sgpfr.IsZfs
	}
	if sgpfr.State != "" {
		objectMap["state"] = sgpfr.State
	}
	if sgpfr.ResourceProviderType != "" {
		objectMap["resourceProviderType"] = sgpfr.ResourceProviderType
	}
	if sgpfr.VnetInjArgs != nil {
		objectMap["vnetInjArgs"] = sgpfr.VnetInjArgs
	}
	if sgpfr.ServerRoleGroups != nil {
		objectMap["serverRoleGroups"] = sgpfr.ServerRoleGroups
	}
	if sgpfr.CreateMode != "" {
		objectMap["createMode"] = sgpfr.CreateMode
	}
	return json.Marshal(objectMap)
}

// AsServerGroupPropertiesForUpdate is the BasicServerGroupProperties implementation for ServerGroupPropertiesForRestore.
func (sgpfr ServerGroupPropertiesForRestore) AsServerGroupPropertiesForUpdate() (*ServerGroupPropertiesForUpdate, bool) {
	return nil, false
}

// AsServerGroupPropertiesForDefault is the BasicServerGroupProperties implementation for ServerGroupPropertiesForRestore.
func (sgpfr ServerGroupPropertiesForRestore) AsServerGroupPropertiesForDefault() (*ServerGroupPropertiesForDefault, bool) {
	return nil, false
}

// AsServerGroupPropertiesForRestore is the BasicServerGroupProperties implementation for ServerGroupPropertiesForRestore.
func (sgpfr ServerGroupPropertiesForRestore) AsServerGroupPropertiesForRestore() (*ServerGroupPropertiesForRestore, bool) {
	return &sgpfr, true
}

// AsServerGroupProperties is the BasicServerGroupProperties implementation for ServerGroupPropertiesForRestore.
func (sgpfr ServerGroupPropertiesForRestore) AsServerGroupProperties() (*ServerGroupProperties, bool) {
	return nil, false
}

// AsBasicServerGroupProperties is the BasicServerGroupProperties implementation for ServerGroupPropertiesForRestore.
func (sgpfr ServerGroupPropertiesForRestore) AsBasicServerGroupProperties() (BasicServerGroupProperties, bool) {
	return &sgpfr, true
}

// ServerGroupPropertiesForUpdate the properties used to update a server group.
type ServerGroupPropertiesForUpdate struct {
	// AdministratorLoginPassword - The password of the administrator login.
	AdministratorLoginPassword *string `json:"administratorLoginPassword,omitempty"`
	// AdministratorLogin - The administrator's login name of servers in server group. Can only be specified when the server is being created (and is required for creation).
	AdministratorLogin *string `json:"administratorLogin,omitempty"`
	// BackupRetentionDays - The backup retention days for server group.
	BackupRetentionDays *int32 `json:"backupRetentionDays,omitempty"`
	// Version - The version of servers. Possible values include: 'OneOne', 'OneTwo'
	Version ServerVersion `json:"version,omitempty"`
	// CitusVersion - The citus version of servers. Possible values include: 'EightFullStopThree', 'NineFullStopZero', 'NineFullStopOne', 'NineFullStopTwo', 'NineFullStopThree', 'NineFullStopFour', 'NineFullStopFive'
	CitusVersion ServerCitusVersion `json:"citusVersion,omitempty"`
	// IsMx - If zfs is enabled or not for the server group.
	IsMx *bool `json:"isMx,omitempty"`
	// IsZfs - If zfs is enabled or not for the server group.
	IsZfs *bool `json:"isZfs,omitempty"`
	// State - A state of a server group that is visible to user. Possible values include: 'Ready', 'Dropping', 'Disabled', 'Starting', 'Stopping', 'Stopped', 'Updating'
	State ServerState `json:"state,omitempty"`
	// EarliestRestoreTime - READ-ONLY; The earliest restore point time (ISO8601 format) for server group.
	EarliestRestoreTime *date.Time `json:"earliestRestoreTime,omitempty"`
	// ResourceProviderType - The resource provider type of server group. Possible values include: 'Meru', 'Marlin'
	ResourceProviderType ResourceProviderType `json:"resourceProviderType,omitempty"`
	// VnetInjArgs - The vnet injection arguments for server group.
	VnetInjArgs *VnetInjArgs `json:"vnetInjArgs,omitempty"`
	// ServerRoleGroups - The list of server role groups.
	ServerRoleGroups *[]ServerRoleGroup `json:"serverRoleGroups,omitempty"`
	// CreateMode - Possible values include: 'CreateModeServerGroupProperties', 'CreateModeUpdate', 'CreateModeDefault', 'CreateModePointInTimeRestore'
	CreateMode CreateMode `json:"createMode,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroupPropertiesForUpdate.
func (sgpfu ServerGroupPropertiesForUpdate) MarshalJSON() ([]byte, error) {
	sgpfu.CreateMode = CreateModeUpdate
	objectMap := make(map[string]interface{})
	if sgpfu.AdministratorLoginPassword != nil {
		objectMap["administratorLoginPassword"] = sgpfu.AdministratorLoginPassword
	}
	if sgpfu.AdministratorLogin != nil {
		objectMap["administratorLogin"] = sgpfu.AdministratorLogin
	}
	if sgpfu.BackupRetentionDays != nil {
		objectMap["backupRetentionDays"] = sgpfu.BackupRetentionDays
	}
	if sgpfu.Version != "" {
		objectMap["version"] = sgpfu.Version
	}
	if sgpfu.CitusVersion != "" {
		objectMap["citusVersion"] = sgpfu.CitusVersion
	}
	if sgpfu.IsMx != nil {
		objectMap["isMx"] = sgpfu.IsMx
	}
	if sgpfu.IsZfs != nil {
		objectMap["isZfs"] = sgpfu.IsZfs
	}
	if sgpfu.State != "" {
		objectMap["state"] = sgpfu.State
	}
	if sgpfu.ResourceProviderType != "" {
		objectMap["resourceProviderType"] = sgpfu.ResourceProviderType
	}
	if sgpfu.VnetInjArgs != nil {
		objectMap["vnetInjArgs"] = sgpfu.VnetInjArgs
	}
	if sgpfu.ServerRoleGroups != nil {
		objectMap["serverRoleGroups"] = sgpfu.ServerRoleGroups
	}
	if sgpfu.CreateMode != "" {
		objectMap["createMode"] = sgpfu.CreateMode
	}
	return json.Marshal(objectMap)
}

// AsServerGroupPropertiesForUpdate is the BasicServerGroupProperties implementation for ServerGroupPropertiesForUpdate.
func (sgpfu ServerGroupPropertiesForUpdate) AsServerGroupPropertiesForUpdate() (*ServerGroupPropertiesForUpdate, bool) {
	return &sgpfu, true
}

// AsServerGroupPropertiesForDefault is the BasicServerGroupProperties implementation for ServerGroupPropertiesForUpdate.
func (sgpfu ServerGroupPropertiesForUpdate) AsServerGroupPropertiesForDefault() (*ServerGroupPropertiesForDefault, bool) {
	return nil, false
}

// AsServerGroupPropertiesForRestore is the BasicServerGroupProperties implementation for ServerGroupPropertiesForUpdate.
func (sgpfu ServerGroupPropertiesForUpdate) AsServerGroupPropertiesForRestore() (*ServerGroupPropertiesForRestore, bool) {
	return nil, false
}

// AsServerGroupProperties is the BasicServerGroupProperties implementation for ServerGroupPropertiesForUpdate.
func (sgpfu ServerGroupPropertiesForUpdate) AsServerGroupProperties() (*ServerGroupProperties, bool) {
	return nil, false
}

// AsBasicServerGroupProperties is the BasicServerGroupProperties implementation for ServerGroupPropertiesForUpdate.
func (sgpfu ServerGroupPropertiesForUpdate) AsBasicServerGroupProperties() (BasicServerGroupProperties, bool) {
	return &sgpfu, true
}

// ServerGroupsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ServerGroupsCreateOrUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ServerGroupsCreateOrUpdateFuture) Result(client ServerGroupsClient) (sg ServerGroup, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ServerGroupsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sg.Response.Response, err = future.GetResult(sender); err == nil && sg.Response.Response.StatusCode != http.StatusNoContent {
		sg, err = client.CreateOrUpdateResponder(sg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsCreateOrUpdateFuture", "Result", sg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ServerGroupsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ServerGroupsDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ServerGroupsDeleteFuture) Result(client ServerGroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ServerGroupsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ServerGroupServer represents a server in a server group.
type ServerGroupServer struct {
	autorest.Response `json:"-"`
	// ServerGroupServerProperties - The properties of a server in a server group.
	*ServerGroupServerProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroupServer.
func (sgs ServerGroupServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sgs.ServerGroupServerProperties != nil {
		objectMap["properties"] = sgs.ServerGroupServerProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServerGroupServer struct.
func (sgs *ServerGroupServer) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var serverGroupServerProperties ServerGroupServerProperties
				err = json.Unmarshal(*v, &serverGroupServerProperties)
				if err != nil {
					return err
				}
				sgs.ServerGroupServerProperties = &serverGroupServerProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sgs.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sgs.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sgs.Type = &typeVar
			}
		}
	}

	return nil
}

// ServerGroupServerList a list of servers in a server group.
type ServerGroupServerList struct {
	autorest.Response `json:"-"`
	// Value - The list of servers in a server group.
	Value *[]ServerGroupServer `json:"value,omitempty"`
}

// ServerGroupServerProperties the properties of a server in server group.
type ServerGroupServerProperties struct {
	// Role - The role of server in the server group. Possible values include: 'Coordinator', 'Worker'
	Role ServerRole `json:"role,omitempty"`
	// State - A state of a server that is visible to user. Possible values include: 'Ready', 'Dropping', 'Disabled', 'Starting', 'Stopping', 'Stopped', 'Updating'
	State ServerState `json:"state,omitempty"`
	// HaState - A state of a server group that is visible to user for HA feature. Possible values include: 'NotEnabled', 'CreatingStandby', 'ReplicatingData', 'FailingOver', 'Healthy', 'RemovingStandby', 'NotSync'
	HaState ServerHaState `json:"haState,omitempty"`
	// AdministratorLogin - The administrator's login name of a servers in server group.
	AdministratorLogin *string `json:"administratorLogin,omitempty"`
	// Version - The version of a server. Possible values include: 'OneOne', 'OneTwo'
	Version ServerVersion `json:"version,omitempty"`
	// ServerEdition - The edition of a server (default: GeneralPurpose). Possible values include: 'GeneralPurpose', 'MemoryOptimized'
	ServerEdition ServerEdition `json:"serverEdition,omitempty"`
	// StorageQuotaInMb - The storage of a server in MB (max: 2097152 = 2TiB).
	StorageQuotaInMb *int64 `json:"storageQuotaInMb,omitempty"`
	// VCores - The vCores count of a server (max: 64).
	VCores *int64 `json:"vCores,omitempty"`
	// StandbyCount - The standby count of a server.
	StandbyCount *int32 `json:"standbyCount,omitempty"`
	// IsPublicIPRequested - READ-ONLY; If public IP is requested or not for a server.
	IsPublicIPRequested *bool `json:"isPublicIpRequested,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroupServerProperties.
func (sgsp ServerGroupServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sgsp.Role != "" {
		objectMap["role"] = sgsp.Role
	}
	if sgsp.State != "" {
		objectMap["state"] = sgsp.State
	}
	if sgsp.HaState != "" {
		objectMap["haState"] = sgsp.HaState
	}
	if sgsp.AdministratorLogin != nil {
		objectMap["administratorLogin"] = sgsp.AdministratorLogin
	}
	if sgsp.Version != "" {
		objectMap["version"] = sgsp.Version
	}
	if sgsp.ServerEdition != "" {
		objectMap["serverEdition"] = sgsp.ServerEdition
	}
	if sgsp.StorageQuotaInMb != nil {
		objectMap["storageQuotaInMb"] = sgsp.StorageQuotaInMb
	}
	if sgsp.VCores != nil {
		objectMap["vCores"] = sgsp.VCores
	}
	if sgsp.StandbyCount != nil {
		objectMap["standbyCount"] = sgsp.StandbyCount
	}
	return json.Marshal(objectMap)
}

// ServerGroupsRestartFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ServerGroupsRestartFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ServerGroupsRestartFuture) Result(client ServerGroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsRestartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ServerGroupsRestartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ServerGroupsStartFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ServerGroupsStartFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ServerGroupsStartFuture) Result(client ServerGroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsStartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ServerGroupsStartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ServerGroupsStopFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ServerGroupsStopFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ServerGroupsStopFuture) Result(client ServerGroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsStopFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ServerGroupsStopFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ServerGroupsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ServerGroupsUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ServerGroupsUpdateFuture) Result(client ServerGroupsClient) (sg ServerGroup, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ServerGroupsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sg.Response.Response, err = future.GetResult(sender); err == nil && sg.Response.Response.StatusCode != http.StatusNoContent {
		sg, err = client.UpdateResponder(sg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsUpdateFuture", "Result", sg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ServerProperties the properties of a server.
type ServerProperties struct {
	// ServerEdition - The edition of a server (default: GeneralPurpose). Possible values include: 'GeneralPurpose', 'MemoryOptimized'
	ServerEdition ServerEdition `json:"serverEdition,omitempty"`
	// StorageQuotaInMb - The storage of a server in MB (max: 2097152 = 2TiB).
	StorageQuotaInMb *int64 `json:"storageQuotaInMb,omitempty"`
	// VCores - The vCores count of a server (max: 64).
	VCores *int64 `json:"vCores,omitempty"`
	// StandbyCount - The standby count of a server.
	StandbyCount *int32 `json:"standbyCount,omitempty"`
	// IsPublicIPRequested - READ-ONLY; If public IP is requested or not for a server.
	IsPublicIPRequested *bool `json:"isPublicIpRequested,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerProperties.
func (sp ServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sp.ServerEdition != "" {
		objectMap["serverEdition"] = sp.ServerEdition
	}
	if sp.StorageQuotaInMb != nil {
		objectMap["storageQuotaInMb"] = sp.StorageQuotaInMb
	}
	if sp.VCores != nil {
		objectMap["vCores"] = sp.VCores
	}
	if sp.StandbyCount != nil {
		objectMap["standbyCount"] = sp.StandbyCount
	}
	return json.Marshal(objectMap)
}

// ServerRoleGroup represents a server role group.
type ServerRoleGroup struct {
	// Name - The name of the server role group.
	Name *string `json:"name,omitempty"`
	// Role - The role of servers in the server role group. Possible values include: 'Coordinator', 'Worker'
	Role ServerRole `json:"role,omitempty"`
	// ServerCount - The number of servers in the server role group.
	ServerCount *int32 `json:"serverCount,omitempty"`
	// HaState - A state of a server role group that is visible to user for HA feature. Possible values include: 'NotEnabled', 'CreatingStandby', 'ReplicatingData', 'FailingOver', 'Healthy', 'RemovingStandby', 'NotSync'
	HaState ServerHaState `json:"haState,omitempty"`
	// ServerNames - READ-ONLY; The list of server names in the server role group.
	ServerNames *[]string `json:"serverNames,omitempty"`
	// ServerEdition - The edition of a server (default: GeneralPurpose). Possible values include: 'GeneralPurpose', 'MemoryOptimized'
	ServerEdition ServerEdition `json:"serverEdition,omitempty"`
	// StorageQuotaInMb - The storage of a server in MB (max: 2097152 = 2TiB).
	StorageQuotaInMb *int64 `json:"storageQuotaInMb,omitempty"`
	// VCores - The vCores count of a server (max: 64).
	VCores *int64 `json:"vCores,omitempty"`
	// StandbyCount - The standby count of a server.
	StandbyCount *int32 `json:"standbyCount,omitempty"`
	// IsPublicIPRequested - READ-ONLY; If public IP is requested or not for a server.
	IsPublicIPRequested *bool `json:"isPublicIpRequested,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerRoleGroup.
func (srg ServerRoleGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if srg.Name != nil {
		objectMap["name"] = srg.Name
	}
	if srg.Role != "" {
		objectMap["role"] = srg.Role
	}
	if srg.ServerCount != nil {
		objectMap["serverCount"] = srg.ServerCount
	}
	if srg.HaState != "" {
		objectMap["haState"] = srg.HaState
	}
	if srg.ServerEdition != "" {
		objectMap["serverEdition"] = srg.ServerEdition
	}
	if srg.StorageQuotaInMb != nil {
		objectMap["storageQuotaInMb"] = srg.StorageQuotaInMb
	}
	if srg.VCores != nil {
		objectMap["vCores"] = srg.VCores
	}
	if srg.StandbyCount != nil {
		objectMap["standbyCount"] = srg.StandbyCount
	}
	return json.Marshal(objectMap)
}

// ServerRoleGroupConfiguration represents server role group configurations.
type ServerRoleGroupConfiguration struct {
	// Role - The role of servers in the server role group. Possible values include: 'Coordinator', 'Worker'
	Role ServerRole `json:"role,omitempty"`
	// Configurations - The list of configurations.
	Configurations *[]ConfigurationPropertiesWithName `json:"configurations,omitempty"`
}

// TrackedResource the resource model definition for an Azure Resource Manager tracked top level resource
// which has 'tags' and a 'location'
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}

// VnetInjArgs the vnet injection arguments for server group.
type VnetInjArgs struct {
	// DelegatedVnetID - delegated vNet ID
	DelegatedVnetID *string `json:"delegatedVnetID,omitempty"`
	// DelegatedSubnetName - delegated subnet name
	DelegatedSubnetName *string `json:"delegatedSubnetName,omitempty"`
	// DelegatedVnetName - delegated vNet name
	DelegatedVnetName *string `json:"delegatedVnetName,omitempty"`
}
