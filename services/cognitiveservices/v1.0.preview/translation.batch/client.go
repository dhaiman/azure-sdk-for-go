// Package translationbatch implements the Azure ARM Translationbatch service API version v1.0-preview.1.
//
//
package translationbatch

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/Azure/go-autorest/tracing"
	"github.com/satori/go.uuid"
	"net/http"
)

const (
	// DefaultBaseURI is the default URI used for the service Translationbatch
	DefaultBaseURI = "https://westus2.cognitiveservices.azure.com/translator/text/batch"
)

// BaseClient is the base client for Translationbatch.
type BaseClient struct {
	autorest.Client
	BaseURI string
}

// New creates an instance of the BaseClient client.
func New() BaseClient {
	return NewWithBaseURI(DefaultBaseURI)
}

// NewWithBaseURI creates an instance of the BaseClient client using a custom endpoint.  Use this when interacting with
// an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
func NewWithBaseURI(baseURI string) BaseClient {
	return BaseClient{
		Client:  autorest.NewClientWithUserAgent(UserAgent()),
		BaseURI: baseURI,
	}
}

// BatchDocumentsSubmit submit a batch request to the document translation service.
//
// Each request can consists of multiple inputs.
// Each input will contains both a source and destination container for source and target language pair.
//
// The prefix and suffix filter (if supplied) will be used to filter the folders.
// The prefix will be applied to the subpath after the container name
//
// Glossaries / Translation memory can be supplied and will be applied when the document is being translated.
// If the glossary is invalid or unreachable during translation time.  An error will be indicated in the document
// status.
//
// If the file with the same name already exists in the destination, it will be overwritten.
// TargetUrl for each target language needs to be unique.
// Parameters:
// body - request details
func (client BaseClient) BatchDocumentsSubmit(ctx context.Context, body *JobSubmissionBatchRequest) (result ErrorResponseV2, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.BatchDocumentsSubmit")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: body,
			Constraints: []validation.Constraint{{Target: "body", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "body.Inputs", Name: validation.Null, Rule: true, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("translationbatch.BaseClient", "BatchDocumentsSubmit", err.Error())
	}

	req, err := client.BatchDocumentsSubmitPreparer(ctx, body)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "BatchDocumentsSubmit", nil, "Failure preparing request")
		return
	}

	resp, err := client.BatchDocumentsSubmitSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "BatchDocumentsSubmit", resp, "Failure sending request")
		return
	}

	result, err = client.BatchDocumentsSubmitResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "BatchDocumentsSubmit", resp, "Failure responding to request")
	}

	return
}

// BatchDocumentsSubmitPreparer prepares the BatchDocumentsSubmit request.
func (client BaseClient) BatchDocumentsSubmitPreparer(ctx context.Context, body *JobSubmissionBatchRequest) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/v1.0-preview.1/documents"))
	if body != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(body))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// BatchDocumentsSubmitSender sends the BatchDocumentsSubmit request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) BatchDocumentsSubmitSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// BatchDocumentsSubmitResponder handles the response to the BatchDocumentsSubmit request. The method always
// closes the http.Response Body.
func (client BaseClient) BatchDocumentsSubmitResponder(resp *http.Response) (result ErrorResponseV2, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusTooManyRequests, http.StatusInternalServerError, http.StatusServiceUnavailable),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CancelOperation cancel a currently processing or queued operation.
// An operation will not be cancelled if it is already completed or failed or cancelling.  A bad request will be
// returned.
// All documents that have completed translation will not be cancelled and will be charged.
// All pending documents will be cancelled if possible.
// Parameters:
// ID - format - uuid.  The operation-id
func (client BaseClient) CancelOperation(ctx context.Context, ID uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CancelOperation")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.CancelOperationPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "CancelOperation", nil, "Failure preparing request")
		return
	}

	resp, err := client.CancelOperationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "CancelOperation", resp, "Failure sending request")
		return
	}

	result, err = client.CancelOperationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "CancelOperation", resp, "Failure responding to request")
	}

	return
}

// CancelOperationPreparer prepares the CancelOperation request.
func (client BaseClient) CancelOperationPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/v1.0-preview.1/operations/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CancelOperationSender sends the CancelOperation request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CancelOperationSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CancelOperationResponder handles the response to the CancelOperation request. The method always
// closes the http.Response Body.
func (client BaseClient) CancelOperationResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusNotFound, http.StatusTooManyRequests, http.StatusInternalServerError, http.StatusServiceUnavailable),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDetailedDocumentStatus returns the status of the list of documents translation operation status in the
// subscription
//
// The documents are sorted by the document Id
//
// If the number of documents exceed our paging limit, server side paging will be used.
// Paginated responses will indicate a partial result by including a continuation token in the response. The absence of
// a continuation token means that no additional pages are available.
//
// Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the
// collection.
// The server will honor the values specified by the client; however, clients MUST be prepared to handle responses that
// contain a different page size or contain a continuation token.
// When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
// Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it
// instead of just ignoring the query options. This will avoid the risk of the client making assumptions about the data
// returned.
// Parameters:
// top - take the $top entries in the collection
// When both $top and $skip are supplied, $skip is applied first
// skip - skip the $skip entries in the collection
// When both $top and $skip are supplied, $skip is applied first
func (client BaseClient) GetDetailedDocumentStatus(ctx context.Context, top *int32, skip *int32) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetDetailedDocumentStatus")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: top,
			Constraints: []validation.Constraint{{Target: "top", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "top", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil},
					{Target: "top", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil},
				}}}},
		{TargetValue: skip,
			Constraints: []validation.Constraint{{Target: "skip", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "skip", Name: validation.InclusiveMaximum, Rule: int64(2147483647), Chain: nil},
					{Target: "skip", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("translationbatch.BaseClient", "GetDetailedDocumentStatus", err.Error())
	}

	req, err := client.GetDetailedDocumentStatusPreparer(ctx, top, skip)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetDetailedDocumentStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDetailedDocumentStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetDetailedDocumentStatus", resp, "Failure sending request")
		return
	}

	result, err = client.GetDetailedDocumentStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetDetailedDocumentStatus", resp, "Failure responding to request")
	}

	return
}

// GetDetailedDocumentStatusPreparer prepares the GetDetailedDocumentStatus request.
func (client BaseClient) GetDetailedDocumentStatusPreparer(ctx context.Context, top *int32, skip *int32) (*http.Request, error) {
	queryParameters := map[string]interface{}{}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	} else {
		queryParameters["$top"] = autorest.Encode("query", 50)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	} else {
		queryParameters["$skip"] = autorest.Encode("query", 0)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/v1.0-preview.1/documents"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDetailedDocumentStatusSender sends the GetDetailedDocumentStatus request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDetailedDocumentStatusSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDetailedDocumentStatusResponder handles the response to the GetDetailedDocumentStatus request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDetailedDocumentStatusResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusNotFound, http.StatusTooManyRequests, http.StatusInternalServerError, http.StatusServiceUnavailable),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDetailedDocumentStatusForAGivenOperationID returns the status of the list of documents translation operation by a
// given operation id.
//
// The documents are sorted by the document Id
//
// If the number of documents exceed our paging limit, server side paging will be used.
// Paginated responses will indicate a partial result by including a continuation token in the response. The absence of
// a continuation token means that no additional pages are available.
//
// Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the
// collection.
// The server will honor the values specified by the client; however, clients MUST be prepared to handle responses that
// contain a different page size or contain a continuation token.
// When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
// Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it
// instead of just ignoring the query options. This will avoid the risk of the client making assumptions about the data
// returned.
// Parameters:
// ID - format - uuid.  The operation id
// top - take the $top entries in the collection
// When both $top and $skip are supplied, $skip is applied first
// skip - skip the $skip entries in the collection
// When both $top and $skip are supplied, $skip is applied first
func (client BaseClient) GetDetailedDocumentStatusForAGivenOperationID(ctx context.Context, ID uuid.UUID, top *int32, skip *int32) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetDetailedDocumentStatusForAGivenOperationID")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: top,
			Constraints: []validation.Constraint{{Target: "top", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "top", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil},
					{Target: "top", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil},
				}}}},
		{TargetValue: skip,
			Constraints: []validation.Constraint{{Target: "skip", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "skip", Name: validation.InclusiveMaximum, Rule: int64(2147483647), Chain: nil},
					{Target: "skip", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("translationbatch.BaseClient", "GetDetailedDocumentStatusForAGivenOperationID", err.Error())
	}

	req, err := client.GetDetailedDocumentStatusForAGivenOperationIDPreparer(ctx, ID, top, skip)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetDetailedDocumentStatusForAGivenOperationID", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDetailedDocumentStatusForAGivenOperationIDSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetDetailedDocumentStatusForAGivenOperationID", resp, "Failure sending request")
		return
	}

	result, err = client.GetDetailedDocumentStatusForAGivenOperationIDResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetDetailedDocumentStatusForAGivenOperationID", resp, "Failure responding to request")
	}

	return
}

// GetDetailedDocumentStatusForAGivenOperationIDPreparer prepares the GetDetailedDocumentStatusForAGivenOperationID request.
func (client BaseClient) GetDetailedDocumentStatusForAGivenOperationIDPreparer(ctx context.Context, ID uuid.UUID, top *int32, skip *int32) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	queryParameters := map[string]interface{}{}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	} else {
		queryParameters["$top"] = autorest.Encode("query", 50)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	} else {
		queryParameters["$skip"] = autorest.Encode("query", 0)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/v1.0-preview.1/operations/{id}/documents", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDetailedDocumentStatusForAGivenOperationIDSender sends the GetDetailedDocumentStatusForAGivenOperationID request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDetailedDocumentStatusForAGivenOperationIDSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDetailedDocumentStatusForAGivenOperationIDResponder handles the response to the GetDetailedDocumentStatusForAGivenOperationID request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDetailedDocumentStatusForAGivenOperationIDResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusNotFound, http.StatusTooManyRequests, http.StatusInternalServerError, http.StatusServiceUnavailable),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDocumentFormats the list of supported document formats supported by our service.
// The list will include the common file extension used and supported as well as the content-type if using the upload
// API.
func (client BaseClient) GetDocumentFormats(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetDocumentFormats")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetDocumentFormatsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetDocumentFormats", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDocumentFormatsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetDocumentFormats", resp, "Failure sending request")
		return
	}

	result, err = client.GetDocumentFormatsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetDocumentFormats", resp, "Failure responding to request")
	}

	return
}

// GetDocumentFormatsPreparer prepares the GetDocumentFormats request.
func (client BaseClient) GetDocumentFormatsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/v1.0-preview.1/documents/formats"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDocumentFormatsSender sends the GetDocumentFormats request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDocumentFormatsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDocumentFormatsResponder handles the response to the GetDocumentFormats request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDocumentFormatsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusTooManyRequests, http.StatusInternalServerError, http.StatusServiceUnavailable),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDocumentStatus returns the status of the translation of the document.
// Parameters:
// documentID - format - int64.  The document id
func (client BaseClient) GetDocumentStatus(ctx context.Context, documentID int64) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetDocumentStatus")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetDocumentStatusPreparer(ctx, documentID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetDocumentStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDocumentStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetDocumentStatus", resp, "Failure sending request")
		return
	}

	result, err = client.GetDocumentStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetDocumentStatus", resp, "Failure responding to request")
	}

	return
}

// GetDocumentStatusPreparer prepares the GetDocumentStatus request.
func (client BaseClient) GetDocumentStatusPreparer(ctx context.Context, documentID int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"documentId": autorest.Encode("path", documentID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/v1.0-preview.1/documents/{documentId}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDocumentStatusSender sends the GetDocumentStatus request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDocumentStatusSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDocumentStatusResponder handles the response to the GetDocumentStatus request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDocumentStatusResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusNotFound, http.StatusTooManyRequests, http.StatusInternalServerError, http.StatusServiceUnavailable),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetGlossaryFormats the list of supported glossary formats supported by our service.
// The list will include the common file extension used.
func (client BaseClient) GetGlossaryFormats(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetGlossaryFormats")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetGlossaryFormatsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetGlossaryFormats", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetGlossaryFormatsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetGlossaryFormats", resp, "Failure sending request")
		return
	}

	result, err = client.GetGlossaryFormatsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetGlossaryFormats", resp, "Failure responding to request")
	}

	return
}

// GetGlossaryFormatsPreparer prepares the GetGlossaryFormats request.
func (client BaseClient) GetGlossaryFormatsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/v1.0-preview.1/glossaries/formats"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetGlossaryFormatsSender sends the GetGlossaryFormats request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetGlossaryFormatsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetGlossaryFormatsResponder handles the response to the GetGlossaryFormats request. The method always
// closes the http.Response Body.
func (client BaseClient) GetGlossaryFormatsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusTooManyRequests, http.StatusInternalServerError, http.StatusServiceUnavailable),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetOperationStatus returns the status of the translation batch operation.
// The status will include the overall job status as well as a summary of the current progress of all the documents
// being translated.
// Parameters:
// ID - format - uuid.  The operation id
func (client BaseClient) GetOperationStatus(ctx context.Context, ID uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetOperationStatus")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetOperationStatusPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetOperationStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetOperationStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetOperationStatus", resp, "Failure sending request")
		return
	}

	result, err = client.GetOperationStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetOperationStatus", resp, "Failure responding to request")
	}

	return
}

// GetOperationStatusPreparer prepares the GetOperationStatus request.
func (client BaseClient) GetOperationStatusPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/v1.0-preview.1/operations/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetOperationStatusSender sends the GetOperationStatus request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetOperationStatusSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetOperationStatusResponder handles the response to the GetOperationStatus request. The method always
// closes the http.Response Body.
func (client BaseClient) GetOperationStatusResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusNotFound, http.StatusTooManyRequests, http.StatusInternalServerError, http.StatusServiceUnavailable),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetStatusOfOperationList returns the list of status of the translation batch operation.
// The list will consist only of the batch request submitted by the user (based on their subscription)
//
// The operation status are sorted by the operation Id
//
// If the number of operations exceed our paging limit, server side paging will be used.
// Paginated responses will indicate a partial result by including a continuation token in the response. The absence of
// a continuation token means that no additional pages are available.
//
// Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the
// collection.
// The server will honor the values specified by the client; however, clients MUST be prepared to handle responses that
// contain a different page size or contain a continuation token.
// When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
// Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it
// instead of just ignoring the query options. This will avoid the risk of the client making assumptions about the data
// returned.
// Parameters:
// top - take the $top entries in the collection
// When both $top and $skip are supplied, $skip is applied first
// skip - skip the $skip entries in the collection
// When both $top and $skip are supplied, $skip is applied first
func (client BaseClient) GetStatusOfOperationList(ctx context.Context, top *int32, skip *int32) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetStatusOfOperationList")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: top,
			Constraints: []validation.Constraint{{Target: "top", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "top", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil},
					{Target: "top", Name: validation.InclusiveMinimum, Rule: int64(1), Chain: nil},
				}}}},
		{TargetValue: skip,
			Constraints: []validation.Constraint{{Target: "skip", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "skip", Name: validation.InclusiveMaximum, Rule: int64(2147483647), Chain: nil},
					{Target: "skip", Name: validation.InclusiveMinimum, Rule: int64(0), Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("translationbatch.BaseClient", "GetStatusOfOperationList", err.Error())
	}

	req, err := client.GetStatusOfOperationListPreparer(ctx, top, skip)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetStatusOfOperationList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetStatusOfOperationListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetStatusOfOperationList", resp, "Failure sending request")
		return
	}

	result, err = client.GetStatusOfOperationListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetStatusOfOperationList", resp, "Failure responding to request")
	}

	return
}

// GetStatusOfOperationListPreparer prepares the GetStatusOfOperationList request.
func (client BaseClient) GetStatusOfOperationListPreparer(ctx context.Context, top *int32, skip *int32) (*http.Request, error) {
	queryParameters := map[string]interface{}{}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	} else {
		queryParameters["$top"] = autorest.Encode("query", 50)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	} else {
		queryParameters["$skip"] = autorest.Encode("query", 0)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/v1.0-preview.1/operations"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetStatusOfOperationListSender sends the GetStatusOfOperationList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetStatusOfOperationListSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetStatusOfOperationListResponder handles the response to the GetStatusOfOperationList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetStatusOfOperationListResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusTooManyRequests, http.StatusInternalServerError, http.StatusServiceUnavailable),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetStorageSourcesThatWeCurrentlySupport the list of storage sources supported by our service.
func (client BaseClient) GetStorageSourcesThatWeCurrentlySupport(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetStorageSourcesThatWeCurrentlySupport")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetStorageSourcesThatWeCurrentlySupportPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetStorageSourcesThatWeCurrentlySupport", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetStorageSourcesThatWeCurrentlySupportSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetStorageSourcesThatWeCurrentlySupport", resp, "Failure sending request")
		return
	}

	result, err = client.GetStorageSourcesThatWeCurrentlySupportResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "GetStorageSourcesThatWeCurrentlySupport", resp, "Failure responding to request")
	}

	return
}

// GetStorageSourcesThatWeCurrentlySupportPreparer prepares the GetStorageSourcesThatWeCurrentlySupport request.
func (client BaseClient) GetStorageSourcesThatWeCurrentlySupportPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/v1.0-preview.1/storagesources"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetStorageSourcesThatWeCurrentlySupportSender sends the GetStorageSourcesThatWeCurrentlySupport request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetStorageSourcesThatWeCurrentlySupportSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetStorageSourcesThatWeCurrentlySupportResponder handles the response to the GetStorageSourcesThatWeCurrentlySupport request. The method always
// closes the http.Response Body.
func (client BaseClient) GetStorageSourcesThatWeCurrentlySupportResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusTooManyRequests, http.StatusInternalServerError, http.StatusServiceUnavailable),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// SingleDocumentUpload use content-type header to denote the file format type
//
// Example:
// text/plain for .txt files
// application/vnd.openxmlformats-officedocument.wordprocessingml.document for .docx files
// application/pdf for .pdf files
// Parameters:
// targetLanguage - the language code for the documents to translate to
// sourceLanguage - the language code of the original document
// If none is specified, we will perform auto detect on the document
// category - category for the translation system (Optional)
func (client BaseClient) SingleDocumentUpload(ctx context.Context, targetLanguage string, sourceLanguage string, category string) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.SingleDocumentUpload")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.SingleDocumentUploadPreparer(ctx, targetLanguage, sourceLanguage, category)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "SingleDocumentUpload", nil, "Failure preparing request")
		return
	}

	resp, err := client.SingleDocumentUploadSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "SingleDocumentUpload", resp, "Failure sending request")
		return
	}

	result, err = client.SingleDocumentUploadResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "translationbatch.BaseClient", "SingleDocumentUpload", resp, "Failure responding to request")
	}

	return
}

// SingleDocumentUploadPreparer prepares the SingleDocumentUpload request.
func (client BaseClient) SingleDocumentUploadPreparer(ctx context.Context, targetLanguage string, sourceLanguage string, category string) (*http.Request, error) {
	queryParameters := map[string]interface{}{
		"TargetLanguage": autorest.Encode("query", targetLanguage),
	}
	if len(sourceLanguage) > 0 {
		queryParameters["SourceLanguage"] = autorest.Encode("query", sourceLanguage)
	}
	if len(category) > 0 {
		queryParameters["Category"] = autorest.Encode("query", category)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/v1.0-preview.1/documents/upload"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SingleDocumentUploadSender sends the SingleDocumentUpload request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) SingleDocumentUploadSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// SingleDocumentUploadResponder handles the response to the SingleDocumentUpload request. The method always
// closes the http.Response Body.
func (client BaseClient) SingleDocumentUploadResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated, http.StatusBadRequest, http.StatusUnauthorized, http.StatusTooManyRequests, http.StatusInternalServerError, http.StatusServiceUnavailable),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
