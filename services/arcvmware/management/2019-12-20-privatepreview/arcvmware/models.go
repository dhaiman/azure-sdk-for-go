package arcvmware

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/arcvmware/management/2019-12-20-privatepreview/arcvmware"

// ArcZone define the arcZone.
type ArcZone struct {
	autorest.Response `json:"-"`
	// ArcZoneProperties - Resource properties.
	*ArcZoneProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Identity - READ-ONLY; Gets or sets the identity.
	Identity *string `json:"identity,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ArcZone.
func (az ArcZone) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if az.ArcZoneProperties != nil {
		objectMap["properties"] = az.ArcZoneProperties
	}
	if az.Location != nil {
		objectMap["location"] = az.Location
	}
	if az.Tags != nil {
		objectMap["tags"] = az.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ArcZone struct.
func (az *ArcZone) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var arcZoneProperties ArcZoneProperties
				err = json.Unmarshal(*v, &arcZoneProperties)
				if err != nil {
					return err
				}
				az.ArcZoneProperties = &arcZoneProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				az.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				az.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				az.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				az.ID = &ID
			}
		case "identity":
			if v != nil {
				var identity string
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				az.Identity = &identity
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				az.Type = &typeVar
			}
		}
	}

	return nil
}

// ArcZoneProperties defines the resource properties.
type ArcZoneProperties struct {
	// UUID - READ-ONLY; Gets or sets a unique identifier for this zone.
	UUID *string `json:"uuid,omitempty"`
	// HostID - Gets or Sets the Arm Id of the cluster resource (AKS Cluster Id).
	HostID *string `json:"hostId,omitempty"`
	// Namespace - READ-ONLY; Gets the K8s namespace for the arc zone.
	Namespace *string `json:"namespace,omitempty"`
	// Authentication - Credentials to authenticate to k8s.
	Authentication *KubernetesAuthentication `json:"authentication,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ArcZoneProperties.
func (azp ArcZoneProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if azp.HostID != nil {
		objectMap["hostId"] = azp.HostID
	}
	if azp.Authentication != nil {
		objectMap["authentication"] = azp.Authentication
	}
	return json.Marshal(objectMap)
}

// ArcZonesCreateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type ArcZonesCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ArcZonesCreateFuture) Result(client ArcZonesClient) (az ArcZone, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.ArcZonesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.ArcZonesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if az.Response.Response, err = future.GetResult(sender); err == nil && az.Response.Response.StatusCode != http.StatusNoContent {
		az, err = client.CreateResponder(az.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "arcvmware.ArcZonesCreateFuture", "Result", az.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ArcZonesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type ArcZonesDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ArcZonesDeleteFuture) Result(client ArcZonesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.ArcZonesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.ArcZonesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ArcZonesList list of ArcZones.
type ArcZonesList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of ArcZones.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of ArcZones
	Value *[]ArcZone `json:"value,omitempty"`
}

// ArcZonesListIterator provides access to a complete listing of ArcZone values.
type ArcZonesListIterator struct {
	i    int
	page ArcZonesListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ArcZonesListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArcZonesListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ArcZonesListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ArcZonesListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ArcZonesListIterator) Response() ArcZonesList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ArcZonesListIterator) Value() ArcZone {
	if !iter.page.NotDone() {
		return ArcZone{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ArcZonesListIterator type.
func NewArcZonesListIterator(page ArcZonesListPage) ArcZonesListIterator {
	return ArcZonesListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (azl ArcZonesList) IsEmpty() bool {
	return azl.Value == nil || len(*azl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (azl ArcZonesList) hasNextLink() bool {
	return azl.NextLink != nil && len(*azl.NextLink) != 0
}

// arcZonesListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (azl ArcZonesList) arcZonesListPreparer(ctx context.Context) (*http.Request, error) {
	if !azl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(azl.NextLink)))
}

// ArcZonesListPage contains a page of ArcZone values.
type ArcZonesListPage struct {
	fn  func(context.Context, ArcZonesList) (ArcZonesList, error)
	azl ArcZonesList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ArcZonesListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ArcZonesListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.azl)
		if err != nil {
			return err
		}
		page.azl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ArcZonesListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ArcZonesListPage) NotDone() bool {
	return !page.azl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ArcZonesListPage) Response() ArcZonesList {
	return page.azl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ArcZonesListPage) Values() []ArcZone {
	if page.azl.IsEmpty() {
		return nil
	}
	return *page.azl.Value
}

// Creates a new instance of the ArcZonesListPage type.
func NewArcZonesListPage(getNextPage func(context.Context, ArcZonesList) (ArcZonesList, error)) ArcZonesListPage {
	return ArcZonesListPage{fn: getNextPage}
}

// Condition condition defines an extension to status.
type Condition struct {
	// Type - READ-ONLY; Type of condition.
	Type *string `json:"type,omitempty"`
	// Status - READ-ONLY; Status of the condition.
	Status *string `json:"status,omitempty"`
	// Reason - READ-ONLY; The reason for the condition's status.
	Reason *string `json:"reason,omitempty"`
	// Message - READ-ONLY; A human readable message indicating details about the status.
	Message *string `json:"message,omitempty"`
	// Severity - READ-ONLY; Severity with which to treat failures of this type of condition.
	Severity *string `json:"severity,omitempty"`
}

// ErrorDefinition error definition.
type ErrorDefinition struct {
	// Code - READ-ONLY; Service specific error code which serves as the substatus for the HTTP error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Description of the error.
	Message *string `json:"message,omitempty"`
	// Details - READ-ONLY; Internal error details.
	Details *[]ErrorDefinition `json:"details,omitempty"`
}

// ErrorResponse error response.
type ErrorResponse struct {
	// Error - The error details.
	Error *ErrorDefinition `json:"error,omitempty"`
}

// HardwareProfile defines the resource properties.
type HardwareProfile struct {
	// MemorySizeMB - Gets or sets memory size in MBs for the vm.
	MemorySizeMB *int32 `json:"memorySizeMB,omitempty"`
	// NumCPUs - Gets or sets the number of vCPUs for the vm.
	NumCPUs *int32 `json:"numCPUs,omitempty"`
	// NumCoresPerSocket - Gets or sets the number of cores per socket for the vm. Defaults to 1 if unspecified.
	NumCoresPerSocket *int32 `json:"numCoresPerSocket,omitempty"`
	// CPUHotAddEnabled - READ-ONLY; Gets or sets a value indicating whether virtual processors can be added while this virtual machine is running.
	CPUHotAddEnabled *bool `json:"cpuHotAddEnabled,omitempty"`
	// CPUHotRemoveEnabled - READ-ONLY; Gets or sets a value indicating whether virtual processors can be removed while this virtual machine is running.
	CPUHotRemoveEnabled *bool `json:"cpuHotRemoveEnabled,omitempty"`
	// MemoryHotAddEnabled - READ-ONLY; Gets or sets a value indicating whether memory can be added while this virtual machine is running.
	MemoryHotAddEnabled *bool `json:"memoryHotAddEnabled,omitempty"`
}

// MarshalJSON is the custom marshaler for HardwareProfile.
func (hp HardwareProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hp.MemorySizeMB != nil {
		objectMap["memorySizeMB"] = hp.MemorySizeMB
	}
	if hp.NumCPUs != nil {
		objectMap["numCPUs"] = hp.NumCPUs
	}
	if hp.NumCoresPerSocket != nil {
		objectMap["numCoresPerSocket"] = hp.NumCoresPerSocket
	}
	return json.Marshal(objectMap)
}

// KubernetesAuthentication defines the kubernetes authentication class.
type KubernetesAuthentication struct {
	// Type - Gets or sets kubernetes authentication type. Possible values include: 'KubeConfig', 'ListCredential'
	Type Type `json:"type,omitempty"`
	// Value - Gets or sets kubernetes authentication value.
	Value *string `json:"value,omitempty"`
}

// KubernetesSecret a k8s secret identifier.
type KubernetesSecret struct {
	// SecretName - Gets or sets the name of the secret in Kubernetes.
	SecretName *string `json:"secretName,omitempty"`
	// SecretNamespace - Gets or sets a namespace in which the specified secret exists.
	SecretNamespace *string `json:"secretNamespace,omitempty"`
}

// NetworkInterface network Interface model
type NetworkInterface struct {
	// Name - Gets or sets the name of the network interface.
	Name *string `json:"name,omitempty"`
	// Label - READ-ONLY; Gets or sets the label of the virtual network in vCenter that the nic is connected to.
	Label *string `json:"label,omitempty"`
	// IPAddresses - READ-ONLY; Gets or sets the nic ip addresses.
	IPAddresses *[]string `json:"ipAddresses,omitempty"`
	// MacAddress - READ-ONLY; Gets or sets the NIC MAC address.
	MacAddress *string `json:"macAddress,omitempty"`
	// NetworkID - Gets or sets the ARM Id of the network resource to connect the virtual machine.
	NetworkID *string `json:"networkId,omitempty"`
	// NicType - NIC type. Possible values include: 'Vmxnet3', 'Vmxnet2', 'Vmxnet', 'E1000', 'E1000e', 'Pcnet32'
	NicType NICType `json:"nicType,omitempty"`
	// NicID - READ-ONLY; Gets or sets the network interface Id.
	NicID *string `json:"nicId,omitempty"`
	// NicName - READ-ONLY; Gets or sets the network interface name.
	NicName *string `json:"nicName,omitempty"`
	// PowerOnBoot - Gets or sets the power on boot. Possible values include: 'PowerOnBoot1Enabled', 'PowerOnBoot1Disabled'
	PowerOnBoot PowerOnBoot1 `json:"powerOnBoot,omitempty"`
	// NetworkMoRefID - READ-ONLY; Gets or sets the vCenter MoRef (Managed Object Reference) ID of the virtual network
	// that the nic is connected to.
	NetworkMoRefID *string `json:"networkMoRefId,omitempty"`
	// NetworkName - READ-ONLY; Gets or sets the name of the virtual network in vCenter that the nic is connected to.
	NetworkName *string `json:"networkName,omitempty"`
	// NetworkUUID - READ-ONLY; Gets or sets a unique identifier for the network.
	NetworkUUID *string `json:"networkUuid,omitempty"`
	// DeviceKey - Gets or sets the device key value.
	DeviceKey *int32 `json:"deviceKey,omitempty"`
	// IPSettings - Gets or sets the ipsettings.
	IPSettings *NicIPSettings `json:"ipSettings,omitempty"`
}

// MarshalJSON is the custom marshaler for NetworkInterface.
func (ni NetworkInterface) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ni.Name != nil {
		objectMap["name"] = ni.Name
	}
	if ni.NetworkID != nil {
		objectMap["networkId"] = ni.NetworkID
	}
	if ni.NicType != "" {
		objectMap["nicType"] = ni.NicType
	}
	if ni.PowerOnBoot != "" {
		objectMap["powerOnBoot"] = ni.PowerOnBoot
	}
	if ni.DeviceKey != nil {
		objectMap["deviceKey"] = ni.DeviceKey
	}
	if ni.IPSettings != nil {
		objectMap["ipSettings"] = ni.IPSettings
	}
	return json.Marshal(objectMap)
}

// NetworkInterfaceUpdate defines the network interface update.
type NetworkInterfaceUpdate struct {
	// Name - Gets or sets the name of the network interface.
	Name *string `json:"name,omitempty"`
	// NetworkID - Gets or sets the ARM Id of the network resource to connect the virtual machine.
	NetworkID *string `json:"networkId,omitempty"`
	// NicType - NIC type. Possible values include: 'Vmxnet3', 'Vmxnet2', 'Vmxnet', 'E1000', 'E1000e', 'Pcnet32'
	NicType NICType `json:"nicType,omitempty"`
	// PowerOnBoot - Gets or sets the power on boot. Possible values include: 'Enabled', 'Disabled'
	PowerOnBoot PowerOnBoot `json:"powerOnBoot,omitempty"`
	// DeviceKey - Gets or sets the device key value.
	DeviceKey *int32 `json:"deviceKey,omitempty"`
}

// NetworkProfile defines the resource properties.
type NetworkProfile struct {
	// NetworkInterfaces - Gets or sets the list of network interfaces associated with the virtual machine.
	NetworkInterfaces *[]NetworkInterface `json:"networkInterfaces,omitempty"`
}

// NetworkProfileUpdate defines the update resource properties.
type NetworkProfileUpdate struct {
	// NetworkInterfaces - Gets or sets the list of network interfaces associated with the virtual machine.
	NetworkInterfaces *[]NetworkInterfaceUpdate `json:"networkInterfaces,omitempty"`
}

// NicIPAddressSettings IP address information for a virtual network adapter reported by the fabric.
type NicIPAddressSettings struct {
	// AllocationMethod - READ-ONLY; Gets the ip address allocation method.
	AllocationMethod *string `json:"allocationMethod,omitempty"`
	// IPAddress - READ-ONLY; Gets the ip address for the nic.
	IPAddress *string `json:"ipAddress,omitempty"`
	// SubnetMask - READ-ONLY; Gets the mask.
	SubnetMask *string `json:"subnetMask,omitempty"`
}

// NicIPSettings defines the network interface ip settings.
type NicIPSettings struct {
	// AllocationMethod - Gets or sets the nic allocation method. Possible values include: 'Unset', 'Dynamic', 'Static', 'Linklayer', 'Random', 'Other'
	AllocationMethod AllocationMethod `json:"allocationMethod,omitempty"`
	// DNSServers - READ-ONLY; Gets or sets the dns servers.
	DNSServers *[]string `json:"dnsServers,omitempty"`
	// Gateway - Gets or sets the gateway.
	Gateway *[]string `json:"gateway,omitempty"`
	// IPAddress - Gets or sets the ip address for the nic.
	IPAddress *string `json:"ipAddress,omitempty"`
	// SubnetMask - Gets or sets the mask.
	SubnetMask *string `json:"subnetMask,omitempty"`
	// PrimaryWinsServer - READ-ONLY; Gets or sets the primary server.
	PrimaryWinsServer *string `json:"primaryWinsServer,omitempty"`
	// SecondaryWinsServer - READ-ONLY; Gets or sets the secondary server.
	SecondaryWinsServer *string `json:"secondaryWinsServer,omitempty"`
	// IPAddressInfo - READ-ONLY; Gets or sets the IP address information being reported for this NIC. This contains the same IPv4 information above plus IPV6 information.
	IPAddressInfo *[]NicIPAddressSettings `json:"ipAddressInfo,omitempty"`
}

// MarshalJSON is the custom marshaler for NicIPSettings.
func (nis NicIPSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if nis.AllocationMethod != "" {
		objectMap["allocationMethod"] = nis.AllocationMethod
	}
	if nis.Gateway != nil {
		objectMap["gateway"] = nis.Gateway
	}
	if nis.IPAddress != nil {
		objectMap["ipAddress"] = nis.IPAddress
	}
	if nis.SubnetMask != nil {
		objectMap["subnetMask"] = nis.SubnetMask
	}
	return json.Marshal(objectMap)
}

// Operation operation provided by provider
type Operation struct {
	// Name - Name of the operation
	Name *string `json:"name,omitempty"`
	// Display - Properties of the operation
	Display *OperationDisplay `json:"display,omitempty"`
}

// OperationDisplay properties of the operation
type OperationDisplay struct {
	// Provider - Provider name
	Provider *string `json:"provider,omitempty"`
	// Resource - Resource name
	Resource *string `json:"resource,omitempty"`
	// Operation - Operation name
	Operation *string `json:"operation,omitempty"`
	// Description - Description of the operation
	Description *string `json:"description,omitempty"`
}

// OperationsList lists the operations available.
type OperationsList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of operations.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of operations
	Value *[]Operation `json:"value,omitempty"`
}

// OperationsListIterator provides access to a complete listing of Operation values.
type OperationsListIterator struct {
	i    int
	page OperationsListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationsListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationsListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationsListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationsListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationsListIterator) Response() OperationsList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationsListIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationsListIterator type.
func NewOperationsListIterator(page OperationsListPage) OperationsListIterator {
	return OperationsListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ol OperationsList) IsEmpty() bool {
	return ol.Value == nil || len(*ol.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ol OperationsList) hasNextLink() bool {
	return ol.NextLink != nil && len(*ol.NextLink) != 0
}

// operationsListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ol OperationsList) operationsListPreparer(ctx context.Context) (*http.Request, error) {
	if !ol.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ol.NextLink)))
}

// OperationsListPage contains a page of Operation values.
type OperationsListPage struct {
	fn func(context.Context, OperationsList) (OperationsList, error)
	ol OperationsList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationsListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationsListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ol)
		if err != nil {
			return err
		}
		page.ol = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationsListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationsListPage) NotDone() bool {
	return !page.ol.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationsListPage) Response() OperationsList {
	return page.ol
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationsListPage) Values() []Operation {
	if page.ol.IsEmpty() {
		return nil
	}
	return *page.ol.Value
}

// Creates a new instance of the OperationsListPage type.
func NewOperationsListPage(getNextPage func(context.Context, OperationsList) (OperationsList, error)) OperationsListPage {
	return OperationsListPage{fn: getNextPage}
}

// OsProfile defines the resource properties.
type OsProfile struct {
	// ComputerName - READ-ONLY; Gets or sets computer name.
	ComputerName *string `json:"computerName,omitempty"`
	// AdminUsername - Gets or sets administrator username.
	AdminUsername *string `json:"adminUsername,omitempty"`
	// AdminPassword - Gets or sets administrator password.
	AdminPassword *string `json:"adminPassword,omitempty"`
	// OsType - READ-ONLY; Gets or sets the type of the os. Possible values include: 'OsTypeWindows', 'OsTypeLinux', 'OsTypeOther'
	OsType OsType `json:"osType,omitempty"`
	// OsName - READ-ONLY; Gets or sets os name.
	OsName *string `json:"osName,omitempty"`
	// ToolsRunningStatus - READ-ONLY; Gets or sets the current running status of VMware Tools running in the guest operating system.
	ToolsRunningStatus *string `json:"toolsRunningStatus,omitempty"`
	// ToolsVersionStatus - READ-ONLY; Gets or sets the current version status of VMware Tools installed in the guest operating system.
	ToolsVersionStatus *string `json:"toolsVersionStatus,omitempty"`
	// ToolsVersion - READ-ONLY; Gets or sets the current version of VMware Tools.
	ToolsVersion *string `json:"toolsVersion,omitempty"`
}

// MarshalJSON is the custom marshaler for OsProfile.
func (op OsProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if op.AdminUsername != nil {
		objectMap["adminUsername"] = op.AdminUsername
	}
	if op.AdminPassword != nil {
		objectMap["adminPassword"] = op.AdminPassword
	}
	return json.Marshal(objectMap)
}

// ResourcePatch object containing updates for patch operations.
type ResourcePatch struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ResourcePatch.
func (rp ResourcePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rp.Tags != nil {
		objectMap["tags"] = rp.Tags
	}
	return json.Marshal(objectMap)
}

// ResourcePool define the resourcePool.
type ResourcePool struct {
	autorest.Response `json:"-"`
	// ResourcePoolProperties - Resource properties.
	*ResourcePoolProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Identity - READ-ONLY; Gets or sets the identity.
	Identity *string `json:"identity,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourcePool.
func (rp ResourcePool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rp.ResourcePoolProperties != nil {
		objectMap["properties"] = rp.ResourcePoolProperties
	}
	if rp.Location != nil {
		objectMap["location"] = rp.Location
	}
	if rp.Tags != nil {
		objectMap["tags"] = rp.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ResourcePool struct.
func (rp *ResourcePool) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var resourcePoolProperties ResourcePoolProperties
				err = json.Unmarshal(*v, &resourcePoolProperties)
				if err != nil {
					return err
				}
				rp.ResourcePoolProperties = &resourcePoolProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				rp.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				rp.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rp.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rp.ID = &ID
			}
		case "identity":
			if v != nil {
				var identity string
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				rp.Identity = &identity
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rp.Type = &typeVar
			}
		}
	}

	return nil
}

// ResourcePoolProperties defines the resource properties.
type ResourcePoolProperties struct {
	// UUID - READ-ONLY; Gets or sets a unique identifier for this resource.
	UUID *string `json:"uuid,omitempty"`
	// VCenterID - Gets or sets the ARM Id of the vCenter resource in which this resource pool resides.
	VCenterID *string `json:"vCenterId,omitempty"`
	// MoRefID - Gets or sets the vCenter MoRef (Managed Object Reference) ID for the resource pool.
	MoRefID *string `json:"moRefId,omitempty"`
	// ArcZoneID - Gets or sets the ARM Id of the arcZone of the vCenter.
	ArcZoneID *string `json:"arcZoneId,omitempty"`
	// MoName - READ-ONLY; Gets or sets the vCenter Managed Object name for the resource pool.
	MoName *string `json:"moName,omitempty"`
	// Status - READ-ONLY; Gets or sets the status of the resource.
	Status *string `json:"status,omitempty"`
	// CPUSharesLevel - READ-ONLY; Gets or sets CPUSharesLevel which specifies the CPU allocation level for this pool.
	// This property is used in relative allocation between resource consumers.
	CPUSharesLevel *string `json:"cpuSharesLevel,omitempty"`
	// CPUReservationMHz - READ-ONLY; Gets or sets CPUReservationMHz which specifies the CPU size in MHz that is guaranteed
	// to be available.
	CPUReservationMHz *int64 `json:"cpuReservationMHz,omitempty"`
	// CPULimitMHz - READ-ONLY; Gets or sets CPULimitMHz which specifies a CPU usage limit in MHz.
	// Utilization will not exceed this limit even if there are available resources.
	CPULimitMHz *int64 `json:"cpuLimitMHz,omitempty"`
	// MemSharesLevel - READ-ONLY; Gets or sets CPUSharesLevel which specifies the memory allocation level for this pool.
	// This property is used in relative allocation between resource consumers.
	MemSharesLevel *string `json:"memSharesLevel,omitempty"`
	// MemReservationMB - READ-ONLY; Gets or sets MemReservationMB which specifies the guaranteed available memory in
	// megabytes.
	MemReservationMB *int64 `json:"memReservationMB,omitempty"`
	// MemLimitMB - READ-ONLY; Gets or sets MemLimitMB specifies a memory usage limit in megabytes.
	// Utilization will not exceed the specified limit even if there are available resources.
	MemLimitMB *int64 `json:"memLimitMB,omitempty"`
	// CustomResourceName - READ-ONLY; Gets the name of the corresponding resource in Kubernetes.
	CustomResourceName *string `json:"customResourceName,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourcePoolProperties.
func (rpp ResourcePoolProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rpp.VCenterID != nil {
		objectMap["vCenterId"] = rpp.VCenterID
	}
	if rpp.MoRefID != nil {
		objectMap["moRefId"] = rpp.MoRefID
	}
	if rpp.ArcZoneID != nil {
		objectMap["arcZoneId"] = rpp.ArcZoneID
	}
	return json.Marshal(objectMap)
}

// ResourcePoolsCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ResourcePoolsCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ResourcePoolsCreateFuture) Result(client ResourcePoolsClient) (rp ResourcePool, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.ResourcePoolsCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.ResourcePoolsCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if rp.Response.Response, err = future.GetResult(sender); err == nil && rp.Response.Response.StatusCode != http.StatusNoContent {
		rp, err = client.CreateResponder(rp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "arcvmware.ResourcePoolsCreateFuture", "Result", rp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ResourcePoolsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ResourcePoolsDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ResourcePoolsDeleteFuture) Result(client ResourcePoolsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.ResourcePoolsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.ResourcePoolsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ResourcePoolsList list of ResourcePools.
type ResourcePoolsList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of ResourcePools.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of ResourcePools
	Value *[]ResourcePool `json:"value,omitempty"`
}

// ResourcePoolsListIterator provides access to a complete listing of ResourcePool values.
type ResourcePoolsListIterator struct {
	i    int
	page ResourcePoolsListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ResourcePoolsListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourcePoolsListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ResourcePoolsListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ResourcePoolsListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ResourcePoolsListIterator) Response() ResourcePoolsList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ResourcePoolsListIterator) Value() ResourcePool {
	if !iter.page.NotDone() {
		return ResourcePool{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ResourcePoolsListIterator type.
func NewResourcePoolsListIterator(page ResourcePoolsListPage) ResourcePoolsListIterator {
	return ResourcePoolsListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rpl ResourcePoolsList) IsEmpty() bool {
	return rpl.Value == nil || len(*rpl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rpl ResourcePoolsList) hasNextLink() bool {
	return rpl.NextLink != nil && len(*rpl.NextLink) != 0
}

// resourcePoolsListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rpl ResourcePoolsList) resourcePoolsListPreparer(ctx context.Context) (*http.Request, error) {
	if !rpl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rpl.NextLink)))
}

// ResourcePoolsListPage contains a page of ResourcePool values.
type ResourcePoolsListPage struct {
	fn  func(context.Context, ResourcePoolsList) (ResourcePoolsList, error)
	rpl ResourcePoolsList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ResourcePoolsListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourcePoolsListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rpl)
		if err != nil {
			return err
		}
		page.rpl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ResourcePoolsListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ResourcePoolsListPage) NotDone() bool {
	return !page.rpl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ResourcePoolsListPage) Response() ResourcePoolsList {
	return page.rpl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ResourcePoolsListPage) Values() []ResourcePool {
	if page.rpl.IsEmpty() {
		return nil
	}
	return *page.rpl.Value
}

// Creates a new instance of the ResourcePoolsListPage type.
func NewResourcePoolsListPage(getNextPage func(context.Context, ResourcePoolsList) (ResourcePoolsList, error)) ResourcePoolsListPage {
	return ResourcePoolsListPage{fn: getNextPage}
}

// StopVirtualMachineOptions defines the stop action properties.
type StopVirtualMachineOptions struct {
	// SkipShutdown - Gets or sets a value indicating whether to request non-graceful VM shutdown. True value for this flag indicates non-graceful shutdown whereas false indicates otherwise. Defaults to false. Possible values include: 'False', 'True'
	SkipShutdown SkipShutdown `json:"skipShutdown,omitempty"`
}

// StorageProfile defines the resource properties.
type StorageProfile struct {
	// Disks - Gets or sets the list of virtual disks associated with the virtual machine.
	Disks *[]VirtualDisk `json:"disks,omitempty"`
	// ScsiControllers - READ-ONLY; Gets or sets the list of virtual SCSI controllers associated with the virtual machine.
	ScsiControllers *[]VirtualSCSIController `json:"scsiControllers,omitempty"`
}

// MarshalJSON is the custom marshaler for StorageProfile.
func (sp StorageProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sp.Disks != nil {
		objectMap["disks"] = sp.Disks
	}
	return json.Marshal(objectMap)
}

// StorageProfileUpdate defines the resource update properties.
type StorageProfileUpdate struct {
	// Disks - Gets or sets the list of virtual disks associated with the virtual machine.
	Disks *[]VirtualDiskUpdate `json:"disks,omitempty"`
}

// VCenter define the vCenter.
type VCenter struct {
	autorest.Response `json:"-"`
	// VCenterProperties - Resource properties.
	*VCenterProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Identity - READ-ONLY; Gets or sets the identity.
	Identity *string `json:"identity,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for VCenter.
func (vc VCenter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vc.VCenterProperties != nil {
		objectMap["properties"] = vc.VCenterProperties
	}
	if vc.Location != nil {
		objectMap["location"] = vc.Location
	}
	if vc.Tags != nil {
		objectMap["tags"] = vc.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VCenter struct.
func (vc *VCenter) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vCenterProperties VCenterProperties
				err = json.Unmarshal(*v, &vCenterProperties)
				if err != nil {
					return err
				}
				vc.VCenterProperties = &vCenterProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vc.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vc.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vc.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vc.ID = &ID
			}
		case "identity":
			if v != nil {
				var identity string
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				vc.Identity = &identity
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vc.Type = &typeVar
			}
		}
	}

	return nil
}

// VCenterProperties defines the resource properties.
type VCenterProperties struct {
	// UUID - READ-ONLY; Gets or sets a unique identifier for this resource.
	UUID *string `json:"uuid,omitempty"`
	// Fqdn - Gets or sets the FQDN/IPAddress of the vCenter.
	Fqdn *string `json:"fqdn,omitempty"`
	// Port - Gets or sets the port of the vCenter.
	Port *int32 `json:"port,omitempty"`
	// ArcZoneID - Gets or sets the ARM Id of the arcZone of the vCenter.
	ArcZoneID *string `json:"arcZoneId,omitempty"`
	// Credentials - Credentials to connect to vcenter.
	Credentials *KubernetesSecret `json:"credentials,omitempty"`
	// Version - READ-ONLY; Gets or sets the version of the vCenter.
	Version *string `json:"version,omitempty"`
	// InstanceUUID - READ-ONLY; Gets or sets the instance UUID of the vCenter.
	InstanceUUID *string `json:"instanceUuid,omitempty"`
	// ConnectionStatus - READ-ONLY; Gets or sets the connection status to the vCenter.
	ConnectionStatus *string `json:"connectionStatus,omitempty"`
	// ErrorMessage - READ-ONLY; Gets or sets any error message if connection to vCenter is having any issue.
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// CustomResourceName - READ-ONLY; Gets the name of the corresponding resource in Kubernetes.
	CustomResourceName *string `json:"customResourceName,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VCenterProperties.
func (vcp VCenterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vcp.Fqdn != nil {
		objectMap["fqdn"] = vcp.Fqdn
	}
	if vcp.Port != nil {
		objectMap["port"] = vcp.Port
	}
	if vcp.ArcZoneID != nil {
		objectMap["arcZoneId"] = vcp.ArcZoneID
	}
	if vcp.Credentials != nil {
		objectMap["credentials"] = vcp.Credentials
	}
	return json.Marshal(objectMap)
}

// VCentersCreateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type VCentersCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VCentersCreateFuture) Result(client VCentersClient) (vc VCenter, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.VCentersCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.VCentersCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vc.Response.Response, err = future.GetResult(sender); err == nil && vc.Response.Response.StatusCode != http.StatusNoContent {
		vc, err = client.CreateResponder(vc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "arcvmware.VCentersCreateFuture", "Result", vc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VCentersDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type VCentersDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VCentersDeleteFuture) Result(client VCentersClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.VCentersDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.VCentersDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VCentersList list of VCenters.
type VCentersList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of VCenters.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of VCenters
	Value *[]VCenter `json:"value,omitempty"`
}

// VCentersListIterator provides access to a complete listing of VCenter values.
type VCentersListIterator struct {
	i    int
	page VCentersListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VCentersListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VCentersListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VCentersListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VCentersListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VCentersListIterator) Response() VCentersList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VCentersListIterator) Value() VCenter {
	if !iter.page.NotDone() {
		return VCenter{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VCentersListIterator type.
func NewVCentersListIterator(page VCentersListPage) VCentersListIterator {
	return VCentersListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vcl VCentersList) IsEmpty() bool {
	return vcl.Value == nil || len(*vcl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vcl VCentersList) hasNextLink() bool {
	return vcl.NextLink != nil && len(*vcl.NextLink) != 0
}

// vCentersListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vcl VCentersList) vCentersListPreparer(ctx context.Context) (*http.Request, error) {
	if !vcl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vcl.NextLink)))
}

// VCentersListPage contains a page of VCenter values.
type VCentersListPage struct {
	fn  func(context.Context, VCentersList) (VCentersList, error)
	vcl VCentersList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VCentersListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VCentersListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vcl)
		if err != nil {
			return err
		}
		page.vcl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VCentersListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VCentersListPage) NotDone() bool {
	return !page.vcl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VCentersListPage) Response() VCentersList {
	return page.vcl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VCentersListPage) Values() []VCenter {
	if page.vcl.IsEmpty() {
		return nil
	}
	return *page.vcl.Value
}

// Creates a new instance of the VCentersListPage type.
func NewVCentersListPage(getNextPage func(context.Context, VCentersList) (VCentersList, error)) VCentersListPage {
	return VCentersListPage{fn: getNextPage}
}

// VirtualDisk virtual disk model
type VirtualDisk struct {
	// Name - Gets or sets the name of the virtual disk.
	Name *string `json:"name,omitempty"`
	// Label - READ-ONLY; Gets or sets the label of the virtual disk in vCenter.
	Label *string `json:"label,omitempty"`
	// DiskID - READ-ONLY; Gets or sets the disk id.
	DiskID *string `json:"diskId,omitempty"`
	// DiskSizeGB - Gets or sets the disk total size.
	DiskSizeGB *int32 `json:"diskSizeGB,omitempty"`
	// DiskName - READ-ONLY; Gets or sets the disk name.
	DiskName *string `json:"diskName,omitempty"`
	// DeviceKey - Gets or sets the device key value.
	DeviceKey *int32 `json:"deviceKey,omitempty"`
	// DiskMode - Gets or sets the disk mode. Possible values include: 'DiskMode1Persistent', 'DiskMode1Nonpersistent', 'DiskMode1Undoable', 'DiskMode1IndependentPersistent', 'DiskMode1IndependentNonpersistent', 'DiskMode1Append'
	DiskMode DiskMode1 `json:"diskMode,omitempty"`
	// ControllerKey - Gets or sets the controller id.
	ControllerKey *int32 `json:"controllerKey,omitempty"`
	// UnitNumber - Gets or sets the unit number of the disk on the controller.
	UnitNumber *int32 `json:"unitNumber,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualDisk.
func (vd VirtualDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vd.Name != nil {
		objectMap["name"] = vd.Name
	}
	if vd.DiskSizeGB != nil {
		objectMap["diskSizeGB"] = vd.DiskSizeGB
	}
	if vd.DeviceKey != nil {
		objectMap["deviceKey"] = vd.DeviceKey
	}
	if vd.DiskMode != "" {
		objectMap["diskMode"] = vd.DiskMode
	}
	if vd.ControllerKey != nil {
		objectMap["controllerKey"] = vd.ControllerKey
	}
	if vd.UnitNumber != nil {
		objectMap["unitNumber"] = vd.UnitNumber
	}
	return json.Marshal(objectMap)
}

// VirtualDiskUpdate defines the virtual disk update.
type VirtualDiskUpdate struct {
	// Name - Gets or sets the name of the virtual disk.
	Name *string `json:"name,omitempty"`
	// DiskSizeGB - Gets or sets the disk total size.
	DiskSizeGB *int32 `json:"diskSizeGB,omitempty"`
	// DeviceKey - Gets or sets the device key value.
	DeviceKey *int32 `json:"deviceKey,omitempty"`
	// DiskMode - Gets or sets the disk mode. Possible values include: 'Persistent', 'Nonpersistent', 'Undoable', 'IndependentPersistent', 'IndependentNonpersistent', 'Append'
	DiskMode DiskMode `json:"diskMode,omitempty"`
	// ControllerKey - Gets or sets the controller id.
	ControllerKey *int32 `json:"controllerKey,omitempty"`
	// UnitNumber - Gets or sets the unit number of the disk on the controller.
	UnitNumber *int32 `json:"unitNumber,omitempty"`
}

// VirtualMachine define the virtualMachine.
type VirtualMachine struct {
	autorest.Response `json:"-"`
	// VirtualMachineProperties - Resource properties.
	*VirtualMachineProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Identity - READ-ONLY; Gets or sets the identity.
	Identity *string `json:"identity,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualMachine.
func (VM VirtualMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if VM.VirtualMachineProperties != nil {
		objectMap["properties"] = VM.VirtualMachineProperties
	}
	if VM.Location != nil {
		objectMap["location"] = VM.Location
	}
	if VM.Tags != nil {
		objectMap["tags"] = VM.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualMachine struct.
func (VM *VirtualMachine) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualMachineProperties VirtualMachineProperties
				err = json.Unmarshal(*v, &virtualMachineProperties)
				if err != nil {
					return err
				}
				VM.VirtualMachineProperties = &virtualMachineProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				VM.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				VM.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				VM.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				VM.ID = &ID
			}
		case "identity":
			if v != nil {
				var identity string
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				VM.Identity = &identity
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				VM.Type = &typeVar
			}
		}
	}

	return nil
}

// VirtualMachineProperties defines the resource properties.
type VirtualMachineProperties struct {
	// UUID - READ-ONLY; Gets or sets a unique identifier for this resource.
	UUID *string `json:"uuid,omitempty"`
	// ResourcePoolID - Gets or sets the ARM Id of the resourcePool resource on which this virtual machine will
	// deploy.
	ResourcePoolID *string `json:"resourcePoolId,omitempty"`
	// TemplateID - Gets or sets the ARM Id of the template resource to deploy the virtual machine.
	TemplateID *string `json:"templateId,omitempty"`
	// ArcZoneID - Gets or sets the ARM Id of the arcZone of the vCenter.
	ArcZoneID *string `json:"arcZoneId,omitempty"`
	// VCenterID - Gets or sets the ARM Id of the vCenter resource in which this resource pool resides.
	VCenterID *string `json:"vCenterId,omitempty"`
	// OsProfile - OS properties.
	OsProfile *OsProfile `json:"osProfile,omitempty"`
	// HardwareProfile - Hardware properties.
	HardwareProfile *HardwareProfile `json:"hardwareProfile,omitempty"`
	// NetworkProfile - Network properties.
	NetworkProfile *NetworkProfile `json:"networkProfile,omitempty"`
	// StorageProfile - Storage properties.
	StorageProfile *StorageProfile `json:"storageProfile,omitempty"`
	// MoRefID - READ-ONLY; Gets or sets the vCenter MoRef (Managed Object Reference) ID for the virtual machine.
	MoRefID *string `json:"moRefId,omitempty"`
	// MoName - READ-ONLY; Gets or sets the vCenter Managed Object name for the virtual machine.
	MoName *string `json:"moName,omitempty"`
	// FolderPath - READ-ONLY; Gets or sets the folder path of the vm.
	FolderPath *string `json:"folderPath,omitempty"`
	// Status - READ-ONLY; Gets or sets the status of the resource.
	Status *string `json:"status,omitempty"`
	// InstanceUUID - READ-ONLY; Gets or sets the instance uuid of the vm.
	InstanceUUID *string `json:"instanceUuid,omitempty"`
	// PowerState - READ-ONLY; Gets the power state of the virtual machine.
	PowerState *string `json:"powerState,omitempty"`
	// CustomResourceName - READ-ONLY; Gets the name of the corresponding resource in Kubernetes.
	CustomResourceName *string `json:"customResourceName,omitempty"`
	// Conditions - READ-ONLY; Defines a list of readiness conditions for the vm.
	Conditions *[]Condition `json:"conditions,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualMachineProperties.
func (vmp VirtualMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vmp.ResourcePoolID != nil {
		objectMap["resourcePoolId"] = vmp.ResourcePoolID
	}
	if vmp.TemplateID != nil {
		objectMap["templateId"] = vmp.TemplateID
	}
	if vmp.ArcZoneID != nil {
		objectMap["arcZoneId"] = vmp.ArcZoneID
	}
	if vmp.VCenterID != nil {
		objectMap["vCenterId"] = vmp.VCenterID
	}
	if vmp.OsProfile != nil {
		objectMap["osProfile"] = vmp.OsProfile
	}
	if vmp.HardwareProfile != nil {
		objectMap["hardwareProfile"] = vmp.HardwareProfile
	}
	if vmp.NetworkProfile != nil {
		objectMap["networkProfile"] = vmp.NetworkProfile
	}
	if vmp.StorageProfile != nil {
		objectMap["storageProfile"] = vmp.StorageProfile
	}
	return json.Marshal(objectMap)
}

// VirtualMachinesCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualMachinesCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VirtualMachinesCreateFuture) Result(client VirtualMachinesClient) (VM VirtualMachine, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.VirtualMachinesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.VirtualMachinesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if VM.Response.Response, err = future.GetResult(sender); err == nil && VM.Response.Response.StatusCode != http.StatusNoContent {
		VM, err = client.CreateResponder(VM.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "arcvmware.VirtualMachinesCreateFuture", "Result", VM.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualMachinesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualMachinesDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VirtualMachinesDeleteFuture) Result(client VirtualMachinesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.VirtualMachinesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.VirtualMachinesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualMachinesList list of VirtualMachines.
type VirtualMachinesList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of VirtualMachines.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of VirtualMachines
	Value *[]VirtualMachine `json:"value,omitempty"`
}

// VirtualMachinesListIterator provides access to a complete listing of VirtualMachine values.
type VirtualMachinesListIterator struct {
	i    int
	page VirtualMachinesListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualMachinesListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualMachinesListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualMachinesListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualMachinesListIterator) Response() VirtualMachinesList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualMachinesListIterator) Value() VirtualMachine {
	if !iter.page.NotDone() {
		return VirtualMachine{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualMachinesListIterator type.
func NewVirtualMachinesListIterator(page VirtualMachinesListPage) VirtualMachinesListIterator {
	return VirtualMachinesListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vml VirtualMachinesList) IsEmpty() bool {
	return vml.Value == nil || len(*vml.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vml VirtualMachinesList) hasNextLink() bool {
	return vml.NextLink != nil && len(*vml.NextLink) != 0
}

// virtualMachinesListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vml VirtualMachinesList) virtualMachinesListPreparer(ctx context.Context) (*http.Request, error) {
	if !vml.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vml.NextLink)))
}

// VirtualMachinesListPage contains a page of VirtualMachine values.
type VirtualMachinesListPage struct {
	fn  func(context.Context, VirtualMachinesList) (VirtualMachinesList, error)
	vml VirtualMachinesList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualMachinesListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vml)
		if err != nil {
			return err
		}
		page.vml = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualMachinesListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualMachinesListPage) NotDone() bool {
	return !page.vml.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualMachinesListPage) Response() VirtualMachinesList {
	return page.vml
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualMachinesListPage) Values() []VirtualMachine {
	if page.vml.IsEmpty() {
		return nil
	}
	return *page.vml.Value
}

// Creates a new instance of the VirtualMachinesListPage type.
func NewVirtualMachinesListPage(getNextPage func(context.Context, VirtualMachinesList) (VirtualMachinesList, error)) VirtualMachinesListPage {
	return VirtualMachinesListPage{fn: getNextPage}
}

// VirtualMachinesRestartFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualMachinesRestartFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VirtualMachinesRestartFuture) Result(client VirtualMachinesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.VirtualMachinesRestartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.VirtualMachinesRestartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualMachinesStartFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualMachinesStartFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VirtualMachinesStartFuture) Result(client VirtualMachinesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.VirtualMachinesStartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.VirtualMachinesStartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualMachinesStopFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualMachinesStopFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VirtualMachinesStopFuture) Result(client VirtualMachinesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.VirtualMachinesStopFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.VirtualMachinesStopFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualMachinesUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualMachinesUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VirtualMachinesUpdateFuture) Result(client VirtualMachinesClient) (VM VirtualMachine, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.VirtualMachinesUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.VirtualMachinesUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if VM.Response.Response, err = future.GetResult(sender); err == nil && VM.Response.Response.StatusCode != http.StatusNoContent {
		VM, err = client.UpdateResponder(VM.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "arcvmware.VirtualMachinesUpdateFuture", "Result", VM.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualMachineTemplate define the virtualMachineTemplate.
type VirtualMachineTemplate struct {
	autorest.Response `json:"-"`
	// VirtualMachineTemplateProperties - Resource properties.
	*VirtualMachineTemplateProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Identity - READ-ONLY; Gets or sets the identity.
	Identity *string `json:"identity,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualMachineTemplate.
func (vmt VirtualMachineTemplate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vmt.VirtualMachineTemplateProperties != nil {
		objectMap["properties"] = vmt.VirtualMachineTemplateProperties
	}
	if vmt.Location != nil {
		objectMap["location"] = vmt.Location
	}
	if vmt.Tags != nil {
		objectMap["tags"] = vmt.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualMachineTemplate struct.
func (vmt *VirtualMachineTemplate) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualMachineTemplateProperties VirtualMachineTemplateProperties
				err = json.Unmarshal(*v, &virtualMachineTemplateProperties)
				if err != nil {
					return err
				}
				vmt.VirtualMachineTemplateProperties = &virtualMachineTemplateProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vmt.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vmt.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vmt.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vmt.ID = &ID
			}
		case "identity":
			if v != nil {
				var identity string
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				vmt.Identity = &identity
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vmt.Type = &typeVar
			}
		}
	}

	return nil
}

// VirtualMachineTemplateProperties defines the resource properties.
type VirtualMachineTemplateProperties struct {
	// UUID - READ-ONLY; Gets or sets a unique identifier for this resource.
	UUID *string `json:"uuid,omitempty"`
	// VCenterID - Gets or sets the ARM Id of the vCenter resource in which this template resides.
	VCenterID *string `json:"vCenterId,omitempty"`
	// MoRefID - Gets or sets the vCenter MoRef (Managed Object Reference) ID for the virtual machine
	// template.
	MoRefID *string `json:"moRefId,omitempty"`
	// ArcZoneID - Gets or sets the ARM Id of the arcZone of the vCenter.
	ArcZoneID *string `json:"arcZoneId,omitempty"`
	// MoName - READ-ONLY; Gets or sets the vCenter Managed Object name for the virtual machine template.
	MoName *string `json:"moName,omitempty"`
	// MemorySizeMB - READ-ONLY; Gets or sets memory size in MBs for the template.
	MemorySizeMB *int32 `json:"memorySizeMB,omitempty"`
	// NumCPUs - READ-ONLY; Gets or sets the number of vCPUs for the template.
	NumCPUs *int32 `json:"numCPUs,omitempty"`
	// NumCoresPerSocket - READ-ONLY; Gets or sets the number of cores per socket for the template.
	// Defaults to 1 if unspecified.
	NumCoresPerSocket *int32 `json:"numCoresPerSocket,omitempty"`
	// OsType - READ-ONLY; Gets or sets the type of the os. Possible values include: 'OsType1Windows', 'OsType1Linux', 'OsType1Other'
	OsType OsType1 `json:"osType,omitempty"`
	// OsName - READ-ONLY; Gets or sets os name.
	OsName *string `json:"osName,omitempty"`
	// FolderPath - READ-ONLY; Gets or sets the folder path of the template.
	FolderPath *string `json:"folderPath,omitempty"`
	// NetworkInterfaces - READ-ONLY; Gets or sets the network interfaces of the template.
	NetworkInterfaces *[]NetworkInterface `json:"networkInterfaces,omitempty"`
	// Disks - READ-ONLY; Gets or sets the disks the template.
	Disks *[]VirtualDisk `json:"disks,omitempty"`
	// Status - READ-ONLY; Gets or sets the status of the resource.
	Status *string `json:"status,omitempty"`
	// CustomResourceName - READ-ONLY; Gets the name of the corresponding resource in Kubernetes.
	CustomResourceName *string `json:"customResourceName,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualMachineTemplateProperties.
func (vmtp VirtualMachineTemplateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vmtp.VCenterID != nil {
		objectMap["vCenterId"] = vmtp.VCenterID
	}
	if vmtp.MoRefID != nil {
		objectMap["moRefId"] = vmtp.MoRefID
	}
	if vmtp.ArcZoneID != nil {
		objectMap["arcZoneId"] = vmtp.ArcZoneID
	}
	return json.Marshal(objectMap)
}

// VirtualMachineTemplatesCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualMachineTemplatesCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VirtualMachineTemplatesCreateFuture) Result(client VirtualMachineTemplatesClient) (vmt VirtualMachineTemplate, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.VirtualMachineTemplatesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.VirtualMachineTemplatesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vmt.Response.Response, err = future.GetResult(sender); err == nil && vmt.Response.Response.StatusCode != http.StatusNoContent {
		vmt, err = client.CreateResponder(vmt.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "arcvmware.VirtualMachineTemplatesCreateFuture", "Result", vmt.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualMachineTemplatesDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualMachineTemplatesDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VirtualMachineTemplatesDeleteFuture) Result(client VirtualMachineTemplatesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.VirtualMachineTemplatesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.VirtualMachineTemplatesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualMachineTemplatesList list of VirtualMachineTemplates.
type VirtualMachineTemplatesList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of VirtualMachineTemplates.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of VirtualMachineTemplates
	Value *[]VirtualMachineTemplate `json:"value,omitempty"`
}

// VirtualMachineTemplatesListIterator provides access to a complete listing of VirtualMachineTemplate values.
type VirtualMachineTemplatesListIterator struct {
	i    int
	page VirtualMachineTemplatesListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualMachineTemplatesListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachineTemplatesListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualMachineTemplatesListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualMachineTemplatesListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualMachineTemplatesListIterator) Response() VirtualMachineTemplatesList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualMachineTemplatesListIterator) Value() VirtualMachineTemplate {
	if !iter.page.NotDone() {
		return VirtualMachineTemplate{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualMachineTemplatesListIterator type.
func NewVirtualMachineTemplatesListIterator(page VirtualMachineTemplatesListPage) VirtualMachineTemplatesListIterator {
	return VirtualMachineTemplatesListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vmtl VirtualMachineTemplatesList) IsEmpty() bool {
	return vmtl.Value == nil || len(*vmtl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vmtl VirtualMachineTemplatesList) hasNextLink() bool {
	return vmtl.NextLink != nil && len(*vmtl.NextLink) != 0
}

// virtualMachineTemplatesListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vmtl VirtualMachineTemplatesList) virtualMachineTemplatesListPreparer(ctx context.Context) (*http.Request, error) {
	if !vmtl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vmtl.NextLink)))
}

// VirtualMachineTemplatesListPage contains a page of VirtualMachineTemplate values.
type VirtualMachineTemplatesListPage struct {
	fn   func(context.Context, VirtualMachineTemplatesList) (VirtualMachineTemplatesList, error)
	vmtl VirtualMachineTemplatesList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualMachineTemplatesListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachineTemplatesListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vmtl)
		if err != nil {
			return err
		}
		page.vmtl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualMachineTemplatesListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualMachineTemplatesListPage) NotDone() bool {
	return !page.vmtl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualMachineTemplatesListPage) Response() VirtualMachineTemplatesList {
	return page.vmtl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualMachineTemplatesListPage) Values() []VirtualMachineTemplate {
	if page.vmtl.IsEmpty() {
		return nil
	}
	return *page.vmtl.Value
}

// Creates a new instance of the VirtualMachineTemplatesListPage type.
func NewVirtualMachineTemplatesListPage(getNextPage func(context.Context, VirtualMachineTemplatesList) (VirtualMachineTemplatesList, error)) VirtualMachineTemplatesListPage {
	return VirtualMachineTemplatesListPage{fn: getNextPage}
}

// VirtualMachineUpdate defines the virtualMachineUpdate.
type VirtualMachineUpdate struct {
	Properties *VirtualMachineUpdateProperties `json:"properties,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VirtualMachineUpdate.
func (vmu VirtualMachineUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vmu.Properties != nil {
		objectMap["properties"] = vmu.Properties
	}
	if vmu.Tags != nil {
		objectMap["tags"] = vmu.Tags
	}
	return json.Marshal(objectMap)
}

// VirtualMachineUpdateProperties defines the resource properties.
type VirtualMachineUpdateProperties struct {
	HardwareProfile *HardwareProfile      `json:"hardwareProfile,omitempty"`
	StorageProfile  *StorageProfileUpdate `json:"storageProfile,omitempty"`
	NetworkProfile  *NetworkProfileUpdate `json:"networkProfile,omitempty"`
}

// VirtualNetwork define the virtualNetwork.
type VirtualNetwork struct {
	autorest.Response `json:"-"`
	// VirtualNetworkProperties - Resource properties.
	*VirtualNetworkProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Identity - READ-ONLY; Gets or sets the identity.
	Identity *string `json:"identity,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetwork.
func (vn VirtualNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vn.VirtualNetworkProperties != nil {
		objectMap["properties"] = vn.VirtualNetworkProperties
	}
	if vn.Location != nil {
		objectMap["location"] = vn.Location
	}
	if vn.Tags != nil {
		objectMap["tags"] = vn.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualNetwork struct.
func (vn *VirtualNetwork) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualNetworkProperties VirtualNetworkProperties
				err = json.Unmarshal(*v, &virtualNetworkProperties)
				if err != nil {
					return err
				}
				vn.VirtualNetworkProperties = &virtualNetworkProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vn.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vn.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vn.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vn.ID = &ID
			}
		case "identity":
			if v != nil {
				var identity string
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				vn.Identity = &identity
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vn.Type = &typeVar
			}
		}
	}

	return nil
}

// VirtualNetworkProperties defines the resource properties.
type VirtualNetworkProperties struct {
	// UUID - READ-ONLY; Gets or sets a unique identifier for this resource.
	UUID *string `json:"uuid,omitempty"`
	// VCenterID - Gets or sets the ARM Id of the vCenter resource in which this template resides.
	VCenterID *string `json:"vCenterId,omitempty"`
	// MoRefID - Gets or sets the vCenter MoRef (Managed Object Reference) ID for the virtual network.
	MoRefID *string `json:"moRefId,omitempty"`
	// ArcZoneID - Gets or sets the ARM Id of the arcZone of the vCenter.
	ArcZoneID *string `json:"arcZoneId,omitempty"`
	// MoName - READ-ONLY; Gets or sets the vCenter Managed Object name for the virtual network.
	MoName *string `json:"moName,omitempty"`
	// Status - READ-ONLY; Gets or sets the status of the resource.
	Status *string `json:"status,omitempty"`
	// CustomResourceName - READ-ONLY; Gets the name of the corresponding resource in Kubernetes.
	CustomResourceName *string `json:"customResourceName,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkProperties.
func (vnp VirtualNetworkProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vnp.VCenterID != nil {
		objectMap["vCenterId"] = vnp.VCenterID
	}
	if vnp.MoRefID != nil {
		objectMap["moRefId"] = vnp.MoRefID
	}
	if vnp.ArcZoneID != nil {
		objectMap["arcZoneId"] = vnp.ArcZoneID
	}
	return json.Marshal(objectMap)
}

// VirtualNetworksCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualNetworksCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VirtualNetworksCreateFuture) Result(client VirtualNetworksClient) (vn VirtualNetwork, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.VirtualNetworksCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.VirtualNetworksCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vn.Response.Response, err = future.GetResult(sender); err == nil && vn.Response.Response.StatusCode != http.StatusNoContent {
		vn, err = client.CreateResponder(vn.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "arcvmware.VirtualNetworksCreateFuture", "Result", vn.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworksDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualNetworksDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VirtualNetworksDeleteFuture) Result(client VirtualNetworksClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "arcvmware.VirtualNetworksDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("arcvmware.VirtualNetworksDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualNetworksList list of VirtualNetworks.
type VirtualNetworksList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of VirtualNetworks.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of VirtualNetworks
	Value *[]VirtualNetwork `json:"value,omitempty"`
}

// VirtualNetworksListIterator provides access to a complete listing of VirtualNetwork values.
type VirtualNetworksListIterator struct {
	i    int
	page VirtualNetworksListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualNetworksListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworksListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualNetworksListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualNetworksListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualNetworksListIterator) Response() VirtualNetworksList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualNetworksListIterator) Value() VirtualNetwork {
	if !iter.page.NotDone() {
		return VirtualNetwork{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualNetworksListIterator type.
func NewVirtualNetworksListIterator(page VirtualNetworksListPage) VirtualNetworksListIterator {
	return VirtualNetworksListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vnl VirtualNetworksList) IsEmpty() bool {
	return vnl.Value == nil || len(*vnl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vnl VirtualNetworksList) hasNextLink() bool {
	return vnl.NextLink != nil && len(*vnl.NextLink) != 0
}

// virtualNetworksListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vnl VirtualNetworksList) virtualNetworksListPreparer(ctx context.Context) (*http.Request, error) {
	if !vnl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vnl.NextLink)))
}

// VirtualNetworksListPage contains a page of VirtualNetwork values.
type VirtualNetworksListPage struct {
	fn  func(context.Context, VirtualNetworksList) (VirtualNetworksList, error)
	vnl VirtualNetworksList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualNetworksListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworksListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vnl)
		if err != nil {
			return err
		}
		page.vnl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualNetworksListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualNetworksListPage) NotDone() bool {
	return !page.vnl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualNetworksListPage) Response() VirtualNetworksList {
	return page.vnl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualNetworksListPage) Values() []VirtualNetwork {
	if page.vnl.IsEmpty() {
		return nil
	}
	return *page.vnl.Value
}

// Creates a new instance of the VirtualNetworksListPage type.
func NewVirtualNetworksListPage(getNextPage func(context.Context, VirtualNetworksList) (VirtualNetworksList, error)) VirtualNetworksListPage {
	return VirtualNetworksListPage{fn: getNextPage}
}

// VirtualSCSIController this data object type contains the properties of a SCSI controller device attached to
// a virtual machine that is reported by the controller.
type VirtualSCSIController struct {
	// Type - Gets or sets the controller type. Possible values include: 'Lsilogic', 'Buslogic', 'Pvscsi', 'Lsilogicsas'
	Type Type1 `json:"type,omitempty"`
	// ControllerKey - Gets or sets the key of the controller.
	ControllerKey *int32 `json:"controllerKey,omitempty"`
	// BusNumber - Gets or sets the bus number of the controller.
	BusNumber *int32 `json:"busNumber,omitempty"`
	// ScsiCtlrUnitNumber - Gets or sets the SCSI controller unit number.
	ScsiCtlrUnitNumber *int32 `json:"scsiCtlrUnitNumber,omitempty"`
	// Sharing - Gets or sets the sharing mode. Possible values include: 'NoSharing', 'PhysicalSharing', 'VirtualSharing'
	Sharing Sharing `json:"sharing,omitempty"`
}
