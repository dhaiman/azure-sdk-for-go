package anybuild

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "context"
    "encoding/json"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "github.com/Azure/go-autorest/autorest/to"
    "github.com/Azure/go-autorest/tracing"
    "net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/anybuild/2020-08-26"

        // AgentOs describes the type of operating system to use for agents in this pool.
        type AgentOs struct {
        // OsOffer - The offer of base image used to create agents in the pool. For more information see [ImageReference.offer](https://docs.microsoft.com/en-us/rest/api/compute/virtualmachinescalesets/get#imagereference).
        OsOffer *string `json:"osOffer,omitempty"`
        // OsSKU - The SKU of base image used to create agents in the pool. For more information see [ImageReference.sku](https://docs.microsoft.com/en-us/rest/api/compute/virtualmachinescalesets/get#imagereference).
        OsSKU *string `json:"osSKU,omitempty"`
        }

        // AzureEntityResource the resource model definition for a Azure Resource Manager resource with an etag.
        type AzureEntityResource struct {
        // Etag - READ-ONLY; Resource Etag.
        Etag *string `json:"etag,omitempty"`
        // ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
        Type *string `json:"type,omitempty"`
        }

        // Cluster detailed information about AnyBuild cluster and its pools of agents.
        type Cluster struct {
        autorest.Response `json:"-"`
        *ClusterProperties `json:"properties,omitempty"`
        // Tags - Resource tags.
        Tags map[string]*string `json:"tags"`
        // Location - The geo-location where the resource lives
        Location *string `json:"location,omitempty"`
        // ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
        Type *string `json:"type,omitempty"`
        }

        // MarshalJSON is the custom marshaler for Cluster.
        func (c Cluster)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(c.ClusterProperties != nil) {
                objectMap["properties"] = c.ClusterProperties
                }
                if(c.Tags != nil) {
                objectMap["tags"] = c.Tags
                }
                if(c.Location != nil) {
                objectMap["location"] = c.Location
                }
                return json.Marshal(objectMap)
        }
        // UnmarshalJSON is the custom unmarshaler for Cluster struct.
        func (c *Cluster) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "properties":
    if v != nil {
        var clusterProperties ClusterProperties
        err = json.Unmarshal(*v, &clusterProperties)
        if err != nil {
    return err
    }
        c.ClusterProperties = &clusterProperties
    }
                case "tags":
    if v != nil {
        var tags map[string]*string
        err = json.Unmarshal(*v, &tags)
        if err != nil {
    return err
    }
        c.Tags = tags
    }
                case "location":
    if v != nil {
        var location string
        err = json.Unmarshal(*v, &location)
        if err != nil {
    return err
    }
        c.Location = &location
    }
                case "id":
    if v != nil {
        var ID string
        err = json.Unmarshal(*v, &ID)
        if err != nil {
    return err
    }
        c.ID = &ID
    }
                case "name":
    if v != nil {
        var name string
        err = json.Unmarshal(*v, &name)
        if err != nil {
    return err
    }
        c.Name = &name
    }
                case "type":
    if v != nil {
        var typeVar string
        err = json.Unmarshal(*v, &typeVar)
        if err != nil {
    return err
    }
        c.Type = &typeVar
    }
            }
        }

        return nil
        }

        // ClusterListResult list of all clusters.
        type ClusterListResult struct {
        autorest.Response `json:"-"`
        Value *[]Cluster `json:"value,omitempty"`
        // NextLink - The URI to fetch the next page of clusters. Call ListNext() with this URI to fetch the next page of clusters.
        NextLink *string `json:"nextLink,omitempty"`
        }

        // ClusterListResultIterator provides access to a complete listing of Cluster values.
        type ClusterListResultIterator struct {
            i int
            page ClusterListResultPage
        }
        // NextWithContext advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        func (iter * ClusterListResultIterator) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ClusterListResultIterator.NextWithContext")
        defer func() {
        sc := -1
        if iter.Response().Response.Response != nil {
        sc = iter.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        iter.i++
        if iter.i < len(iter. page.Values()) {
        return nil
        }
        err = iter.page.NextWithContext(ctx)
        if err != nil {
        iter. i--
        return err
        }
        iter.i = 0
        return nil
        }
        // Next advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (iter * ClusterListResultIterator) Next() error {
        return iter.NextWithContext(context.Background())
        }
        // NotDone returns true if the enumeration should be started or is not yet complete.
        func (iter ClusterListResultIterator) NotDone() bool {
        return iter.page.NotDone() && iter.i < len(iter. page.Values())
        }
        // Response returns the raw server response from the last page request.
        func (iter ClusterListResultIterator) Response() ClusterListResult {
        return iter.page.Response()
        }
        // Value returns the current value or a zero-initialized value if the
        // iterator has advanced beyond the end of the collection.
        func (iter ClusterListResultIterator) Value() Cluster {
        if !iter.page.NotDone() {
        return Cluster{}
        }
        return iter.page.Values()[iter.i]
        }
        // Creates a new instance of the ClusterListResultIterator type.
        func NewClusterListResultIterator (page ClusterListResultPage) ClusterListResultIterator {
            return ClusterListResultIterator{page: page}
        }


            // IsEmpty returns true if the ListResult contains no values.
            func (clr ClusterListResult) IsEmpty() bool {
            return clr.Value == nil || len(*clr.Value) == 0
            }

            // hasNextLink returns true if the NextLink is not empty.
            func (clr ClusterListResult) hasNextLink() bool {
            return clr.NextLink != nil && len(*clr.NextLink) != 0
            }
                // clusterListResultPreparer prepares a request to retrieve the next set of results.
                // It returns nil if no more results exist.
                func (clr ClusterListResult) clusterListResultPreparer(ctx context.Context) (*http.Request, error) {
                if !clr.hasNextLink() {
                return nil, nil
                }
                return autorest.Prepare((&http.Request{}).WithContext(ctx),
                autorest.AsJSON(),
                autorest.AsGet(),
                autorest.WithBaseURL(to.String( clr.NextLink)));
                }

        // ClusterListResultPage contains a page of Cluster values.
        type ClusterListResultPage struct {
            fn func(context.Context, ClusterListResult) (ClusterListResult, error)
            clr ClusterListResult
        }

        // NextWithContext advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        func (page * ClusterListResultPage) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/ClusterListResultPage.NextWithContext")
        defer func() {
        sc := -1
        if page.Response().Response.Response != nil {
        sc = page.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        for {
            next, err := page.fn(ctx, page.clr)
            if err != nil {
            return err
            }
            page.clr = next
            if !next.hasNextLink() || !next.IsEmpty() {
                break
            }
        }
        return nil
        }

        // Next advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (page * ClusterListResultPage) Next() error {
        return page.NextWithContext(context.Background())
        }
        // NotDone returns true if the page enumeration should be started or is not yet complete.
        func (page ClusterListResultPage) NotDone() bool {
        return !page.clr.IsEmpty()
        }
        // Response returns the raw server response from the last page request.
        func (page ClusterListResultPage) Response() ClusterListResult {
        return page.clr
        }
        // Values returns the slice of values for the current page or nil if there are no values.
        func (page ClusterListResultPage) Values() []Cluster {
        if page.clr.IsEmpty() {
        return nil
        }
        return *page.clr.Value
        }
        // Creates a new instance of the ClusterListResultPage type.
        func NewClusterListResultPage (getNextPage func(context.Context, ClusterListResult) (ClusterListResult, error)) ClusterListResultPage {
            return ClusterListResultPage{fn: getNextPage}
        }

        // ClusterProperties describes the properties of a Cluster.
        type ClusterProperties struct {
        // ProvisioningState - READ-ONLY; Provisioning state of the cluster. Possible values include: 'Creating', 'Updating', 'Deflating', 'Deleting', 'Succeeded', 'Failed', 'Canceled'
        ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
        // AgentsMode - Possible values include: 'Inflated', 'Deflated'
        AgentsMode AgentsMode `json:"agentsMode,omitempty"`
        // ClusterURI - READ-ONLY; The fully-qualified cluster URI.
        ClusterURI *string `json:"clusterUri,omitempty"`
        // Pools - List of agent pools in the cluster.
        Pools *[]Pool `json:"pools,omitempty"`
        }

        // MarshalJSON is the custom marshaler for ClusterProperties.
        func (cp ClusterProperties)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(cp.AgentsMode != "") {
                objectMap["agentsMode"] = cp.AgentsMode
                }
                if(cp.Pools != nil) {
                objectMap["pools"] = cp.Pools
                }
                return json.Marshal(objectMap)
        }

        // ClusterResetParameters parameters for Resetting a Cluster.
        type ClusterResetParameters struct {
        // AgentsMode - Controls the mode of agents in the cluster after the reset operation is complete. Possible values include: 'Inflated', 'Deflated'
        AgentsMode AgentsMode `json:"agentsMode,omitempty"`
        }

        // ClustersCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
        // operation.
        type ClustersCreateOrUpdateFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *ClustersCreateOrUpdateFuture) Result(client ClustersClient) (c Cluster, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "anybuild.ClustersCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("anybuild.ClustersCreateOrUpdateFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if c.Response.Response, err = future.GetResult(sender); err == nil && c.Response.Response.StatusCode != http.StatusNoContent {
            c, err = client.CreateOrUpdateResponder(c.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "anybuild.ClustersCreateOrUpdateFuture", "Result", c.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // ClustersDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
        type ClustersDeleteFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *ClustersDeleteFuture) Result(client ClustersClient) (ar autorest.Response, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "anybuild.ClustersDeleteFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("anybuild.ClustersDeleteFuture")
        return
        }
            ar.Response = future.Response()
        return
        }

        // ClustersResetFuture an abstraction for monitoring and retrieving the results of a long-running operation.
        type ClustersResetFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *ClustersResetFuture) Result(client ClustersClient) (ar autorest.Response, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "anybuild.ClustersResetFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("anybuild.ClustersResetFuture")
        return
        }
            ar.Response = future.Response()
        return
        }

        // ClustersUpdateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
        type ClustersUpdateFuture struct {
            azure.Future
        }
        // Result returns the result of the asynchronous operation.
        // If the operation has not completed it will return an error.
        func (future *ClustersUpdateFuture) Result(client ClustersClient) (c Cluster, err error) {
        var done bool
        done, err = future.DoneWithContext(context.Background(), client)
        if err != nil {
        err = autorest.NewErrorWithError(err, "anybuild.ClustersUpdateFuture", "Result", future.Response(), "Polling failure")
        return
        }
        if !done {
        err = azure.NewAsyncOpIncompleteError("anybuild.ClustersUpdateFuture")
        return
        }
            sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
            if c.Response.Response, err = future.GetResult(sender); err == nil && c.Response.Response.StatusCode != http.StatusNoContent {
            c, err = client.UpdateResponder(c.Response.Response)
            if err != nil {
            err = autorest.NewErrorWithError(err, "anybuild.ClustersUpdateFuture", "Result", c.Response.Response, "Failure responding to request")
            }
            }
            return
        }

        // ClusterUpdate updated information for AnyBuild cluster and its pools of agents.
        type ClusterUpdate struct {
        *ClusterProperties `json:"properties,omitempty"`
        // Tags - Resource tags
        Tags map[string]*string `json:"tags"`
        }

        // MarshalJSON is the custom marshaler for ClusterUpdate.
        func (cu ClusterUpdate)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(cu.ClusterProperties != nil) {
                objectMap["properties"] = cu.ClusterProperties
                }
                if(cu.Tags != nil) {
                objectMap["tags"] = cu.Tags
                }
                return json.Marshal(objectMap)
        }
        // UnmarshalJSON is the custom unmarshaler for ClusterUpdate struct.
        func (cu *ClusterUpdate) UnmarshalJSON(body []byte) error {
        var m map[string]*json.RawMessage
        err := json.Unmarshal(body, &m)
        if err != nil {
        return err
        }
        for k, v := range  m {
        switch k {
                case "properties":
    if v != nil {
        var clusterProperties ClusterProperties
        err = json.Unmarshal(*v, &clusterProperties)
        if err != nil {
    return err
    }
        cu.ClusterProperties = &clusterProperties
    }
                case "tags":
    if v != nil {
        var tags map[string]*string
        err = json.Unmarshal(*v, &tags)
        if err != nil {
    return err
    }
        cu.Tags = tags
    }
            }
        }

        return nil
        }

        // ErrorDefinition error definition.
        type ErrorDefinition struct {
        // Code - READ-ONLY; Service specific error code which serves as the substatus for the HTTP error code.
        Code *string `json:"code,omitempty"`
        // Message - READ-ONLY; Description of the error.
        Message *string `json:"message,omitempty"`
        // Details - READ-ONLY; Internal error details.
        Details *[]ErrorDefinition `json:"details,omitempty"`
        }

        // ErrorResponse error response.
        type ErrorResponse struct {
        // Error - The error details.
        Error *ErrorDefinition `json:"error,omitempty"`
        }

        // Operation describes the properties of AnyBuild operation.
        type Operation struct {
        // Name - The name of AnyBuild operation in format Microsoft.AnyBuild/{resource}/{operation}
        Name *string `json:"name,omitempty"`
        // IsDataAction - True, when operation applies to data-plane. False, for ARM/control-plane operations.
        IsDataAction *bool `json:"isDataAction,omitempty"`
        Display *OperationDisplay `json:"display,omitempty"`
        }

        // OperationDisplay describes the display properties of AnyBuild operation.
        type OperationDisplay struct {
        // Provider - The friendly name of the resource provider for the operation.
        Provider *string `json:"provider,omitempty"`
        // Resource - The localized display name of the resource the operation applies to.
        Resource *string `json:"resource,omitempty"`
        // Operation - The localized friendly name for the operation.
        Operation *string `json:"operation,omitempty"`
        // Description - The localized friendly description for the operation
        Description *string `json:"description,omitempty"`
        }

        // OperationListResult the List AnyBuild operations response.
        type OperationListResult struct {
        autorest.Response `json:"-"`
        // Value - READ-ONLY; List of AnyBuild operations.
        Value *[]Operation `json:"value,omitempty"`
        // NextLink - The URL to fetch the next page (per server side paging).
        // null for now, added for future use.
        NextLink *string `json:"nextLink,omitempty"`
        }

        // MarshalJSON is the custom marshaler for OperationListResult.
        func (olr OperationListResult)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(olr.NextLink != nil) {
                objectMap["nextLink"] = olr.NextLink
                }
                return json.Marshal(objectMap)
        }

        // OperationListResultIterator provides access to a complete listing of Operation values.
        type OperationListResultIterator struct {
            i int
            page OperationListResultPage
        }
        // NextWithContext advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        func (iter * OperationListResultIterator) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/OperationListResultIterator.NextWithContext")
        defer func() {
        sc := -1
        if iter.Response().Response.Response != nil {
        sc = iter.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        iter.i++
        if iter.i < len(iter. page.Values()) {
        return nil
        }
        err = iter.page.NextWithContext(ctx)
        if err != nil {
        iter. i--
        return err
        }
        iter.i = 0
        return nil
        }
        // Next advances to the next value.  If there was an error making
        // the request the iterator does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (iter * OperationListResultIterator) Next() error {
        return iter.NextWithContext(context.Background())
        }
        // NotDone returns true if the enumeration should be started or is not yet complete.
        func (iter OperationListResultIterator) NotDone() bool {
        return iter.page.NotDone() && iter.i < len(iter. page.Values())
        }
        // Response returns the raw server response from the last page request.
        func (iter OperationListResultIterator) Response() OperationListResult {
        return iter.page.Response()
        }
        // Value returns the current value or a zero-initialized value if the
        // iterator has advanced beyond the end of the collection.
        func (iter OperationListResultIterator) Value() Operation {
        if !iter.page.NotDone() {
        return Operation{}
        }
        return iter.page.Values()[iter.i]
        }
        // Creates a new instance of the OperationListResultIterator type.
        func NewOperationListResultIterator (page OperationListResultPage) OperationListResultIterator {
            return OperationListResultIterator{page: page}
        }


            // IsEmpty returns true if the ListResult contains no values.
            func (olr OperationListResult) IsEmpty() bool {
            return olr.Value == nil || len(*olr.Value) == 0
            }

            // hasNextLink returns true if the NextLink is not empty.
            func (olr OperationListResult) hasNextLink() bool {
            return olr.NextLink != nil && len(*olr.NextLink) != 0
            }
                // operationListResultPreparer prepares a request to retrieve the next set of results.
                // It returns nil if no more results exist.
                func (olr OperationListResult) operationListResultPreparer(ctx context.Context) (*http.Request, error) {
                if !olr.hasNextLink() {
                return nil, nil
                }
                return autorest.Prepare((&http.Request{}).WithContext(ctx),
                autorest.AsJSON(),
                autorest.AsGet(),
                autorest.WithBaseURL(to.String( olr.NextLink)));
                }

        // OperationListResultPage contains a page of Operation values.
        type OperationListResultPage struct {
            fn func(context.Context, OperationListResult) (OperationListResult, error)
            olr OperationListResult
        }

        // NextWithContext advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        func (page * OperationListResultPage) NextWithContext(ctx context.Context) (err error) {
        if tracing.IsEnabled() {
        ctx = tracing.StartSpan(ctx, fqdn + "/OperationListResultPage.NextWithContext")
        defer func() {
        sc := -1
        if page.Response().Response.Response != nil {
        sc = page.Response().Response.Response.StatusCode
        }
        tracing.EndSpan(ctx, sc, err)
        }()
        }
        for {
            next, err := page.fn(ctx, page.olr)
            if err != nil {
            return err
            }
            page.olr = next
            if !next.hasNextLink() || !next.IsEmpty() {
                break
            }
        }
        return nil
        }

        // Next advances to the next page of values.  If there was an error making
        // the request the page does not advance and the error is returned.
        // Deprecated: Use NextWithContext() instead.
        func (page * OperationListResultPage) Next() error {
        return page.NextWithContext(context.Background())
        }
        // NotDone returns true if the page enumeration should be started or is not yet complete.
        func (page OperationListResultPage) NotDone() bool {
        return !page.olr.IsEmpty()
        }
        // Response returns the raw server response from the last page request.
        func (page OperationListResultPage) Response() OperationListResult {
        return page.olr
        }
        // Values returns the slice of values for the current page or nil if there are no values.
        func (page OperationListResultPage) Values() []Operation {
        if page.olr.IsEmpty() {
        return nil
        }
        return *page.olr.Value
        }
        // Creates a new instance of the OperationListResultPage type.
        func NewOperationListResultPage (getNextPage func(context.Context, OperationListResult) (OperationListResult, error)) OperationListResultPage {
            return OperationListResultPage{fn: getNextPage}
        }

        // Pool describes a pool of agents.
        type Pool struct {
        // Cores - The number of cores supported by each agent in the pool.
        Cores *int32 `json:"cores,omitempty"`
        // AgentOs - Details about operating system to use for agents in the pool.
        AgentOs *AgentOs `json:"agentOs,omitempty"`
        // Capacity - The default capacity range of the pool. Scheduled capacity changes can change the range.
        Capacity *PoolCapacity `json:"capacity,omitempty"`
        // Schedules - Schedules for controlling capacity of the pool throughout days the week.
        Schedules *[]PoolSchedule `json:"schedules,omitempty"`
        }

        // PoolCapacity describes capacity range of the pool. Auto-scaling can increase or decrease agent pool counts
        // dynamically within this range.
        type PoolCapacity struct {
        // Minimum - The minimum number of agents in the pool.
        Minimum *int32 `json:"minimum,omitempty"`
        // Maximum - The maximum number of agents in the pool.
        Maximum *int32 `json:"maximum,omitempty"`
        }

        // PoolSchedule schedule for controlling capacity of the pool during the specified time interval.
        type PoolSchedule struct {
        // Capacity - Capacity range of this time interval.
        Capacity *PoolCapacity `json:"capacity,omitempty"`
        // TimeZone - Time zone for the beginning and ending time of this time interval. The values are the same as for [RecurrentSchedule.timeZone](https://docs.microsoft.com/en-us/rest/api/monitor/autoscalesettings/listbyresourcegroup#recurrentschedule).
        TimeZone *string `json:"timeZone,omitempty"`
        // Begin - Time when the time interval begins.
        Begin *TimeOfDay `json:"begin,omitempty"`
        // End - Time when the time interval ends.
        End *TimeOfDay `json:"end,omitempty"`
        }

        // ProxyResource the resource model definition for a ARM proxy resource. It will have everything other than
        // required location and tags
        type ProxyResource struct {
        // ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
        Type *string `json:"type,omitempty"`
        }

        // Resource the resource model definition.
        type Resource struct {
        // ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
        Type *string `json:"type,omitempty"`
        }

        // TimeOfDay time when pool schedule begins or ends.
        type TimeOfDay struct {
        // DayOfWeek - Day of the week. Possible values include: 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
        DayOfWeek DayOfWeek `json:"dayOfWeek,omitempty"`
        // Hour - Hour when pool schedule begins or ends. Values supported are 0 to 23 on the 24-hour clock (AM/PM times are not supported).
        Hour *int32 `json:"hour,omitempty"`
        // Minute - Minute when pool schedule begins or ends.
        Minute *int32 `json:"minute,omitempty"`
        }

        // TrackedResource the resource model definition for a ARM tracked top level resource
        type TrackedResource struct {
        // Tags - Resource tags.
        Tags map[string]*string `json:"tags"`
        // Location - The geo-location where the resource lives
        Location *string `json:"location,omitempty"`
        // ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ID *string `json:"id,omitempty"`
        // Name - READ-ONLY; The name of the resource
        Name *string `json:"name,omitempty"`
        // Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
        Type *string `json:"type,omitempty"`
        }

        // MarshalJSON is the custom marshaler for TrackedResource.
        func (tr TrackedResource)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(tr.Tags != nil) {
                objectMap["tags"] = tr.Tags
                }
                if(tr.Location != nil) {
                objectMap["location"] = tr.Location
                }
                return json.Marshal(objectMap)
        }

        // UpdateResource the Update Resource model definition.
        type UpdateResource struct {
        // Tags - Resource tags
        Tags map[string]*string `json:"tags"`
        }

        // MarshalJSON is the custom marshaler for UpdateResource.
        func (ur UpdateResource)MarshalJSON() ([]byte, error){
        objectMap := make(map[string]interface{})
                if(ur.Tags != nil) {
                objectMap["tags"] = ur.Tags
                }
                return json.Marshal(objectMap)
        }

